{"ast":null,"code":"/**\n * Browser Image Compression\n * v2.0.0\n * by Donald <donaldcwl@gmail.com>\n * https://github.com/Donaldcwl/browser-image-compression\n */\nfunction _mergeNamespaces(e, r) {\n  return r.forEach(function (r) {\n    Object.keys(r).forEach(function (t) {\n      if (\"default\" !== t && !(t in e)) {\n        var a = Object.getOwnPropertyDescriptor(r, t);\n        Object.defineProperty(e, t, a.get ? a : {\n          enumerable: !0,\n          get: function () {\n            return r[t];\n          }\n        });\n      }\n    });\n  }), Object.freeze(e);\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n\n  if (Object.getOwnPropertySymbols) {\n    var a = Object.getOwnPropertySymbols(e);\n    r && (a = a.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, a);\n  }\n\n  return t;\n}\n\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n\n  return e;\n}\n\nfunction _defineProperty(e, r, t) {\n  return r in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction _slicedToArray(e, r) {\n  return _arrayWithHoles(e) || _iterableToArrayLimit(e, r) || _unsupportedIterableToArray(e, r) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(e) {\n  if (Array.isArray(e)) return e;\n}\n\nfunction _iterableToArrayLimit(e, r) {\n  var t = null == e ? null : \"undefined\" != typeof Symbol && e[Symbol.iterator] || e[\"@@iterator\"];\n\n  if (null != t) {\n    var a,\n        i,\n        s = [],\n        c = !0,\n        f = !1;\n\n    try {\n      for (t = t.call(e); !(c = (a = t.next()).done) && (s.push(a.value), !r || s.length !== r); c = !0);\n    } catch (e) {\n      f = !0, i = e;\n    } finally {\n      try {\n        c || null == t.return || t.return();\n      } finally {\n        if (f) throw i;\n      }\n    }\n\n    return s;\n  }\n}\n\nfunction _unsupportedIterableToArray(e, r) {\n  if (e) {\n    if (\"string\" == typeof e) return _arrayLikeToArray(e, r);\n    var t = Object.prototype.toString.call(e).slice(8, -1);\n    return \"Object\" === t && e.constructor && (t = e.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(e) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(e, r) : void 0;\n  }\n}\n\nfunction _arrayLikeToArray(e, r) {\n  (null == r || r > e.length) && (r = e.length);\n\n  for (var t = 0, a = new Array(r); t < r; t++) a[t] = e[t];\n\n  return a;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction createCommonjsModule(e) {\n  var r = {\n    exports: {}\n  };\n  return e(r, r.exports), r.exports;\n}\n\nvar UZIP_1 = createCommonjsModule(function (e) {\n  var r,\n      t,\n      UZIP = {};\n  e.exports = UZIP, UZIP.parse = function (e, r) {\n    for (var t = UZIP.bin.readUshort, a = UZIP.bin.readUint, i = 0, s = {}, c = new Uint8Array(e), f = c.length - 4; 101010256 != a(c, f);) f--;\n\n    i = f;\n    i += 4;\n    var l = t(c, i += 4);\n    t(c, i += 2);\n    var u = a(c, i += 2),\n        d = a(c, i += 4);\n    i += 4, i = d;\n\n    for (var h = 0; h < l; h++) {\n      a(c, i), i += 4, i += 4, i += 4, a(c, i += 4);\n      u = a(c, i += 4);\n      var A = a(c, i += 4),\n          v = t(c, i += 4),\n          p = t(c, i + 2),\n          m = t(c, i + 4);\n      i += 6;\n      var g = a(c, i += 8);\n      i += 4, i += v + p + m, UZIP._readLocal(c, g, s, u, A, r);\n    }\n\n    return s;\n  }, UZIP._readLocal = function (e, r, t, a, i, s) {\n    var c = UZIP.bin.readUshort,\n        f = UZIP.bin.readUint;\n    f(e, r), c(e, r += 4), c(e, r += 2);\n    var l = c(e, r += 2);\n    f(e, r += 2), f(e, r += 4), r += 4;\n    var u = c(e, r += 8),\n        d = c(e, r += 2);\n    r += 2;\n    var h = UZIP.bin.readUTF8(e, r, u);\n    if (r += u, r += d, s) t[h] = {\n      size: i,\n      csize: a\n    };else {\n      var A = new Uint8Array(e.buffer, r);\n      if (0 == l) t[h] = new Uint8Array(A.buffer.slice(r, r + a));else {\n        if (8 != l) throw \"unknown compression method: \" + l;\n        var v = new Uint8Array(i);\n        UZIP.inflateRaw(A, v), t[h] = v;\n      }\n    }\n  }, UZIP.inflateRaw = function (e, r) {\n    return UZIP.F.inflate(e, r);\n  }, UZIP.inflate = function (e, r) {\n    return e[0], e[1], UZIP.inflateRaw(new Uint8Array(e.buffer, e.byteOffset + 2, e.length - 6), r);\n  }, UZIP.deflate = function (e, r) {\n    null == r && (r = {\n      level: 6\n    });\n    var t = 0,\n        a = new Uint8Array(50 + Math.floor(1.1 * e.length));\n    a[t] = 120, a[t + 1] = 156, t += 2, t = UZIP.F.deflateRaw(e, a, t, r.level);\n    var i = UZIP.adler(e, 0, e.length);\n    return a[t + 0] = i >>> 24 & 255, a[t + 1] = i >>> 16 & 255, a[t + 2] = i >>> 8 & 255, a[t + 3] = i >>> 0 & 255, new Uint8Array(a.buffer, 0, t + 4);\n  }, UZIP.deflateRaw = function (e, r) {\n    null == r && (r = {\n      level: 6\n    });\n    var t = new Uint8Array(50 + Math.floor(1.1 * e.length)),\n        a = UZIP.F.deflateRaw(e, t, a, r.level);\n    return new Uint8Array(t.buffer, 0, a);\n  }, UZIP.encode = function (e, r) {\n    null == r && (r = !1);\n    var t = 0,\n        a = UZIP.bin.writeUint,\n        i = UZIP.bin.writeUshort,\n        s = {};\n\n    for (var c in e) {\n      var f = !UZIP._noNeed(c) && !r,\n          l = e[c],\n          u = UZIP.crc.crc(l, 0, l.length);\n      s[c] = {\n        cpr: f,\n        usize: l.length,\n        crc: u,\n        file: f ? UZIP.deflateRaw(l) : l\n      };\n    }\n\n    for (var c in s) t += s[c].file.length + 30 + 46 + 2 * UZIP.bin.sizeUTF8(c);\n\n    t += 22;\n    var d = new Uint8Array(t),\n        h = 0,\n        A = [];\n\n    for (var c in s) {\n      var v = s[c];\n      A.push(h), h = UZIP._writeHeader(d, h, c, v, 0);\n    }\n\n    var p = 0,\n        m = h;\n\n    for (var c in s) {\n      v = s[c];\n      A.push(h), h = UZIP._writeHeader(d, h, c, v, 1, A[p++]);\n    }\n\n    var g = h - m;\n    return a(d, h, 101010256), h += 4, i(d, h += 4, p), i(d, h += 2, p), a(d, h += 2, g), a(d, h += 4, m), h += 4, h += 2, d.buffer;\n  }, UZIP._noNeed = function (e) {\n    var r = e.split(\".\").pop().toLowerCase();\n    return -1 != \"png,jpg,jpeg,zip\".indexOf(r);\n  }, UZIP._writeHeader = function (e, r, t, a, i, s) {\n    var c = UZIP.bin.writeUint,\n        f = UZIP.bin.writeUshort,\n        l = a.file;\n    return c(e, r, 0 == i ? 67324752 : 33639248), r += 4, 1 == i && (r += 2), f(e, r, 20), f(e, r += 2, 0), f(e, r += 2, a.cpr ? 8 : 0), c(e, r += 2, 0), c(e, r += 4, a.crc), c(e, r += 4, l.length), c(e, r += 4, a.usize), f(e, r += 4, UZIP.bin.sizeUTF8(t)), f(e, r += 2, 0), r += 2, 1 == i && (r += 2, r += 2, c(e, r += 6, s), r += 4), r += UZIP.bin.writeUTF8(e, r, t), 0 == i && (e.set(l, r), r += l.length), r;\n  }, UZIP.crc = {\n    table: function () {\n      for (var e = new Uint32Array(256), r = 0; r < 256; r++) {\n        for (var t = r, a = 0; a < 8; a++) 1 & t ? t = 3988292384 ^ t >>> 1 : t >>>= 1;\n\n        e[r] = t;\n      }\n\n      return e;\n    }(),\n    update: function (e, r, t, a) {\n      for (var i = 0; i < a; i++) e = UZIP.crc.table[255 & (e ^ r[t + i])] ^ e >>> 8;\n\n      return e;\n    },\n    crc: function (e, r, t) {\n      return 4294967295 ^ UZIP.crc.update(4294967295, e, r, t);\n    }\n  }, UZIP.adler = function (e, r, t) {\n    for (var a = 1, i = 0, s = r, c = r + t; s < c;) {\n      for (var f = Math.min(s + 5552, c); s < f;) i += a += e[s++];\n\n      a %= 65521, i %= 65521;\n    }\n\n    return i << 16 | a;\n  }, UZIP.bin = {\n    readUshort: function (e, r) {\n      return e[r] | e[r + 1] << 8;\n    },\n    writeUshort: function (e, r, t) {\n      e[r] = 255 & t, e[r + 1] = t >> 8 & 255;\n    },\n    readUint: function (e, r) {\n      return 16777216 * e[r + 3] + (e[r + 2] << 16 | e[r + 1] << 8 | e[r]);\n    },\n    writeUint: function (e, r, t) {\n      e[r] = 255 & t, e[r + 1] = t >> 8 & 255, e[r + 2] = t >> 16 & 255, e[r + 3] = t >> 24 & 255;\n    },\n    readASCII: function (e, r, t) {\n      for (var a = \"\", i = 0; i < t; i++) a += String.fromCharCode(e[r + i]);\n\n      return a;\n    },\n    writeASCII: function (e, r, t) {\n      for (var a = 0; a < t.length; a++) e[r + a] = t.charCodeAt(a);\n    },\n    pad: function (e) {\n      return e.length < 2 ? \"0\" + e : e;\n    },\n    readUTF8: function (e, r, t) {\n      for (var a, i = \"\", s = 0; s < t; s++) i += \"%\" + UZIP.bin.pad(e[r + s].toString(16));\n\n      try {\n        a = decodeURIComponent(i);\n      } catch (a) {\n        return UZIP.bin.readASCII(e, r, t);\n      }\n\n      return a;\n    },\n    writeUTF8: function (e, r, t) {\n      for (var a = t.length, i = 0, s = 0; s < a; s++) {\n        var c = t.charCodeAt(s);\n        if (0 == (4294967168 & c)) e[r + i] = c, i++;else if (0 == (4294965248 & c)) e[r + i] = 192 | c >> 6, e[r + i + 1] = 128 | c >> 0 & 63, i += 2;else if (0 == (4294901760 & c)) e[r + i] = 224 | c >> 12, e[r + i + 1] = 128 | c >> 6 & 63, e[r + i + 2] = 128 | c >> 0 & 63, i += 3;else {\n          if (0 != (4292870144 & c)) throw \"e\";\n          e[r + i] = 240 | c >> 18, e[r + i + 1] = 128 | c >> 12 & 63, e[r + i + 2] = 128 | c >> 6 & 63, e[r + i + 3] = 128 | c >> 0 & 63, i += 4;\n        }\n      }\n\n      return i;\n    },\n    sizeUTF8: function (e) {\n      for (var r = e.length, t = 0, a = 0; a < r; a++) {\n        var i = e.charCodeAt(a);\n        if (0 == (4294967168 & i)) t++;else if (0 == (4294965248 & i)) t += 2;else if (0 == (4294901760 & i)) t += 3;else {\n          if (0 != (4292870144 & i)) throw \"e\";\n          t += 4;\n        }\n      }\n\n      return t;\n    }\n  }, UZIP.F = {}, UZIP.F.deflateRaw = function (e, r, t, a) {\n    var i = [[0, 0, 0, 0, 0], [4, 4, 8, 4, 0], [4, 5, 16, 8, 0], [4, 6, 16, 16, 0], [4, 10, 16, 32, 0], [8, 16, 32, 32, 0], [8, 16, 128, 128, 0], [8, 32, 128, 256, 0], [32, 128, 258, 1024, 1], [32, 258, 258, 4096, 1]][a],\n        s = UZIP.F.U,\n        c = UZIP.F._goodIndex;\n    UZIP.F._hash;\n    var f = UZIP.F._putsE,\n        l = 0,\n        u = t << 3,\n        d = 0,\n        h = e.length;\n\n    if (0 == a) {\n      for (; l < h;) {\n        f(r, u, l + (I = Math.min(65535, h - l)) == h ? 1 : 0), u = UZIP.F._copyExact(e, l, I, r, u + 8), l += I;\n      }\n\n      return u >>> 3;\n    }\n\n    var A = s.lits,\n        v = s.strt,\n        p = s.prev,\n        m = 0,\n        g = 0,\n        U = 0,\n        w = 0,\n        _ = 0,\n        P = 0;\n\n    for (h > 2 && (v[P = UZIP.F._hash(e, 0)] = 0), l = 0; l < h; l++) {\n      if (_ = P, l + 1 < h - 2) {\n        P = UZIP.F._hash(e, l + 1);\n        var b = l + 1 & 32767;\n        p[b] = v[P], v[P] = b;\n      }\n\n      if (d <= l) {\n        (m > 14e3 || g > 26697) && h - l > 100 && (d < l && (A[m] = l - d, m += 2, d = l), u = UZIP.F._writeBlock(l == h - 1 || d == h ? 1 : 0, A, m, w, e, U, l - U, r, u), m = g = w = 0, U = l);\n        var y = 0;\n        l < h - 2 && (y = UZIP.F._bestMatch(e, l, p, _, Math.min(i[2], h - l), i[3]));\n        var I = y >>> 16,\n            F = 65535 & y;\n\n        if (0 != y) {\n          F = 65535 & y;\n          var E = c(I = y >>> 16, s.of0);\n          s.lhst[257 + E]++;\n          var C = c(F, s.df0);\n          s.dhst[C]++, w += s.exb[E] + s.dxb[C], A[m] = I << 23 | l - d, A[m + 1] = F << 16 | E << 8 | C, m += 2, d = l + I;\n        } else s.lhst[e[l]]++;\n\n        g++;\n      }\n    }\n\n    for (U == l && 0 != e.length || (d < l && (A[m] = l - d, m += 2, d = l), u = UZIP.F._writeBlock(1, A, m, w, e, U, l - U, r, u), m = 0, g = 0, m = g = w = 0, U = l); 0 != (7 & u);) u++;\n\n    return u >>> 3;\n  }, UZIP.F._bestMatch = function (e, r, t, a, i, s) {\n    var c = 32767 & r,\n        f = t[c],\n        l = c - f + 32768 & 32767;\n    if (f == c || a != UZIP.F._hash(e, r - l)) return 0;\n\n    for (var u = 0, d = 0, h = Math.min(32767, r); l <= h && 0 != --s && f != c;) {\n      if (0 == u || e[r + u] == e[r + u - l]) {\n        var A = UZIP.F._howLong(e, r, l);\n\n        if (A > u) {\n          if (d = l, (u = A) >= i) break;\n          l + 2 < A && (A = l + 2);\n\n          for (var v = 0, p = 0; p < A - 2; p++) {\n            var m = r - l + p + 32768 & 32767,\n                g = m - t[m] + 32768 & 32767;\n            g > v && (v = g, f = m);\n          }\n        }\n      }\n\n      l += (c = f) - (f = t[c]) + 32768 & 32767;\n    }\n\n    return u << 16 | d;\n  }, UZIP.F._howLong = function (e, r, t) {\n    if (e[r] != e[r - t] || e[r + 1] != e[r + 1 - t] || e[r + 2] != e[r + 2 - t]) return 0;\n    var a = r,\n        i = Math.min(e.length, r + 258);\n\n    for (r += 3; r < i && e[r] == e[r - t];) r++;\n\n    return r - a;\n  }, UZIP.F._hash = function (e, r) {\n    return (e[r] << 8 | e[r + 1]) + (e[r + 2] << 4) & 65535;\n  }, UZIP.saved = 0, UZIP.F._writeBlock = function (e, r, t, a, i, s, c, f, l) {\n    var u,\n        d,\n        h,\n        A,\n        v,\n        p,\n        m,\n        g,\n        U,\n        w = UZIP.F.U,\n        _ = UZIP.F._putsF,\n        P = UZIP.F._putsE;\n    w.lhst[256]++, d = (u = UZIP.F.getTrees())[0], h = u[1], A = u[2], v = u[3], p = u[4], m = u[5], g = u[6], U = u[7];\n    var b = 32 + (0 == (l + 3 & 7) ? 0 : 8 - (l + 3 & 7)) + (c << 3),\n        y = a + UZIP.F.contSize(w.fltree, w.lhst) + UZIP.F.contSize(w.fdtree, w.dhst),\n        I = a + UZIP.F.contSize(w.ltree, w.lhst) + UZIP.F.contSize(w.dtree, w.dhst);\n    I += 14 + 3 * m + UZIP.F.contSize(w.itree, w.ihst) + (2 * w.ihst[16] + 3 * w.ihst[17] + 7 * w.ihst[18]);\n\n    for (var F = 0; F < 286; F++) w.lhst[F] = 0;\n\n    for (F = 0; F < 30; F++) w.dhst[F] = 0;\n\n    for (F = 0; F < 19; F++) w.ihst[F] = 0;\n\n    var E = b < y && b < I ? 0 : y < I ? 1 : 2;\n\n    if (_(f, l, e), _(f, l + 1, E), l += 3, 0 == E) {\n      for (; 0 != (7 & l);) l++;\n\n      l = UZIP.F._copyExact(i, s, c, f, l);\n    } else {\n      var C, B;\n\n      if (1 == E && (C = w.fltree, B = w.fdtree), 2 == E) {\n        UZIP.F.makeCodes(w.ltree, d), UZIP.F.revCodes(w.ltree, d), UZIP.F.makeCodes(w.dtree, h), UZIP.F.revCodes(w.dtree, h), UZIP.F.makeCodes(w.itree, A), UZIP.F.revCodes(w.itree, A), C = w.ltree, B = w.dtree, P(f, l, v - 257), P(f, l += 5, p - 1), P(f, l += 5, m - 4), l += 4;\n\n        for (var R = 0; R < m; R++) P(f, l + 3 * R, w.itree[1 + (w.ordr[R] << 1)]);\n\n        l += 3 * m, l = UZIP.F._codeTiny(g, w.itree, f, l), l = UZIP.F._codeTiny(U, w.itree, f, l);\n      }\n\n      for (var G = s, M = 0; M < t; M += 2) {\n        for (var O = r[M], x = O >>> 23, S = G + (8388607 & O); G < S;) l = UZIP.F._writeLit(i[G++], C, f, l);\n\n        if (0 != x) {\n          var Z = r[M + 1],\n              Q = Z >> 16,\n              T = Z >> 8 & 255,\n              D = 255 & Z;\n          P(f, l = UZIP.F._writeLit(257 + T, C, f, l), x - w.of0[T]), l += w.exb[T], _(f, l = UZIP.F._writeLit(D, B, f, l), Q - w.df0[D]), l += w.dxb[D], G += x;\n        }\n      }\n\n      l = UZIP.F._writeLit(256, C, f, l);\n    }\n\n    return l;\n  }, UZIP.F._copyExact = function (e, r, t, a, i) {\n    var s = i >>> 3;\n    return a[s] = t, a[s + 1] = t >>> 8, a[s + 2] = 255 - a[s], a[s + 3] = 255 - a[s + 1], s += 4, a.set(new Uint8Array(e.buffer, r, t), s), i + (t + 4 << 3);\n  }, UZIP.F.getTrees = function () {\n    for (var e = UZIP.F.U, r = UZIP.F._hufTree(e.lhst, e.ltree, 15), t = UZIP.F._hufTree(e.dhst, e.dtree, 15), a = [], i = UZIP.F._lenCodes(e.ltree, a), s = [], c = UZIP.F._lenCodes(e.dtree, s), f = 0; f < a.length; f += 2) e.ihst[a[f]]++;\n\n    for (f = 0; f < s.length; f += 2) e.ihst[s[f]]++;\n\n    for (var l = UZIP.F._hufTree(e.ihst, e.itree, 7), u = 19; u > 4 && 0 == e.itree[1 + (e.ordr[u - 1] << 1)];) u--;\n\n    return [r, t, l, i, c, u, a, s];\n  }, UZIP.F.getSecond = function (e) {\n    for (var r = [], t = 0; t < e.length; t += 2) r.push(e[t + 1]);\n\n    return r;\n  }, UZIP.F.nonZero = function (e) {\n    for (var r = \"\", t = 0; t < e.length; t += 2) 0 != e[t + 1] && (r += (t >> 1) + \",\");\n\n    return r;\n  }, UZIP.F.contSize = function (e, r) {\n    for (var t = 0, a = 0; a < r.length; a++) t += r[a] * e[1 + (a << 1)];\n\n    return t;\n  }, UZIP.F._codeTiny = function (e, r, t, a) {\n    for (var i = 0; i < e.length; i += 2) {\n      var s = e[i],\n          c = e[i + 1];\n      a = UZIP.F._writeLit(s, r, t, a);\n      var f = 16 == s ? 2 : 17 == s ? 3 : 7;\n      s > 15 && (UZIP.F._putsE(t, a, c, f), a += f);\n    }\n\n    return a;\n  }, UZIP.F._lenCodes = function (e, r) {\n    for (var t = e.length; 2 != t && 0 == e[t - 1];) t -= 2;\n\n    for (var a = 0; a < t; a += 2) {\n      var i = e[a + 1],\n          s = a + 3 < t ? e[a + 3] : -1,\n          c = a + 5 < t ? e[a + 5] : -1,\n          f = 0 == a ? -1 : e[a - 1];\n\n      if (0 == i && s == i && c == i) {\n        for (var l = a + 5; l + 2 < t && e[l + 2] == i;) l += 2;\n\n        (u = Math.min(l + 1 - a >>> 1, 138)) < 11 ? r.push(17, u - 3) : r.push(18, u - 11), a += 2 * u - 2;\n      } else if (i == f && s == i && c == i) {\n        for (l = a + 5; l + 2 < t && e[l + 2] == i;) l += 2;\n\n        var u = Math.min(l + 1 - a >>> 1, 6);\n        r.push(16, u - 3), a += 2 * u - 2;\n      } else r.push(i, 0);\n    }\n\n    return t >>> 1;\n  }, UZIP.F._hufTree = function (e, r, t) {\n    var a = [],\n        i = e.length,\n        s = r.length,\n        c = 0;\n\n    for (c = 0; c < s; c += 2) r[c] = 0, r[c + 1] = 0;\n\n    for (c = 0; c < i; c++) 0 != e[c] && a.push({\n      lit: c,\n      f: e[c]\n    });\n\n    var f = a.length,\n        l = a.slice(0);\n    if (0 == f) return 0;\n\n    if (1 == f) {\n      var u = a[0].lit;\n      l = 0 == u ? 1 : 0;\n      return r[1 + (u << 1)] = 1, r[1 + (l << 1)] = 1, 1;\n    }\n\n    a.sort(function (e, r) {\n      return e.f - r.f;\n    });\n    var d = a[0],\n        h = a[1],\n        A = 0,\n        v = 1,\n        p = 2;\n\n    for (a[0] = {\n      lit: -1,\n      f: d.f + h.f,\n      l: d,\n      r: h,\n      d: 0\n    }; v != f - 1;) d = A != v && (p == f || a[A].f < a[p].f) ? a[A++] : a[p++], h = A != v && (p == f || a[A].f < a[p].f) ? a[A++] : a[p++], a[v++] = {\n      lit: -1,\n      f: d.f + h.f,\n      l: d,\n      r: h\n    };\n\n    var m = UZIP.F.setDepth(a[v - 1], 0);\n\n    for (m > t && (UZIP.F.restrictDepth(l, t, m), m = t), c = 0; c < f; c++) r[1 + (l[c].lit << 1)] = l[c].d;\n\n    return m;\n  }, UZIP.F.setDepth = function (e, r) {\n    return -1 != e.lit ? (e.d = r, r) : Math.max(UZIP.F.setDepth(e.l, r + 1), UZIP.F.setDepth(e.r, r + 1));\n  }, UZIP.F.restrictDepth = function (e, r, t) {\n    var a = 0,\n        i = 1 << t - r,\n        s = 0;\n\n    for (e.sort(function (e, r) {\n      return r.d == e.d ? e.f - r.f : r.d - e.d;\n    }), a = 0; a < e.length && e[a].d > r; a++) {\n      var c = e[a].d;\n      e[a].d = r, s += i - (1 << t - c);\n    }\n\n    for (s >>>= t - r; s > 0;) {\n      (c = e[a].d) < r ? (e[a].d++, s -= 1 << r - c - 1) : a++;\n    }\n\n    for (; a >= 0; a--) e[a].d == r && s < 0 && (e[a].d--, s++);\n\n    0 != s && console.log(\"debt left\");\n  }, UZIP.F._goodIndex = function (e, r) {\n    var t = 0;\n    return r[16 | t] <= e && (t |= 16), r[8 | t] <= e && (t |= 8), r[4 | t] <= e && (t |= 4), r[2 | t] <= e && (t |= 2), r[1 | t] <= e && (t |= 1), t;\n  }, UZIP.F._writeLit = function (e, r, t, a) {\n    return UZIP.F._putsF(t, a, r[e << 1]), a + r[1 + (e << 1)];\n  }, UZIP.F.inflate = function (e, r) {\n    var t = Uint8Array;\n    if (3 == e[0] && 0 == e[1]) return r || new t(0);\n    var a = UZIP.F,\n        i = a._bitsF,\n        s = a._bitsE,\n        c = a._decodeTiny,\n        f = a.makeCodes,\n        l = a.codes2map,\n        u = a._get17,\n        d = a.U,\n        h = null == r;\n    h && (r = new t(e.length >>> 2 << 3));\n\n    for (var A, v, p = 0, m = 0, g = 0, U = 0, w = 0, _ = 0, P = 0, b = 0, y = 0; 0 == p;) if (p = i(e, y, 1), m = i(e, y + 1, 2), y += 3, 0 != m) {\n      if (h && (r = UZIP.F._check(r, b + (1 << 17))), 1 == m && (A = d.flmap, v = d.fdmap, _ = 511, P = 31), 2 == m) {\n        g = s(e, y, 5) + 257, U = s(e, y + 5, 5) + 1, w = s(e, y + 10, 4) + 4, y += 14;\n\n        for (var I = 0; I < 38; I += 2) d.itree[I] = 0, d.itree[I + 1] = 0;\n\n        var F = 1;\n\n        for (I = 0; I < w; I++) {\n          var E = s(e, y + 3 * I, 3);\n          d.itree[1 + (d.ordr[I] << 1)] = E, E > F && (F = E);\n        }\n\n        y += 3 * w, f(d.itree, F), l(d.itree, F, d.imap), A = d.lmap, v = d.dmap, y = c(d.imap, (1 << F) - 1, g + U, e, y, d.ttree);\n\n        var C = a._copyOut(d.ttree, 0, g, d.ltree);\n\n        _ = (1 << C) - 1;\n\n        var B = a._copyOut(d.ttree, g, U, d.dtree);\n\n        P = (1 << B) - 1, f(d.ltree, C), l(d.ltree, C, A), f(d.dtree, B), l(d.dtree, B, v);\n      }\n\n      for (;;) {\n        var R = A[u(e, y) & _];\n\n        y += 15 & R;\n        var G = R >>> 4;\n        if (G >>> 8 == 0) r[b++] = G;else {\n          if (256 == G) break;\n          var M = b + G - 254;\n\n          if (G > 264) {\n            var O = d.ldef[G - 257];\n            M = b + (O >>> 3) + s(e, y, 7 & O), y += 7 & O;\n          }\n\n          var x = v[u(e, y) & P];\n          y += 15 & x;\n          var S = x >>> 4,\n              Z = d.ddef[S],\n              Q = (Z >>> 4) + i(e, y, 15 & Z);\n\n          for (y += 15 & Z, h && (r = UZIP.F._check(r, b + (1 << 17))); b < M;) r[b] = r[b++ - Q], r[b] = r[b++ - Q], r[b] = r[b++ - Q], r[b] = r[b++ - Q];\n\n          b = M;\n        }\n      }\n    } else {\n      0 != (7 & y) && (y += 8 - (7 & y));\n      var T = 4 + (y >>> 3),\n          D = e[T - 4] | e[T - 3] << 8;\n      h && (r = UZIP.F._check(r, b + D)), r.set(new t(e.buffer, e.byteOffset + T, D), b), y = T + D << 3, b += D;\n    }\n\n    return r.length == b ? r : r.slice(0, b);\n  }, UZIP.F._check = function (e, r) {\n    var t = e.length;\n    if (r <= t) return e;\n    var a = new Uint8Array(Math.max(t << 1, r));\n    return a.set(e, 0), a;\n  }, UZIP.F._decodeTiny = function (e, r, t, a, i, s) {\n    for (var c = UZIP.F._bitsE, f = UZIP.F._get17, l = 0; l < t;) {\n      var u = e[f(a, i) & r];\n      i += 15 & u;\n      var d = u >>> 4;\n      if (d <= 15) s[l] = d, l++;else {\n        var h = 0,\n            A = 0;\n        16 == d ? (A = 3 + c(a, i, 2), i += 2, h = s[l - 1]) : 17 == d ? (A = 3 + c(a, i, 3), i += 3) : 18 == d && (A = 11 + c(a, i, 7), i += 7);\n\n        for (var v = l + A; l < v;) s[l] = h, l++;\n      }\n    }\n\n    return i;\n  }, UZIP.F._copyOut = function (e, r, t, a) {\n    for (var i = 0, s = 0, c = a.length >>> 1; s < t;) {\n      var f = e[s + r];\n      a[s << 1] = 0, a[1 + (s << 1)] = f, f > i && (i = f), s++;\n    }\n\n    for (; s < c;) a[s << 1] = 0, a[1 + (s << 1)] = 0, s++;\n\n    return i;\n  }, UZIP.F.makeCodes = function (e, r) {\n    for (var t, a, i, s, c = UZIP.F.U, f = e.length, l = c.bl_count, u = 0; u <= r; u++) l[u] = 0;\n\n    for (u = 1; u < f; u += 2) l[e[u]]++;\n\n    var d = c.next_code;\n\n    for (t = 0, l[0] = 0, a = 1; a <= r; a++) t = t + l[a - 1] << 1, d[a] = t;\n\n    for (i = 0; i < f; i += 2) 0 != (s = e[i + 1]) && (e[i] = d[s], d[s]++);\n  }, UZIP.F.codes2map = function (e, r, t) {\n    for (var a = e.length, i = UZIP.F.U.rev15, s = 0; s < a; s += 2) if (0 != e[s + 1]) for (var c = s >> 1, f = e[s + 1], l = c << 4 | f, u = r - f, d = e[s] << u, h = d + (1 << u); d != h;) {\n      t[i[d] >>> 15 - r] = l, d++;\n    }\n  }, UZIP.F.revCodes = function (e, r) {\n    for (var t = UZIP.F.U.rev15, a = 15 - r, i = 0; i < e.length; i += 2) {\n      var s = e[i] << r - e[i + 1];\n      e[i] = t[s] >>> a;\n    }\n  }, UZIP.F._putsE = function (e, r, t) {\n    t <<= 7 & r;\n    var a = r >>> 3;\n    e[a] |= t, e[a + 1] |= t >>> 8;\n  }, UZIP.F._putsF = function (e, r, t) {\n    t <<= 7 & r;\n    var a = r >>> 3;\n    e[a] |= t, e[a + 1] |= t >>> 8, e[a + 2] |= t >>> 16;\n  }, UZIP.F._bitsE = function (e, r, t) {\n    return (e[r >>> 3] | e[1 + (r >>> 3)] << 8) >>> (7 & r) & (1 << t) - 1;\n  }, UZIP.F._bitsF = function (e, r, t) {\n    return (e[r >>> 3] | e[1 + (r >>> 3)] << 8 | e[2 + (r >>> 3)] << 16) >>> (7 & r) & (1 << t) - 1;\n  }, UZIP.F._get17 = function (e, r) {\n    return (e[r >>> 3] | e[1 + (r >>> 3)] << 8 | e[2 + (r >>> 3)] << 16) >>> (7 & r);\n  }, UZIP.F._get25 = function (e, r) {\n    return (e[r >>> 3] | e[1 + (r >>> 3)] << 8 | e[2 + (r >>> 3)] << 16 | e[3 + (r >>> 3)] << 24) >>> (7 & r);\n  }, UZIP.F.U = (r = Uint16Array, t = Uint32Array, {\n    next_code: new r(16),\n    bl_count: new r(16),\n    ordr: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n    of0: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],\n    exb: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],\n    ldef: new r(32),\n    df0: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],\n    dxb: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],\n    ddef: new t(32),\n    flmap: new r(512),\n    fltree: [],\n    fdmap: new r(32),\n    fdtree: [],\n    lmap: new r(32768),\n    ltree: [],\n    ttree: [],\n    dmap: new r(32768),\n    dtree: [],\n    imap: new r(512),\n    itree: [],\n    rev15: new r(32768),\n    lhst: new t(286),\n    dhst: new t(30),\n    ihst: new t(19),\n    lits: new t(15e3),\n    strt: new r(65536),\n    prev: new r(32768)\n  }), function () {\n    for (var e = UZIP.F.U, r = 0; r < 32768; r++) {\n      var t = r;\n      t = (4278255360 & (t = (4042322160 & (t = (3435973836 & (t = (2863311530 & t) >>> 1 | (1431655765 & t) << 1)) >>> 2 | (858993459 & t) << 2)) >>> 4 | (252645135 & t) << 4)) >>> 8 | (16711935 & t) << 8, e.rev15[r] = (t >>> 16 | t << 16) >>> 17;\n    }\n\n    function pushV(e, r, t) {\n      for (; 0 != r--;) e.push(0, t);\n    }\n\n    for (r = 0; r < 32; r++) e.ldef[r] = e.of0[r] << 3 | e.exb[r], e.ddef[r] = e.df0[r] << 4 | e.dxb[r];\n\n    pushV(e.fltree, 144, 8), pushV(e.fltree, 112, 9), pushV(e.fltree, 24, 7), pushV(e.fltree, 8, 8), UZIP.F.makeCodes(e.fltree, 9), UZIP.F.codes2map(e.fltree, 9, e.flmap), UZIP.F.revCodes(e.fltree, 9), pushV(e.fdtree, 32, 5), UZIP.F.makeCodes(e.fdtree, 5), UZIP.F.codes2map(e.fdtree, 5, e.fdmap), UZIP.F.revCodes(e.fdtree, 5), pushV(e.itree, 19, 0), pushV(e.ltree, 286, 0), pushV(e.dtree, 30, 0), pushV(e.ttree, 320, 0);\n  }();\n}),\n    UZIP = Object.freeze(_mergeNamespaces({\n  __proto__: null,\n  default: UZIP_1\n}, [UZIP_1])),\n    UPNG = {},\n    N,\n    W,\n    H;\nUPNG.toRGBA8 = function (e) {\n  var r = e.width,\n      t = e.height;\n  if (null == e.tabs.acTL) return [UPNG.toRGBA8.decodeImage(e.data, r, t, e).buffer];\n  var a = [];\n  null == e.frames[0].data && (e.frames[0].data = e.data);\n\n  for (var i = r * t * 4, s = new Uint8Array(i), c = new Uint8Array(i), f = new Uint8Array(i), l = 0; l < e.frames.length; l++) {\n    var u = e.frames[l],\n        d = u.rect.x,\n        h = u.rect.y,\n        A = u.rect.width,\n        v = u.rect.height,\n        p = UPNG.toRGBA8.decodeImage(u.data, A, v, e);\n    if (0 != l) for (var m = 0; m < i; m++) f[m] = s[m];\n    if (0 == u.blend ? UPNG._copyTile(p, A, v, s, r, t, d, h, 0) : 1 == u.blend && UPNG._copyTile(p, A, v, s, r, t, d, h, 1), a.push(s.buffer.slice(0)), 0 == u.dispose) ;else if (1 == u.dispose) UPNG._copyTile(c, A, v, s, r, t, d, h, 0);else if (2 == u.dispose) for (m = 0; m < i; m++) s[m] = f[m];\n  }\n\n  return a;\n}, UPNG.toRGBA8.decodeImage = function (e, r, t, a) {\n  var i = r * t,\n      s = UPNG.decode._getBPP(a),\n      c = Math.ceil(r * s / 8),\n      f = new Uint8Array(4 * i),\n      l = new Uint32Array(f.buffer),\n      u = a.ctype,\n      d = a.depth,\n      h = UPNG._bin.readUshort;\n\n  if (6 == u) {\n    var A = i << 2;\n    if (8 == d) for (var v = 0; v < A; v += 4) f[v] = e[v], f[v + 1] = e[v + 1], f[v + 2] = e[v + 2], f[v + 3] = e[v + 3];\n    if (16 == d) for (v = 0; v < A; v++) f[v] = e[v << 1];\n  } else if (2 == u) {\n    var p = a.tabs.tRNS;\n\n    if (null == p) {\n      if (8 == d) for (v = 0; v < i; v++) {\n        var m = 3 * v;\n        l[v] = 255 << 24 | e[m + 2] << 16 | e[m + 1] << 8 | e[m];\n      }\n      if (16 == d) for (v = 0; v < i; v++) {\n        m = 6 * v;\n        l[v] = 255 << 24 | e[m + 4] << 16 | e[m + 2] << 8 | e[m];\n      }\n    } else {\n      var g = p[0],\n          U = p[1],\n          w = p[2];\n      if (8 == d) for (v = 0; v < i; v++) {\n        var _ = v << 2;\n\n        m = 3 * v;\n        l[v] = 255 << 24 | e[m + 2] << 16 | e[m + 1] << 8 | e[m], e[m] == g && e[m + 1] == U && e[m + 2] == w && (f[_ + 3] = 0);\n      }\n      if (16 == d) for (v = 0; v < i; v++) {\n        _ = v << 2, m = 6 * v;\n        l[v] = 255 << 24 | e[m + 4] << 16 | e[m + 2] << 8 | e[m], h(e, m) == g && h(e, m + 2) == U && h(e, m + 4) == w && (f[_ + 3] = 0);\n      }\n    }\n  } else if (3 == u) {\n    var P = a.tabs.PLTE,\n        b = a.tabs.tRNS,\n        y = b ? b.length : 0;\n    if (1 == d) for (var I = 0; I < t; I++) {\n      var F = I * c,\n          E = I * r;\n\n      for (v = 0; v < r; v++) {\n        _ = E + v << 2;\n        var C = 3 * (B = e[F + (v >> 3)] >> 7 - ((7 & v) << 0) & 1);\n        f[_] = P[C], f[_ + 1] = P[C + 1], f[_ + 2] = P[C + 2], f[_ + 3] = B < y ? b[B] : 255;\n      }\n    }\n    if (2 == d) for (I = 0; I < t; I++) for (F = I * c, E = I * r, v = 0; v < r; v++) {\n      _ = E + v << 2, C = 3 * (B = e[F + (v >> 2)] >> 6 - ((3 & v) << 1) & 3);\n      f[_] = P[C], f[_ + 1] = P[C + 1], f[_ + 2] = P[C + 2], f[_ + 3] = B < y ? b[B] : 255;\n    }\n    if (4 == d) for (I = 0; I < t; I++) for (F = I * c, E = I * r, v = 0; v < r; v++) {\n      _ = E + v << 2, C = 3 * (B = e[F + (v >> 1)] >> 4 - ((1 & v) << 2) & 15);\n      f[_] = P[C], f[_ + 1] = P[C + 1], f[_ + 2] = P[C + 2], f[_ + 3] = B < y ? b[B] : 255;\n    }\n    if (8 == d) for (v = 0; v < i; v++) {\n      var B;\n      _ = v << 2, C = 3 * (B = e[v]);\n      f[_] = P[C], f[_ + 1] = P[C + 1], f[_ + 2] = P[C + 2], f[_ + 3] = B < y ? b[B] : 255;\n    }\n  } else if (4 == u) {\n    if (8 == d) for (v = 0; v < i; v++) {\n      _ = v << 2;\n      var R = e[G = v << 1];\n      f[_] = R, f[_ + 1] = R, f[_ + 2] = R, f[_ + 3] = e[G + 1];\n    }\n    if (16 == d) for (v = 0; v < i; v++) {\n      var G;\n      _ = v << 2, R = e[G = v << 2];\n      f[_] = R, f[_ + 1] = R, f[_ + 2] = R, f[_ + 3] = e[G + 2];\n    }\n  } else if (0 == u) for (g = a.tabs.tRNS ? a.tabs.tRNS : -1, I = 0; I < t; I++) {\n    var M = I * c,\n        O = I * r;\n    if (1 == d) for (var x = 0; x < r; x++) {\n      var S = (R = 255 * (e[M + (x >>> 3)] >>> 7 - (7 & x) & 1)) == 255 * g ? 0 : 255;\n      l[O + x] = S << 24 | R << 16 | R << 8 | R;\n    } else if (2 == d) for (x = 0; x < r; x++) {\n      S = (R = 85 * (e[M + (x >>> 2)] >>> 6 - ((3 & x) << 1) & 3)) == 85 * g ? 0 : 255;\n      l[O + x] = S << 24 | R << 16 | R << 8 | R;\n    } else if (4 == d) for (x = 0; x < r; x++) {\n      S = (R = 17 * (e[M + (x >>> 1)] >>> 4 - ((1 & x) << 2) & 15)) == 17 * g ? 0 : 255;\n      l[O + x] = S << 24 | R << 16 | R << 8 | R;\n    } else if (8 == d) for (x = 0; x < r; x++) {\n      S = (R = e[M + x]) == g ? 0 : 255;\n      l[O + x] = S << 24 | R << 16 | R << 8 | R;\n    } else if (16 == d) for (x = 0; x < r; x++) {\n      R = e[M + (x << 1)], S = h(e, M + (x << v)) == g ? 0 : 255;\n      l[O + x] = S << 24 | R << 16 | R << 8 | R;\n    }\n  }\n\n  return f;\n}, UPNG.decode = function (e) {\n  for (var r, t = new Uint8Array(e), a = 8, i = UPNG._bin, s = i.readUshort, c = i.readUint, f = {\n    tabs: {},\n    frames: []\n  }, l = new Uint8Array(t.length), u = 0, d = 0, h = [137, 80, 78, 71, 13, 10, 26, 10], A = 0; A < 8; A++) if (t[A] != h[A]) throw \"The input is not a PNG file!\";\n\n  for (; a < t.length;) {\n    var v = i.readUint(t, a);\n    a += 4;\n    var p = i.readASCII(t, a, 4);\n    if (a += 4, \"IHDR\" == p) UPNG.decode._IHDR(t, a, f);else if (\"CgBI\" == p) f.tabs[p] = t.slice(a, a + 4);else if (\"IDAT\" == p) {\n      for (A = 0; A < v; A++) l[u + A] = t[a + A];\n\n      u += v;\n    } else if (\"acTL\" == p) f.tabs[p] = {\n      num_frames: c(t, a),\n      num_plays: c(t, a + 4)\n    }, r = new Uint8Array(t.length);else if (\"fcTL\" == p) {\n      var m;\n      if (0 != d) (m = f.frames[f.frames.length - 1]).data = UPNG.decode._decompress(f, r.slice(0, d), m.rect.width, m.rect.height), d = 0;\n      var g = {\n        x: c(t, a + 12),\n        y: c(t, a + 16),\n        width: c(t, a + 4),\n        height: c(t, a + 8)\n      },\n          U = s(t, a + 22);\n      U = s(t, a + 20) / (0 == U ? 100 : U);\n      var w = {\n        rect: g,\n        delay: Math.round(1e3 * U),\n        dispose: t[a + 24],\n        blend: t[a + 25]\n      };\n      f.frames.push(w);\n    } else if (\"fdAT\" == p) {\n      for (A = 0; A < v - 4; A++) r[d + A] = t[a + A + 4];\n\n      d += v - 4;\n    } else if (\"pHYs\" == p) f.tabs[p] = [i.readUint(t, a), i.readUint(t, a + 4), t[a + 8]];else if (\"cHRM\" == p) {\n      f.tabs[p] = [];\n\n      for (A = 0; A < 8; A++) f.tabs[p].push(i.readUint(t, a + 4 * A));\n    } else if (\"tEXt\" == p || \"zTXt\" == p) {\n      null == f.tabs[p] && (f.tabs[p] = {});\n\n      var _ = i.nextZero(t, a),\n          P = i.readASCII(t, a, _ - a),\n          b = a + v - _ - 1;\n\n      if (\"tEXt\" == p) F = i.readASCII(t, _ + 1, b);else {\n        var y = UPNG.decode._inflate(t.slice(_ + 2, _ + 2 + b));\n\n        F = i.readUTF8(y, 0, y.length);\n      }\n      f.tabs[p][P] = F;\n    } else if (\"iTXt\" == p) {\n      null == f.tabs[p] && (f.tabs[p] = {});\n      _ = 0;\n      var I = a;\n      _ = i.nextZero(t, I);\n      P = i.readASCII(t, I, _ - I);\n      var F,\n          E = t[I = _ + 1];\n      t[I + 1], I += 2, _ = i.nextZero(t, I), i.readASCII(t, I, _ - I), I = _ + 1, _ = i.nextZero(t, I), i.readUTF8(t, I, _ - I);\n      b = v - ((I = _ + 1) - a);\n      if (0 == E) F = i.readUTF8(t, I, b);else {\n        y = UPNG.decode._inflate(t.slice(I, I + b));\n        F = i.readUTF8(y, 0, y.length);\n      }\n      f.tabs[p][P] = F;\n    } else if (\"PLTE\" == p) f.tabs[p] = i.readBytes(t, a, v);else if (\"hIST\" == p) {\n      var C = f.tabs.PLTE.length / 3;\n      f.tabs[p] = [];\n\n      for (A = 0; A < C; A++) f.tabs[p].push(s(t, a + 2 * A));\n    } else if (\"tRNS\" == p) 3 == f.ctype ? f.tabs[p] = i.readBytes(t, a, v) : 0 == f.ctype ? f.tabs[p] = s(t, a) : 2 == f.ctype && (f.tabs[p] = [s(t, a), s(t, a + 2), s(t, a + 4)]);else if (\"gAMA\" == p) f.tabs[p] = i.readUint(t, a) / 1e5;else if (\"sRGB\" == p) f.tabs[p] = t[a];else if (\"bKGD\" == p) 0 == f.ctype || 4 == f.ctype ? f.tabs[p] = [s(t, a)] : 2 == f.ctype || 6 == f.ctype ? f.tabs[p] = [s(t, a), s(t, a + 2), s(t, a + 4)] : 3 == f.ctype && (f.tabs[p] = t[a]);else if (\"IEND\" == p) break;\n    a += v, i.readUint(t, a), a += 4;\n  }\n\n  0 != d && ((m = f.frames[f.frames.length - 1]).data = UPNG.decode._decompress(f, r.slice(0, d), m.rect.width, m.rect.height), d = 0);\n  return f.data = UPNG.decode._decompress(f, l, f.width, f.height), delete f.compress, delete f.interlace, delete f.filter, f;\n}, UPNG.decode._decompress = function (e, r, t, a) {\n  var i = UPNG.decode._getBPP(e),\n      s = Math.ceil(t * i / 8),\n      c = new Uint8Array((s + 1 + e.interlace) * a);\n\n  return r = e.tabs.CgBI ? UPNG.inflateRaw(r, c) : UPNG.decode._inflate(r, c), 0 == e.interlace ? r = UPNG.decode._filterZero(r, e, 0, t, a) : 1 == e.interlace && (r = UPNG.decode._readInterlace(r, e)), r;\n}, UPNG.decode._inflate = function (e, r) {\n  return UPNG.inflateRaw(new Uint8Array(e.buffer, 2, e.length - 6), r);\n}, UPNG.inflateRaw = (H = {}, H.H = {}, H.H.N = function (e, r) {\n  var t,\n      a,\n      i = Uint8Array,\n      s = 0,\n      c = 0,\n      f = 0,\n      l = 0,\n      u = 0,\n      d = 0,\n      h = 0,\n      A = 0,\n      v = 0;\n  if (3 == e[0] && 0 == e[1]) return r || new i(0);\n  var p = H.H,\n      m = p.b,\n      g = p.e,\n      U = p.R,\n      w = p.n,\n      _ = p.A,\n      P = p.Z,\n      b = p.m,\n      y = null == r;\n\n  for (y && (r = new i(e.length >>> 2 << 5)); 0 == s;) if (s = m(e, v, 1), c = m(e, v + 1, 2), v += 3, 0 != c) {\n    if (y && (r = H.H.W(r, A + (1 << 17))), 1 == c && (t = b.J, a = b.h, d = 511, h = 31), 2 == c) {\n      f = g(e, v, 5) + 257, l = g(e, v + 5, 5) + 1, u = g(e, v + 10, 4) + 4, v += 14;\n\n      for (var I = 1, F = 0; F < 38; F += 2) b.Q[F] = 0, b.Q[F + 1] = 0;\n\n      for (F = 0; F < u; F++) {\n        var E = g(e, v + 3 * F, 3);\n        b.Q[1 + (b.X[F] << 1)] = E, E > I && (I = E);\n      }\n\n      v += 3 * u, w(b.Q, I), _(b.Q, I, b.u), t = b.w, a = b.d, v = U(b.u, (1 << I) - 1, f + l, e, v, b.v);\n      var C = p.V(b.v, 0, f, b.C);\n      d = (1 << C) - 1;\n      var B = p.V(b.v, f, l, b.D);\n      h = (1 << B) - 1, w(b.C, C), _(b.C, C, t), w(b.D, B), _(b.D, B, a);\n    }\n\n    for (;;) {\n      var R = t[P(e, v) & d];\n      v += 15 & R;\n      var G = R >>> 4;\n      if (G >>> 8 == 0) r[A++] = G;else {\n        if (256 == G) break;\n        var M = A + G - 254;\n\n        if (G > 264) {\n          var O = b.q[G - 257];\n          M = A + (O >>> 3) + g(e, v, 7 & O), v += 7 & O;\n        }\n\n        var x = a[P(e, v) & h];\n        v += 15 & x;\n        var S = x >>> 4,\n            Z = b.c[S],\n            Q = (Z >>> 4) + m(e, v, 15 & Z);\n\n        for (v += 15 & Z; A < M;) r[A] = r[A++ - Q], r[A] = r[A++ - Q], r[A] = r[A++ - Q], r[A] = r[A++ - Q];\n\n        A = M;\n      }\n    }\n  } else {\n    0 != (7 & v) && (v += 8 - (7 & v));\n    var T = 4 + (v >>> 3),\n        D = e[T - 4] | e[T - 3] << 8;\n    y && (r = H.H.W(r, A + D)), r.set(new i(e.buffer, e.byteOffset + T, D), A), v = T + D << 3, A += D;\n  }\n\n  return r.length == A ? r : r.slice(0, A);\n}, H.H.W = function (e, r) {\n  var t = e.length;\n  if (r <= t) return e;\n  var a = new Uint8Array(t << 1);\n  return a.set(e, 0), a;\n}, H.H.R = function (e, r, t, a, i, s) {\n  for (var c = H.H.e, f = H.H.Z, l = 0; l < t;) {\n    var u = e[f(a, i) & r];\n    i += 15 & u;\n    var d = u >>> 4;\n    if (d <= 15) s[l] = d, l++;else {\n      var h = 0,\n          A = 0;\n      16 == d ? (A = 3 + c(a, i, 2), i += 2, h = s[l - 1]) : 17 == d ? (A = 3 + c(a, i, 3), i += 3) : 18 == d && (A = 11 + c(a, i, 7), i += 7);\n\n      for (var v = l + A; l < v;) s[l] = h, l++;\n    }\n  }\n\n  return i;\n}, H.H.V = function (e, r, t, a) {\n  for (var i = 0, s = 0, c = a.length >>> 1; s < t;) {\n    var f = e[s + r];\n    a[s << 1] = 0, a[1 + (s << 1)] = f, f > i && (i = f), s++;\n  }\n\n  for (; s < c;) a[s << 1] = 0, a[1 + (s << 1)] = 0, s++;\n\n  return i;\n}, H.H.n = function (e, r) {\n  for (var t, a, i, s, c = H.H.m, f = e.length, l = c.j, u = 0; u <= r; u++) l[u] = 0;\n\n  for (u = 1; u < f; u += 2) l[e[u]]++;\n\n  var d = c.K;\n\n  for (t = 0, l[0] = 0, a = 1; a <= r; a++) t = t + l[a - 1] << 1, d[a] = t;\n\n  for (i = 0; i < f; i += 2) 0 != (s = e[i + 1]) && (e[i] = d[s], d[s]++);\n}, H.H.A = function (e, r, t) {\n  for (var a = e.length, i = H.H.m.r, s = 0; s < a; s += 2) if (0 != e[s + 1]) for (var c = s >> 1, f = e[s + 1], l = c << 4 | f, u = r - f, d = e[s] << u, h = d + (1 << u); d != h;) t[i[d] >>> 15 - r] = l, d++;\n}, H.H.l = function (e, r) {\n  for (var t = H.H.m.r, a = 15 - r, i = 0; i < e.length; i += 2) {\n    var s = e[i] << r - e[i + 1];\n    e[i] = t[s] >>> a;\n  }\n}, H.H.M = function (e, r, t) {\n  t <<= 7 & r;\n  var a = r >>> 3;\n  e[a] |= t, e[a + 1] |= t >>> 8;\n}, H.H.I = function (e, r, t) {\n  t <<= 7 & r;\n  var a = r >>> 3;\n  e[a] |= t, e[a + 1] |= t >>> 8, e[a + 2] |= t >>> 16;\n}, H.H.e = function (e, r, t) {\n  return (e[r >>> 3] | e[1 + (r >>> 3)] << 8) >>> (7 & r) & (1 << t) - 1;\n}, H.H.b = function (e, r, t) {\n  return (e[r >>> 3] | e[1 + (r >>> 3)] << 8 | e[2 + (r >>> 3)] << 16) >>> (7 & r) & (1 << t) - 1;\n}, H.H.Z = function (e, r) {\n  return (e[r >>> 3] | e[1 + (r >>> 3)] << 8 | e[2 + (r >>> 3)] << 16) >>> (7 & r);\n}, H.H.i = function (e, r) {\n  return (e[r >>> 3] | e[1 + (r >>> 3)] << 8 | e[2 + (r >>> 3)] << 16 | e[3 + (r >>> 3)] << 24) >>> (7 & r);\n}, H.H.m = (N = Uint16Array, W = Uint32Array, {\n  K: new N(16),\n  j: new N(16),\n  X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n  S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],\n  T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],\n  q: new N(32),\n  p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],\n  z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],\n  c: new W(32),\n  J: new N(512),\n  _: [],\n  h: new N(32),\n  $: [],\n  w: new N(32768),\n  C: [],\n  v: [],\n  d: new N(32768),\n  D: [],\n  u: new N(512),\n  Q: [],\n  r: new N(32768),\n  s: new W(286),\n  Y: new W(30),\n  a: new W(19),\n  t: new W(15e3),\n  k: new N(65536),\n  g: new N(32768)\n}), function () {\n  for (var e = H.H.m, r = 0; r < 32768; r++) {\n    var t = r;\n    t = (4278255360 & (t = (4042322160 & (t = (3435973836 & (t = (2863311530 & t) >>> 1 | (1431655765 & t) << 1)) >>> 2 | (858993459 & t) << 2)) >>> 4 | (252645135 & t) << 4)) >>> 8 | (16711935 & t) << 8, e.r[r] = (t >>> 16 | t << 16) >>> 17;\n  }\n\n  function n(e, r, t) {\n    for (; 0 != r--;) e.push(0, t);\n  }\n\n  for (r = 0; r < 32; r++) e.q[r] = e.S[r] << 3 | e.T[r], e.c[r] = e.p[r] << 4 | e.z[r];\n\n  n(e._, 144, 8), n(e._, 112, 9), n(e._, 24, 7), n(e._, 8, 8), H.H.n(e._, 9), H.H.A(e._, 9, e.J), H.H.l(e._, 9), n(e.$, 32, 5), H.H.n(e.$, 5), H.H.A(e.$, 5, e.h), H.H.l(e.$, 5), n(e.Q, 19, 0), n(e.C, 286, 0), n(e.D, 30, 0), n(e.v, 320, 0);\n}(), H.H.N), UPNG.decode._readInterlace = function (e, r) {\n  for (var t = r.width, a = r.height, i = UPNG.decode._getBPP(r), s = i >> 3, c = Math.ceil(t * i / 8), f = new Uint8Array(a * c), l = 0, u = [0, 0, 4, 0, 2, 0, 1], d = [0, 4, 0, 2, 0, 1, 0], h = [8, 8, 8, 4, 4, 2, 2], A = [8, 8, 4, 4, 2, 2, 1], v = 0; v < 7;) {\n    for (var p = h[v], m = A[v], g = 0, U = 0, w = u[v]; w < a;) w += p, U++;\n\n    for (var _ = d[v]; _ < t;) _ += m, g++;\n\n    var P = Math.ceil(g * i / 8);\n\n    UPNG.decode._filterZero(e, r, l, g, U);\n\n    for (var b = 0, y = u[v]; y < a;) {\n      for (var I = d[v], F = l + b * P << 3; I < t;) {\n        var E;\n        if (1 == i) E = (E = e[F >> 3]) >> 7 - (7 & F) & 1, f[y * c + (I >> 3)] |= E << 7 - ((7 & I) << 0);\n        if (2 == i) E = (E = e[F >> 3]) >> 6 - (7 & F) & 3, f[y * c + (I >> 2)] |= E << 6 - ((3 & I) << 1);\n        if (4 == i) E = (E = e[F >> 3]) >> 4 - (7 & F) & 15, f[y * c + (I >> 1)] |= E << 4 - ((1 & I) << 2);\n        if (i >= 8) for (var C = y * c + I * s, B = 0; B < s; B++) f[C + B] = e[(F >> 3) + B];\n        F += i, I += m;\n      }\n\n      b++, y += p;\n    }\n\n    g * U != 0 && (l += U * (1 + P)), v += 1;\n  }\n\n  return f;\n}, UPNG.decode._getBPP = function (e) {\n  return [1, null, 3, 1, 2, null, 4][e.ctype] * e.depth;\n}, UPNG.decode._filterZero = function (e, r, t, a, i) {\n  var s = UPNG.decode._getBPP(r),\n      c = Math.ceil(a * s / 8),\n      f = UPNG.decode._paeth;\n\n  s = Math.ceil(s / 8);\n  var l = 0,\n      u = 1,\n      d = e[t],\n      h = 0;\n  if (d > 1 && (e[t] = [0, 0, 1][d - 2]), 3 == d) for (h = s; h < c; h++) e[h + 1] = e[h + 1] + (e[h + 1 - s] >>> 1) & 255;\n\n  for (var A = 0; A < i; A++) if (h = 0, 0 == (d = e[(u = (l = t + A * c) + A + 1) - 1])) for (; h < c; h++) e[l + h] = e[u + h];else if (1 == d) {\n    for (; h < s; h++) e[l + h] = e[u + h];\n\n    for (; h < c; h++) e[l + h] = e[u + h] + e[l + h - s];\n  } else if (2 == d) for (; h < c; h++) e[l + h] = e[u + h] + e[l + h - c];else if (3 == d) {\n    for (; h < s; h++) e[l + h] = e[u + h] + (e[l + h - c] >>> 1);\n\n    for (; h < c; h++) e[l + h] = e[u + h] + (e[l + h - c] + e[l + h - s] >>> 1);\n  } else {\n    for (; h < s; h++) e[l + h] = e[u + h] + f(0, e[l + h - c], 0);\n\n    for (; h < c; h++) e[l + h] = e[u + h] + f(e[l + h - s], e[l + h - c], e[l + h - s - c]);\n  }\n\n  return e;\n}, UPNG.decode._paeth = function (e, r, t) {\n  var a = e + r - t,\n      i = a - e,\n      s = a - r,\n      c = a - t;\n  return i * i <= s * s && i * i <= c * c ? e : s * s <= c * c ? r : t;\n}, UPNG.decode._IHDR = function (e, r, t) {\n  var a = UPNG._bin;\n  t.width = a.readUint(e, r), r += 4, t.height = a.readUint(e, r), r += 4, t.depth = e[r], r++, t.ctype = e[r], r++, t.compress = e[r], r++, t.filter = e[r], r++, t.interlace = e[r], r++;\n}, UPNG._bin = {\n  nextZero: function nextZero(e, r) {\n    for (; 0 != e[r];) r++;\n\n    return r;\n  },\n  readUshort: function readUshort(e, r) {\n    return e[r] << 8 | e[r + 1];\n  },\n  writeUshort: function writeUshort(e, r, t) {\n    e[r] = t >> 8 & 255, e[r + 1] = 255 & t;\n  },\n  readUint: function readUint(e, r) {\n    return 16777216 * e[r] + (e[r + 1] << 16 | e[r + 2] << 8 | e[r + 3]);\n  },\n  writeUint: function writeUint(e, r, t) {\n    e[r] = t >> 24 & 255, e[r + 1] = t >> 16 & 255, e[r + 2] = t >> 8 & 255, e[r + 3] = 255 & t;\n  },\n  readASCII: function readASCII(e, r, t) {\n    for (var a = \"\", i = 0; i < t; i++) a += String.fromCharCode(e[r + i]);\n\n    return a;\n  },\n  writeASCII: function writeASCII(e, r, t) {\n    for (var a = 0; a < t.length; a++) e[r + a] = t.charCodeAt(a);\n  },\n  readBytes: function readBytes(e, r, t) {\n    for (var a = [], i = 0; i < t; i++) a.push(e[r + i]);\n\n    return a;\n  },\n  pad: function pad(e) {\n    return e.length < 2 ? \"0\".concat(e) : e;\n  },\n  readUTF8: function readUTF8(e, r, t) {\n    for (var a, i = \"\", s = 0; s < t; s++) i += \"%\".concat(UPNG._bin.pad(e[r + s].toString(16)));\n\n    try {\n      a = decodeURIComponent(i);\n    } catch (a) {\n      return UPNG._bin.readASCII(e, r, t);\n    }\n\n    return a;\n  }\n}, UPNG._copyTile = function (e, r, t, a, i, s, c, f, l) {\n  for (var u = Math.min(r, i), d = Math.min(t, s), h = 0, A = 0, v = 0; v < d; v++) for (var p = 0; p < u; p++) if (c >= 0 && f >= 0 ? (h = v * r + p << 2, A = (f + v) * i + c + p << 2) : (h = (-f + v) * r - c + p << 2, A = v * i + p << 2), 0 == l) a[A] = e[h], a[A + 1] = e[h + 1], a[A + 2] = e[h + 2], a[A + 3] = e[h + 3];else if (1 == l) {\n    var m = e[h + 3] * (1 / 255),\n        g = e[h] * m,\n        U = e[h + 1] * m,\n        w = e[h + 2] * m,\n        _ = a[A + 3] * (1 / 255),\n        P = a[A] * _,\n        b = a[A + 1] * _,\n        y = a[A + 2] * _,\n        I = 1 - m,\n        F = m + _ * I,\n        E = 0 == F ? 0 : 1 / F;\n\n    a[A + 3] = 255 * F, a[A + 0] = (g + P * I) * E, a[A + 1] = (U + b * I) * E, a[A + 2] = (w + y * I) * E;\n  } else if (2 == l) {\n    m = e[h + 3], g = e[h], U = e[h + 1], w = e[h + 2], _ = a[A + 3], P = a[A], b = a[A + 1], y = a[A + 2];\n    m == _ && g == P && U == b && w == y ? (a[A] = 0, a[A + 1] = 0, a[A + 2] = 0, a[A + 3] = 0) : (a[A] = g, a[A + 1] = U, a[A + 2] = w, a[A + 3] = m);\n  } else if (3 == l) {\n    m = e[h + 3], g = e[h], U = e[h + 1], w = e[h + 2], _ = a[A + 3], P = a[A], b = a[A + 1], y = a[A + 2];\n    if (m == _ && g == P && U == b && w == y) continue;\n    if (m < 220 && _ > 20) return !1;\n  }\n\n  return !0;\n}, UPNG.encode = function (e, r, t, a, i, s, c) {\n  null == a && (a = 0), null == c && (c = !1);\n  var f = UPNG.encode.compress(e, r, t, a, [!1, !1, !1, 0, c]);\n  return UPNG.encode.compressPNG(f, -1), UPNG.encode._main(f, r, t, i, s);\n}, UPNG.encodeLL = function (e, r, t, a, i, s, c, f) {\n  for (var l = {\n    ctype: 0 + (1 == a ? 0 : 2) + (0 == i ? 0 : 4),\n    depth: s,\n    frames: []\n  }, u = (a + i) * s, d = u * r, h = 0; h < e.length; h++) l.frames.push({\n    rect: {\n      x: 0,\n      y: 0,\n      width: r,\n      height: t\n    },\n    img: new Uint8Array(e[h]),\n    blend: 0,\n    dispose: 1,\n    bpp: Math.ceil(u / 8),\n    bpl: Math.ceil(d / 8)\n  });\n\n  return UPNG.encode.compressPNG(l, 0, !0), UPNG.encode._main(l, r, t, c, f);\n}, UPNG.encode._main = function (e, r, t, a, i) {\n  null == i && (i = {});\n  var s = UPNG.crc.crc,\n      c = UPNG._bin.writeUint,\n      f = UPNG._bin.writeUshort,\n      l = UPNG._bin.writeASCII,\n      u = 8,\n      d = e.frames.length > 1,\n      h = !1,\n      A = 33 + (d ? 20 : 0);\n\n  if (null != i.sRGB && (A += 13), null != i.pHYs && (A += 21), 3 == e.ctype) {\n    for (var v = e.plte.length, p = 0; p < v; p++) e.plte[p] >>> 24 != 255 && (h = !0);\n\n    A += 8 + 3 * v + 4 + (h ? 8 + 1 * v + 4 : 0);\n  }\n\n  for (var m = 0; m < e.frames.length; m++) {\n    d && (A += 38), A += (F = e.frames[m]).cimg.length + 12, 0 != m && (A += 4);\n  }\n\n  A += 12;\n  var g = new Uint8Array(A),\n      U = [137, 80, 78, 71, 13, 10, 26, 10];\n\n  for (p = 0; p < 8; p++) g[p] = U[p];\n\n  if (c(g, u, 13), l(g, u += 4, \"IHDR\"), c(g, u += 4, r), c(g, u += 4, t), g[u += 4] = e.depth, g[++u] = e.ctype, g[++u] = 0, g[++u] = 0, g[++u] = 0, c(g, ++u, s(g, u - 17, 17)), u += 4, null != i.sRGB && (c(g, u, 1), l(g, u += 4, \"sRGB\"), g[u += 4] = i.sRGB, c(g, ++u, s(g, u - 5, 5)), u += 4), null != i.pHYs && (c(g, u, 9), l(g, u += 4, \"pHYs\"), c(g, u += 4, i.pHYs[0]), c(g, u += 4, i.pHYs[1]), g[u += 4] = i.pHYs[2], c(g, ++u, s(g, u - 13, 13)), u += 4), d && (c(g, u, 8), l(g, u += 4, \"acTL\"), c(g, u += 4, e.frames.length), c(g, u += 4, null != i.loop ? i.loop : 0), c(g, u += 4, s(g, u - 12, 12)), u += 4), 3 == e.ctype) {\n    c(g, u, 3 * (v = e.plte.length)), l(g, u += 4, \"PLTE\"), u += 4;\n\n    for (p = 0; p < v; p++) {\n      var w = 3 * p,\n          _ = e.plte[p],\n          P = 255 & _,\n          b = _ >>> 8 & 255,\n          y = _ >>> 16 & 255;\n      g[u + w + 0] = P, g[u + w + 1] = b, g[u + w + 2] = y;\n    }\n\n    if (c(g, u += 3 * v, s(g, u - 3 * v - 4, 3 * v + 4)), u += 4, h) {\n      c(g, u, v), l(g, u += 4, \"tRNS\"), u += 4;\n\n      for (p = 0; p < v; p++) g[u + p] = e.plte[p] >>> 24 & 255;\n\n      c(g, u += v, s(g, u - v - 4, v + 4)), u += 4;\n    }\n  }\n\n  var I = 0;\n\n  for (m = 0; m < e.frames.length; m++) {\n    var F = e.frames[m];\n    d && (c(g, u, 26), l(g, u += 4, \"fcTL\"), c(g, u += 4, I++), c(g, u += 4, F.rect.width), c(g, u += 4, F.rect.height), c(g, u += 4, F.rect.x), c(g, u += 4, F.rect.y), f(g, u += 4, a[m]), f(g, u += 2, 1e3), g[u += 2] = F.dispose, g[++u] = F.blend, c(g, ++u, s(g, u - 30, 30)), u += 4);\n    var E = F.cimg;\n    c(g, u, (v = E.length) + (0 == m ? 0 : 4));\n    var C = u += 4;\n    l(g, u, 0 == m ? \"IDAT\" : \"fdAT\"), u += 4, 0 != m && (c(g, u, I++), u += 4), g.set(E, u), c(g, u += v, s(g, C, u - C)), u += 4;\n  }\n\n  return c(g, u, 0), l(g, u += 4, \"IEND\"), c(g, u += 4, s(g, u - 4, 4)), u += 4, g.buffer;\n}, UPNG.encode.compressPNG = function (e, r, t) {\n  for (var a = 0; a < e.frames.length; a++) {\n    var i = e.frames[a];\n    i.rect.width;\n    var s = i.rect.height,\n        c = new Uint8Array(s * i.bpl + s);\n    i.cimg = UPNG.encode._filterZero(i.img, s, i.bpp, i.bpl, c, r, t);\n  }\n}, UPNG.encode.compress = function (e, r, t, a, i) {\n  for (var s = i[0], c = i[1], f = i[2], l = i[3], u = i[4], d = 6, h = 8, A = 255, v = 0; v < e.length; v++) for (var p = new Uint8Array(e[v]), m = p.length, g = 0; g < m; g += 4) A &= p[g + 3];\n\n  var U = 255 != A,\n      w = UPNG.encode.framize(e, r, t, s, c, f),\n      _ = {},\n      P = [],\n      b = [];\n\n  if (0 != a) {\n    var y = [];\n\n    for (g = 0; g < w.length; g++) y.push(w[g].img.buffer);\n\n    var I = UPNG.encode.concatRGBA(y),\n        F = UPNG.quantize(I, a),\n        E = 0,\n        C = new Uint8Array(F.abuf);\n\n    for (g = 0; g < w.length; g++) {\n      var B = (K = w[g].img).length;\n      b.push(new Uint8Array(F.inds.buffer, E >> 2, B >> 2));\n\n      for (v = 0; v < B; v += 4) K[v] = C[E + v], K[v + 1] = C[E + v + 1], K[v + 2] = C[E + v + 2], K[v + 3] = C[E + v + 3];\n\n      E += B;\n    }\n\n    for (g = 0; g < F.plte.length; g++) P.push(F.plte[g].est.rgba);\n  } else for (v = 0; v < w.length; v++) {\n    var R = w[v],\n        G = new Uint32Array(R.img.buffer),\n        M = R.rect.width,\n        O = (m = G.length, new Uint8Array(m));\n    b.push(O);\n\n    for (g = 0; g < m; g++) {\n      var x = G[g];\n      if (0 != g && x == G[g - 1]) O[g] = O[g - 1];else if (g > M && x == G[g - M]) O[g] = O[g - M];else {\n        var S = _[x];\n        if (null == S && (_[x] = S = P.length, P.push(x), P.length >= 300)) break;\n        O[g] = S;\n      }\n    }\n  }\n\n  var Z = P.length;\n  Z <= 256 && 0 == u && (h = Z <= 2 ? 1 : Z <= 4 ? 2 : Z <= 16 ? 4 : 8, h = Math.max(h, l));\n\n  for (v = 0; v < w.length; v++) {\n    (R = w[v]).rect.x, R.rect.y;\n    M = R.rect.width;\n    var Q = R.rect.height,\n        T = R.img;\n    new Uint32Array(T.buffer);\n    var D = 4 * M,\n        z = 4;\n\n    if (Z <= 256 && 0 == u) {\n      D = Math.ceil(h * M / 8);\n\n      for (var V = new Uint8Array(D * Q), L = b[v], k = 0; k < Q; k++) {\n        g = k * D;\n        var q = k * M;\n        if (8 == h) for (var $ = 0; $ < M; $++) V[g + $] = L[q + $];else if (4 == h) for ($ = 0; $ < M; $++) V[g + ($ >> 1)] |= L[q + $] << 4 - 4 * (1 & $);else if (2 == h) for ($ = 0; $ < M; $++) V[g + ($ >> 2)] |= L[q + $] << 6 - 2 * (3 & $);else if (1 == h) for ($ = 0; $ < M; $++) V[g + ($ >> 3)] |= L[q + $] << 7 - 1 * (7 & $);\n      }\n\n      T = V, d = 3, z = 1;\n    } else if (0 == U && 1 == w.length) {\n      V = new Uint8Array(M * Q * 3);\n      var j = M * Q;\n\n      for (g = 0; g < j; g++) {\n        var K,\n            X = 4 * g;\n        V[K = 3 * g] = T[X], V[K + 1] = T[X + 1], V[K + 2] = T[X + 2];\n      }\n\n      T = V, d = 2, z = 3, D = 3 * M;\n    }\n\n    R.img = T, R.bpl = D, R.bpp = z;\n  }\n\n  return {\n    ctype: d,\n    depth: h,\n    plte: P,\n    frames: w\n  };\n}, UPNG.encode.framize = function (e, r, t, a, i, s) {\n  for (var c = [], f = 0; f < e.length; f++) {\n    var l,\n        u = new Uint8Array(e[f]),\n        d = new Uint32Array(u.buffer),\n        h = 0,\n        A = 0,\n        v = r,\n        p = t,\n        m = a ? 1 : 0;\n\n    if (0 != f) {\n      for (var g = s || a || 1 == f || 0 != c[f - 2].dispose ? 1 : 2, U = 0, w = 1e9, _ = 0; _ < g; _++) {\n        for (var P = new Uint8Array(e[f - 1 - _]), b = new Uint32Array(e[f - 1 - _]), y = r, I = t, F = -1, E = -1, C = 0; C < t; C++) for (var B = 0; B < r; B++) {\n          d[Z = C * r + B] != b[Z] && (B < y && (y = B), B > F && (F = B), C < I && (I = C), C > E && (E = C));\n        }\n\n        -1 == F && (y = I = F = E = 0), i && (1 == (1 & y) && y--, 1 == (1 & I) && I--);\n        var R = (F - y + 1) * (E - I + 1);\n        R < w && (w = R, U = _, h = y, A = I, v = F - y + 1, p = E - I + 1);\n      }\n\n      P = new Uint8Array(e[f - 1 - U]);\n      1 == U && (c[f - 1].dispose = 2), l = new Uint8Array(v * p * 4), UPNG._copyTile(P, r, t, l, v, p, -h, -A, 0), 1 == (m = UPNG._copyTile(u, r, t, l, v, p, -h, -A, 3) ? 1 : 0) ? UPNG.encode._prepareDiff(u, r, t, l, {\n        x: h,\n        y: A,\n        width: v,\n        height: p\n      }) : UPNG._copyTile(u, r, t, l, v, p, -h, -A, 0);\n    } else l = u.slice(0);\n\n    c.push({\n      rect: {\n        x: h,\n        y: A,\n        width: v,\n        height: p\n      },\n      img: l,\n      blend: m,\n      dispose: 0\n    });\n  }\n\n  if (a) for (f = 0; f < c.length; f++) {\n    if (1 != (Q = c[f]).blend) {\n      var G = Q.rect,\n          M = c[f - 1].rect,\n          O = Math.min(G.x, M.x),\n          x = Math.min(G.y, M.y),\n          S = {\n        x: O,\n        y: x,\n        width: Math.max(G.x + G.width, M.x + M.width) - O,\n        height: Math.max(G.y + G.height, M.y + M.height) - x\n      };\n      c[f - 1].dispose = 1, f - 1 != 0 && UPNG.encode._updateFrame(e, r, t, c, f - 1, S, i), UPNG.encode._updateFrame(e, r, t, c, f, S, i);\n    }\n  }\n  if (1 != e.length) for (var Z = 0; Z < c.length; Z++) {\n    var Q;\n    (Q = c[Z]).rect.width * Q.rect.height;\n  }\n  return c;\n}, UPNG.encode._updateFrame = function (e, r, t, a, i, s, c) {\n  for (var f = Uint8Array, l = Uint32Array, u = new f(e[i - 1]), d = new l(e[i - 1]), h = i + 1 < e.length ? new f(e[i + 1]) : null, A = new f(e[i]), v = new l(A.buffer), p = r, m = t, g = -1, U = -1, w = 0; w < s.height; w++) for (var _ = 0; _ < s.width; _++) {\n    var P = s.x + _,\n        b = s.y + w,\n        y = b * r + P,\n        I = v[y];\n    0 == I || 0 == a[i - 1].dispose && d[y] == I && (null == h || 0 != h[4 * y + 3]) || (P < p && (p = P), P > g && (g = P), b < m && (m = b), b > U && (U = b));\n  }\n\n  -1 == g && (p = m = g = U = 0), c && (1 == (1 & p) && p--, 1 == (1 & m) && m--), s = {\n    x: p,\n    y: m,\n    width: g - p + 1,\n    height: U - m + 1\n  };\n  var F = a[i];\n  F.rect = s, F.blend = 1, F.img = new Uint8Array(s.width * s.height * 4), 0 == a[i - 1].dispose ? (UPNG._copyTile(u, r, t, F.img, s.width, s.height, -s.x, -s.y, 0), UPNG.encode._prepareDiff(A, r, t, F.img, s)) : UPNG._copyTile(A, r, t, F.img, s.width, s.height, -s.x, -s.y, 0);\n}, UPNG.encode._prepareDiff = function (e, r, t, a, i) {\n  UPNG._copyTile(e, r, t, a, i.width, i.height, -i.x, -i.y, 2);\n}, UPNG.encode._filterZero = function (e, r, t, a, i, s, c) {\n  var f,\n      l = [],\n      u = [0, 1, 2, 3, 4];\n  -1 != s ? u = [s] : (r * a > 5e5 || 1 == t) && (u = [0]), c && (f = {\n    level: 0\n  });\n\n  for (var d, h = UZIP, A = 0; A < u.length; A++) {\n    for (var v = 0; v < r; v++) UPNG.encode._filterLine(i, e, v, a, t, u[A]);\n\n    l.push(h.deflate(i, f));\n  }\n\n  var p = 1e9;\n\n  for (A = 0; A < l.length; A++) l[A].length < p && (d = A, p = l[A].length);\n\n  return l[d];\n}, UPNG.encode._filterLine = function (e, r, t, a, i, s) {\n  var c = t * a,\n      f = c + t,\n      l = UPNG.decode._paeth;\n  if (e[f] = s, f++, 0 == s) {\n    if (a < 500) for (var u = 0; u < a; u++) e[f + u] = r[c + u];else e.set(new Uint8Array(r.buffer, c, a), f);\n  } else if (1 == s) {\n    for (u = 0; u < i; u++) e[f + u] = r[c + u];\n\n    for (u = i; u < a; u++) e[f + u] = r[c + u] - r[c + u - i] + 256 & 255;\n  } else if (0 == t) {\n    for (u = 0; u < i; u++) e[f + u] = r[c + u];\n\n    if (2 == s) for (u = i; u < a; u++) e[f + u] = r[c + u];\n    if (3 == s) for (u = i; u < a; u++) e[f + u] = r[c + u] - (r[c + u - i] >> 1) + 256 & 255;\n    if (4 == s) for (u = i; u < a; u++) e[f + u] = r[c + u] - l(r[c + u - i], 0, 0) + 256 & 255;\n  } else {\n    if (2 == s) for (u = 0; u < a; u++) e[f + u] = r[c + u] + 256 - r[c + u - a] & 255;\n\n    if (3 == s) {\n      for (u = 0; u < i; u++) e[f + u] = r[c + u] + 256 - (r[c + u - a] >> 1) & 255;\n\n      for (u = i; u < a; u++) e[f + u] = r[c + u] + 256 - (r[c + u - a] + r[c + u - i] >> 1) & 255;\n    }\n\n    if (4 == s) {\n      for (u = 0; u < i; u++) e[f + u] = r[c + u] + 256 - l(0, r[c + u - a], 0) & 255;\n\n      for (u = i; u < a; u++) e[f + u] = r[c + u] + 256 - l(r[c + u - i], r[c + u - a], r[c + u - i - a]) & 255;\n    }\n  }\n}, UPNG.crc = {\n  table: function () {\n    for (var e = new Uint32Array(256), r = 0; r < 256; r++) {\n      for (var t = r, a = 0; a < 8; a++) 1 & t ? t = 3988292384 ^ t >>> 1 : t >>>= 1;\n\n      e[r] = t;\n    }\n\n    return e;\n  }(),\n  update: function update(e, r, t, a) {\n    for (var i = 0; i < a; i++) e = UPNG.crc.table[255 & (e ^ r[t + i])] ^ e >>> 8;\n\n    return e;\n  },\n  crc: function crc(e, r, t) {\n    return 4294967295 ^ UPNG.crc.update(4294967295, e, r, t);\n  }\n}, UPNG.quantize = function (e, r) {\n  var t,\n      a = new Uint8Array(e),\n      i = a.slice(0),\n      s = new Uint32Array(i.buffer),\n      c = UPNG.quantize.getKDtree(i, r),\n      f = c[0],\n      l = c[1],\n      u = UPNG.quantize.planeDst,\n      d = a,\n      h = s,\n      A = d.length,\n      v = new Uint8Array(a.length >> 2);\n  if (a.length < 2e7) for (var p = 0; p < A; p += 4) {\n    var m = d[p] * (1 / 255),\n        g = d[p + 1] * (1 / 255),\n        U = d[p + 2] * (1 / 255),\n        w = d[p + 3] * (1 / 255);\n    t = UPNG.quantize.getNearest(f, m, g, U, w), v[p >> 2] = t.ind, h[p >> 2] = t.est.rgba;\n  } else for (p = 0; p < A; p += 4) {\n    m = d[p] * (1 / 255), g = d[p + 1] * (1 / 255), U = d[p + 2] * (1 / 255), w = d[p + 3] * (1 / 255);\n\n    for (t = f; t.left;) t = u(t.est, m, g, U, w) <= 0 ? t.left : t.right;\n\n    v[p >> 2] = t.ind, h[p >> 2] = t.est.rgba;\n  }\n  return {\n    abuf: i.buffer,\n    inds: v,\n    plte: l\n  };\n}, UPNG.quantize.getKDtree = function (e, r, t) {\n  null == t && (t = 1e-4);\n  var a = new Uint32Array(e.buffer),\n      i = {\n    i0: 0,\n    i1: e.length,\n    bst: null,\n    est: null,\n    tdst: 0,\n    left: null,\n    right: null\n  };\n  i.bst = UPNG.quantize.stats(e, i.i0, i.i1), i.est = UPNG.quantize.estats(i.bst);\n\n  for (var s = [i]; s.length < r;) {\n    for (var c = 0, f = 0, l = 0; l < s.length; l++) s[l].est.L > c && (c = s[l].est.L, f = l);\n\n    if (c < t) break;\n    var u = s[f],\n        d = UPNG.quantize.splitPixels(e, a, u.i0, u.i1, u.est.e, u.est.eMq255);\n    if (u.i0 >= d || u.i1 <= d) u.est.L = 0;else {\n      var h = {\n        i0: u.i0,\n        i1: d,\n        bst: null,\n        est: null,\n        tdst: 0,\n        left: null,\n        right: null\n      };\n      h.bst = UPNG.quantize.stats(e, h.i0, h.i1), h.est = UPNG.quantize.estats(h.bst);\n      var A = {\n        i0: d,\n        i1: u.i1,\n        bst: null,\n        est: null,\n        tdst: 0,\n        left: null,\n        right: null\n      };\n      A.bst = {\n        R: [],\n        m: [],\n        N: u.bst.N - h.bst.N\n      };\n\n      for (l = 0; l < 16; l++) A.bst.R[l] = u.bst.R[l] - h.bst.R[l];\n\n      for (l = 0; l < 4; l++) A.bst.m[l] = u.bst.m[l] - h.bst.m[l];\n\n      A.est = UPNG.quantize.estats(A.bst), u.left = h, u.right = A, s[f] = h, s.push(A);\n    }\n  }\n\n  s.sort(function (e, r) {\n    return r.bst.N - e.bst.N;\n  });\n\n  for (l = 0; l < s.length; l++) s[l].ind = l;\n\n  return [i, s];\n}, UPNG.quantize.getNearest = function (e, r, t, a, i) {\n  if (null == e.left) return e.tdst = UPNG.quantize.dist(e.est.q, r, t, a, i), e;\n  var s = UPNG.quantize.planeDst(e.est, r, t, a, i),\n      c = e.left,\n      f = e.right;\n  s > 0 && (c = e.right, f = e.left);\n  var l = UPNG.quantize.getNearest(c, r, t, a, i);\n  if (l.tdst <= s * s) return l;\n  var u = UPNG.quantize.getNearest(f, r, t, a, i);\n  return u.tdst < l.tdst ? u : l;\n}, UPNG.quantize.planeDst = function (e, r, t, a, i) {\n  var s = e.e;\n  return s[0] * r + s[1] * t + s[2] * a + s[3] * i - e.eMq;\n}, UPNG.quantize.dist = function (e, r, t, a, i) {\n  var s = r - e[0],\n      c = t - e[1],\n      f = a - e[2],\n      l = i - e[3];\n  return s * s + c * c + f * f + l * l;\n}, UPNG.quantize.splitPixels = function (e, r, t, a, i, s) {\n  var c = UPNG.quantize.vecDot;\n\n  for (a -= 4; t < a;) {\n    for (; c(e, t, i) <= s;) t += 4;\n\n    for (; c(e, a, i) > s;) a -= 4;\n\n    if (t >= a) break;\n    var f = r[t >> 2];\n    r[t >> 2] = r[a >> 2], r[a >> 2] = f, t += 4, a -= 4;\n  }\n\n  for (; c(e, t, i) > s;) t -= 4;\n\n  return t + 4;\n}, UPNG.quantize.vecDot = function (e, r, t) {\n  return e[r] * t[0] + e[r + 1] * t[1] + e[r + 2] * t[2] + e[r + 3] * t[3];\n}, UPNG.quantize.stats = function (e, r, t) {\n  for (var a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i = [0, 0, 0, 0], s = t - r >> 2, c = r; c < t; c += 4) {\n    var f = e[c] * (1 / 255),\n        l = e[c + 1] * (1 / 255),\n        u = e[c + 2] * (1 / 255),\n        d = e[c + 3] * (1 / 255);\n    i[0] += f, i[1] += l, i[2] += u, i[3] += d, a[0] += f * f, a[1] += f * l, a[2] += f * u, a[3] += f * d, a[5] += l * l, a[6] += l * u, a[7] += l * d, a[10] += u * u, a[11] += u * d, a[15] += d * d;\n  }\n\n  return a[4] = a[1], a[8] = a[2], a[9] = a[6], a[12] = a[3], a[13] = a[7], a[14] = a[11], {\n    R: a,\n    m: i,\n    N: s\n  };\n}, UPNG.quantize.estats = function (e) {\n  var r = e.R,\n      t = e.m,\n      a = e.N,\n      i = t[0],\n      s = t[1],\n      c = t[2],\n      f = t[3],\n      l = 0 == a ? 0 : 1 / a,\n      u = [r[0] - i * i * l, r[1] - i * s * l, r[2] - i * c * l, r[3] - i * f * l, r[4] - s * i * l, r[5] - s * s * l, r[6] - s * c * l, r[7] - s * f * l, r[8] - c * i * l, r[9] - c * s * l, r[10] - c * c * l, r[11] - c * f * l, r[12] - f * i * l, r[13] - f * s * l, r[14] - f * c * l, r[15] - f * f * l],\n      d = u,\n      h = UPNG.M4,\n      A = [Math.random(), Math.random(), Math.random(), Math.random()],\n      v = 0,\n      p = 0;\n  if (0 != a) for (var m = 0; m < 16 && (A = h.multVec(d, A), p = Math.sqrt(h.dot(A, A)), A = h.sml(1 / p, A), !(0 != m && Math.abs(p - v) < 1e-9)); m++) v = p;\n  var g = [i * l, s * l, c * l, f * l];\n  return {\n    Cov: u,\n    q: g,\n    e: A,\n    L: v,\n    eMq255: h.dot(h.sml(255, g), A),\n    eMq: h.dot(A, g),\n    rgba: (Math.round(255 * g[3]) << 24 | Math.round(255 * g[2]) << 16 | Math.round(255 * g[1]) << 8 | Math.round(255 * g[0]) << 0) >>> 0\n  };\n}, UPNG.M4 = {\n  multVec: function multVec(e, r) {\n    return [e[0] * r[0] + e[1] * r[1] + e[2] * r[2] + e[3] * r[3], e[4] * r[0] + e[5] * r[1] + e[6] * r[2] + e[7] * r[3], e[8] * r[0] + e[9] * r[1] + e[10] * r[2] + e[11] * r[3], e[12] * r[0] + e[13] * r[1] + e[14] * r[2] + e[15] * r[3]];\n  },\n  dot: function dot(e, r) {\n    return e[0] * r[0] + e[1] * r[1] + e[2] * r[2] + e[3] * r[3];\n  },\n  sml: function sml(e, r) {\n    return [e * r[0], e * r[1], e * r[2], e * r[3]];\n  }\n}, UPNG.encode.concatRGBA = function (e) {\n  for (var r = 0, t = 0; t < e.length; t++) r += e[t].byteLength;\n\n  var a = new Uint8Array(r),\n      i = 0;\n\n  for (t = 0; t < e.length; t++) {\n    for (var s = new Uint8Array(e[t]), c = s.length, f = 0; f < c; f += 4) {\n      var l = s[f],\n          u = s[f + 1],\n          d = s[f + 2],\n          h = s[f + 3];\n      0 == h && (l = u = d = 0), a[i + f] = l, a[i + f + 1] = u, a[i + f + 2] = d, a[i + f + 3] = h;\n    }\n\n    i += c;\n  }\n\n  return a.buffer;\n};\n\nvar BROWSER_NAME = {\n  CHROME: \"CHROME\",\n  FIREFOX: \"FIREFOX\",\n  DESKTOP_SAFARI: \"DESKTOP_SAFARI\",\n  IE: \"IE\",\n  MOBILE_SAFARI: \"MOBILE_SAFARI\",\n  ETC: \"ETC\"\n},\n    _BROWSER_NAME$CHROME$,\n    MAX_CANVAS_SIZE = (_BROWSER_NAME$CHROME$ = {}, _defineProperty(_BROWSER_NAME$CHROME$, BROWSER_NAME.CHROME, 16384), _defineProperty(_BROWSER_NAME$CHROME$, BROWSER_NAME.FIREFOX, 11180), _defineProperty(_BROWSER_NAME$CHROME$, BROWSER_NAME.DESKTOP_SAFARI, 16384), _defineProperty(_BROWSER_NAME$CHROME$, BROWSER_NAME.IE, 8192), _defineProperty(_BROWSER_NAME$CHROME$, BROWSER_NAME.MOBILE_SAFARI, 4096), _defineProperty(_BROWSER_NAME$CHROME$, BROWSER_NAME.ETC, 8192), _BROWSER_NAME$CHROME$),\n    isBrowser = \"undefined\" != typeof window,\n    moduleMapper = isBrowser && window.cordova && window.cordova.require && window.cordova.require(\"cordova/modulemapper\"),\n    CustomFile = isBrowser && (moduleMapper && moduleMapper.getOriginalSymbol(window, \"File\") || void 0 !== window.File && File),\n    CustomFileReader = isBrowser && (moduleMapper && moduleMapper.getOriginalSymbol(window, \"FileReader\") || void 0 !== window.FileReader && FileReader);\n\nfunction getFilefromDataUrl(e, r) {\n  var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Date.now();\n  return new Promise(function (a) {\n    for (var i = e.split(\",\"), s = i[0].match(/:(.*?);/)[1], c = globalThis.atob(i[1]), f = c.length, l = new Uint8Array(f); f--;) l[f] = c.charCodeAt(f);\n\n    var u = new Blob([l], {\n      type: s\n    });\n    u.name = r, u.lastModified = t, a(u);\n  });\n}\n\nfunction getDataUrlFromFile(e) {\n  return new Promise(function (r, t) {\n    var a = new CustomFileReader();\n    a.onload = function () {\n      return r(a.result);\n    }, a.onerror = function (e) {\n      return t(e);\n    }, a.readAsDataURL(e);\n  });\n}\n\nfunction loadImage(e) {\n  return new Promise(function (r, t) {\n    var a = new Image();\n    a.onload = function () {\n      return r(a);\n    }, a.onerror = function (e) {\n      return t(e);\n    }, a.src = e;\n  });\n}\n\nfunction getBrowserName() {\n  if (void 0 !== getBrowserName.cachedResult) return getBrowserName.cachedResult;\n  var e = BROWSER_NAME.ETC,\n      r = navigator.userAgent;\n  return /Chrom(e|ium)/i.test(r) ? e = BROWSER_NAME.CHROME : /iP(ad|od|hone)/i.test(r) && /WebKit/i.test(r) && !/(CriOS|FxiOS|OPiOS|mercury)/i.test(r) ? e = BROWSER_NAME.MOBILE_SAFARI : /Safari/i.test(r) ? e = BROWSER_NAME.DESKTOP_SAFARI : /Firefox/i.test(r) ? e = BROWSER_NAME.FIREFOX : (/MSIE/i.test(r) || !0 == !!document.documentMode) && (e = BROWSER_NAME.IE), getBrowserName.cachedResult = e, getBrowserName.cachedResult;\n}\n\nfunction approximateBelowMaximumCanvasSizeOfBrowser(e, r) {\n  for (var t = getBrowserName(), a = MAX_CANVAS_SIZE[t], i = e, s = r, c = i * s, f = i > s ? s / i : i / s; c > a * a;) {\n    var l = (a + i) / 2,\n        u = (a + s) / 2;\n    l < u ? (s = u, i = u * f) : (s = l * f, i = l), c = i * s;\n  }\n\n  return {\n    width: i,\n    height: s\n  };\n}\n\nfunction getNewCanvasAndCtx(e, r) {\n  var t, a;\n\n  try {\n    if (null === (a = (t = new OffscreenCanvas(e, r)).getContext(\"2d\"))) throw new Error(\"getContext of OffscreenCanvas returns null\");\n  } catch (e) {\n    a = (t = document.createElement(\"canvas\")).getContext(\"2d\");\n  }\n\n  return t.width = e, t.height = r, [t, a];\n}\n\nfunction drawImageInCanvas(e) {\n  var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0,\n      t = approximateBelowMaximumCanvasSizeOfBrowser(e.width, e.height),\n      a = t.width,\n      i = t.height,\n      s = getNewCanvasAndCtx(a, i),\n      c = _slicedToArray(s, 2),\n      f = c[0],\n      l = c[1];\n\n  return r && /jpe?g/.test(r) && (l.fillStyle = \"white\", l.fillRect(0, 0, f.width, f.height)), l.drawImage(e, 0, 0, f.width, f.height), f;\n}\n\nfunction isIOS() {\n  return void 0 !== isIOS.cachedResult || (isIOS.cachedResult = [\"iPad Simulator\", \"iPhone Simulator\", \"iPod Simulator\", \"iPad\", \"iPhone\", \"iPod\"].includes(navigator.platform) || navigator.userAgent.includes(\"Mac\") && \"undefined\" != typeof document && \"ontouchend\" in document), isIOS.cachedResult;\n}\n\nfunction drawFileInCanvas(e) {\n  var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n  return new Promise(function (t, a) {\n    var i,\n        s,\n        c = function $Try_2_Post() {\n      try {\n        return s = drawImageInCanvas(i, r.fileType || e.type), t([i, s]);\n      } catch (e) {\n        return a(e);\n      }\n    },\n        f = function $Try_2_Catch(r) {\n      try {\n        0;\n\n        var t = function $Try_3_Catch(e) {\n          try {\n            throw e;\n          } catch (e) {\n            return a(e);\n          }\n        };\n\n        try {\n          return getDataUrlFromFile(e).then(function (e) {\n            try {\n              return loadImage(e).then(function (e) {\n                try {\n                  return i = e, function $Try_3_Post() {\n                    try {\n                      return c();\n                    } catch (e) {\n                      return a(e);\n                    }\n                  }();\n                } catch (e) {\n                  return t(e);\n                }\n              }, t);\n            } catch (e) {\n              return t(e);\n            }\n          }, t);\n        } catch (e) {\n          t(e);\n        }\n      } catch (e) {\n        return a(e);\n      }\n    };\n\n    try {\n      if (isIOS() || [BROWSER_NAME.DESKTOP_SAFARI, BROWSER_NAME.MOBILE_SAFARI].includes(getBrowserName())) throw new Error(\"Skip createImageBitmap on IOS and Safari\");\n      return createImageBitmap(e).then(function (e) {\n        try {\n          return i = e, c();\n        } catch (e) {\n          return f();\n        }\n      }, f);\n    } catch (e) {\n      f();\n    }\n  });\n}\n\nfunction canvasToFile(e, r, t, a) {\n  var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1;\n  return new Promise(function (s, c) {\n    var f, l, u;\n    if (\"image/png\" === r) return l = e.getContext(\"2d\").getImageData(0, 0, e.width, e.height).data, u = UPNG.encode([l], e.width, e.height, 256 * i), (f = new Blob([u], {\n      type: r\n    })).name = t, f.lastModified = a, $If_4.call(this);\n    {\n      return \"function\" == typeof OffscreenCanvas && e instanceof OffscreenCanvas ? e.convertToBlob({\n        type: r,\n        quality: i\n      }).then(function (e) {\n        try {\n          return (f = e).name = t, f.lastModified = a, $If_5.call(this);\n        } catch (e) {\n          return c(e);\n        }\n      }.bind(this), c) : getFilefromDataUrl(e.toDataURL(r, i), t, a).then(function (e) {\n        try {\n          return f = e, $If_5.call(this);\n        } catch (e) {\n          return c(e);\n        }\n      }.bind(this), c);\n\n      function $If_5() {\n        return $If_4.call(this);\n      }\n    }\n\n    function $If_4() {\n      return s(f);\n    }\n  });\n}\n\nfunction cleanupCanvasMemory(e) {\n  e.width = 0, e.height = 0;\n}\n\nfunction isAutoOrientationInBrowser() {\n  return new Promise(function (e, r) {\n    var t, a, i, s;\n    return void 0 !== isAutoOrientationInBrowser.cachedResult ? e(isAutoOrientationInBrowser.cachedResult) : (\"data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAAAAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/xABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q==\", getFilefromDataUrl(\"data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAAAAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/xABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q==\", \"test.jpg\", Date.now()).then(function (c) {\n      try {\n        return drawFileInCanvas(t = c).then(function (c) {\n          try {\n            return canvasToFile(a = c[1], t.type, t.name, t.lastModified).then(function (t) {\n              try {\n                return i = t, cleanupCanvasMemory(a), drawFileInCanvas(i).then(function (t) {\n                  try {\n                    return s = t[0], isAutoOrientationInBrowser.cachedResult = 1 === s.width && 2 === s.height, e(isAutoOrientationInBrowser.cachedResult);\n                  } catch (e) {\n                    return r(e);\n                  }\n                }, r);\n              } catch (e) {\n                return r(e);\n              }\n            }, r);\n          } catch (e) {\n            return r(e);\n          }\n        }, r);\n      } catch (e) {\n        return r(e);\n      }\n    }, r));\n  });\n}\n\nfunction getExifOrientation(e) {\n  return new Promise(function (r, t) {\n    var a = new CustomFileReader();\n    a.onload = function (e) {\n      var t = new DataView(e.target.result);\n      if (65496 != t.getUint16(0, !1)) return r(-2);\n\n      for (var a = t.byteLength, i = 2; i < a;) {\n        if (t.getUint16(i + 2, !1) <= 8) return r(-1);\n        var s = t.getUint16(i, !1);\n\n        if (i += 2, 65505 == s) {\n          if (1165519206 != t.getUint32(i += 2, !1)) return r(-1);\n          var c = 18761 == t.getUint16(i += 6, !1);\n          i += t.getUint32(i + 4, c);\n          var f = t.getUint16(i, c);\n          i += 2;\n\n          for (var l = 0; l < f; l++) if (274 == t.getUint16(i + 12 * l, c)) return r(t.getUint16(i + 12 * l + 8, c));\n        } else {\n          if (65280 != (65280 & s)) break;\n          i += t.getUint16(i, !1);\n        }\n      }\n\n      return r(-1);\n    }, a.onerror = function (e) {\n      return t(e);\n    }, a.readAsArrayBuffer(e);\n  });\n}\n\nfunction handleMaxWidthOrHeight(e, r) {\n  var t,\n      a = e.width,\n      i = e.height,\n      s = r.maxWidthOrHeight,\n      c = e;\n\n  if (isFinite(s) && (a > s || i > s)) {\n    var f = _slicedToArray(getNewCanvasAndCtx(a, i), 2);\n\n    c = f[0], t = f[1], a > i ? (c.width = s, c.height = i / a * s) : (c.width = a / i * s, c.height = s), t.drawImage(e, 0, 0, c.width, c.height), cleanupCanvasMemory(e);\n  }\n\n  return c;\n}\n\nfunction followExifOrientation(e, r) {\n  var t = e.width,\n      a = e.height,\n      i = _slicedToArray(getNewCanvasAndCtx(t, a), 2),\n      s = i[0],\n      c = i[1];\n\n  switch (r > 4 && r < 9 ? (s.width = a, s.height = t) : (s.width = t, s.height = a), r) {\n    case 2:\n      c.transform(-1, 0, 0, 1, t, 0);\n      break;\n\n    case 3:\n      c.transform(-1, 0, 0, -1, t, a);\n      break;\n\n    case 4:\n      c.transform(1, 0, 0, -1, 0, a);\n      break;\n\n    case 5:\n      c.transform(0, 1, 1, 0, 0, 0);\n      break;\n\n    case 6:\n      c.transform(0, 1, -1, 0, a, 0);\n      break;\n\n    case 7:\n      c.transform(0, -1, -1, 0, a, t);\n      break;\n\n    case 8:\n      c.transform(0, -1, 1, 0, 0, t);\n  }\n\n  return c.drawImage(e, 0, 0, t, a), cleanupCanvasMemory(e), s;\n}\n\nfunction compress(e, r) {\n  var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;\n  return new Promise(function (a, i) {\n    var s, c, f, l, u, d, h, A, v, p, m, g, U, w, _, P, b, y, I;\n\n    function incProgress() {\n      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5;\n      if (r.signal && r.signal.aborted) throw r.signal.reason;\n      s += e, r.onProgress(Math.min(s, 100));\n    }\n\n    function setProgress(e) {\n      if (r.signal && r.signal.aborted) throw r.signal.reason;\n      s = Math.min(Math.max(e, s), 100), r.onProgress(s);\n    }\n\n    return s = t, c = r.maxIteration || 10, f = 1024 * r.maxSizeMB * 1024, incProgress(), drawFileInCanvas(e, r).then(function (t) {\n      try {\n        var s = _slicedToArray(t, 2);\n\n        return l = s[1], incProgress(), u = handleMaxWidthOrHeight(l, r), incProgress(), new Promise(function (t, a) {\n          var i;\n          if (!(i = r.exifOrientation)) return getExifOrientation(e).then(function (e) {\n            try {\n              return i = e, $If_2.call(this);\n            } catch (e) {\n              return a(e);\n            }\n          }.bind(this), a);\n\n          function $If_2() {\n            return t(i);\n          }\n\n          return $If_2.call(this);\n        }).then(function (t) {\n          try {\n            return d = t, incProgress(), isAutoOrientationInBrowser().then(function (t) {\n              try {\n                return h = t ? u : followExifOrientation(u, d), incProgress(), A = r.initialQuality || 1, v = r.fileType || e.type, canvasToFile(h, v, e.name, e.lastModified, A).then(function (t) {\n                  try {\n                    {\n                      if (p = t, incProgress(), m = p.size > f, g = p.size > e.size, !m && !g) return setProgress(100), a(p);\n                      var s;\n\n                      function $Loop_3() {\n                        if (c-- && (_ > f || _ > U)) {\n                          var r,\n                              t,\n                              a = _slicedToArray(getNewCanvasAndCtx(r = I ? .95 * y.width : y.width, t = I ? .95 * y.height : y.height), 2);\n\n                          return b = a[0], a[1].drawImage(y, 0, 0, r, t), A *= .95, canvasToFile(b, v, e.name, e.lastModified, A).then(function (e) {\n                            try {\n                              return P = e, cleanupCanvasMemory(y), y = b, _ = P.size, setProgress(Math.min(99, Math.floor((w - _) / (w - f) * 100))), $Loop_3;\n                            } catch (e) {\n                              return i(e);\n                            }\n                          }, i);\n                        }\n\n                        return [1];\n                      }\n\n                      return U = e.size, w = p.size, _ = w, y = h, I = !r.alwaysKeepResolution && m, (s = function (e) {\n                        for (; e;) {\n                          if (e.then) return void e.then(s, i);\n\n                          try {\n                            if (e.pop) {\n                              if (e.length) return e.pop() ? $Loop_3_exit.call(this) : e;\n                              e = $Loop_3;\n                            } else e = e.call(this);\n                          } catch (e) {\n                            return i(e);\n                          }\n                        }\n                      }.bind(this))($Loop_3);\n\n                      function $Loop_3_exit() {\n                        return cleanupCanvasMemory(y), cleanupCanvasMemory(b), cleanupCanvasMemory(u), cleanupCanvasMemory(h), cleanupCanvasMemory(l), setProgress(100), a(P);\n                      }\n                    }\n                  } catch (e) {\n                    return i(e);\n                  }\n                }.bind(this), i);\n              } catch (e) {\n                return i(e);\n              }\n            }.bind(this), i);\n          } catch (e) {\n            return i(e);\n          }\n        }.bind(this), i);\n      } catch (e) {\n        return i(e);\n      }\n    }.bind(this), i);\n  });\n}\n\nvar cnt = 0,\n    imageCompressionLibUrl,\n    worker;\n\nfunction createWorker(e) {\n  var r = [];\n  return \"function\" == typeof e ? r.push(\"(\".concat(e, \")()\")) : r.push(e), new Worker(URL.createObjectURL(new Blob(r)));\n}\n\nfunction createSourceObject(e) {\n  return URL.createObjectURL(new Blob([e], {\n    type: \"application/javascript\"\n  }));\n}\n\nfunction stringify(e) {\n  return JSON.stringify(e, function (e, r) {\n    return \"function\" == typeof r ? \"BIC_FN:::(function () { return \".concat(r.toString(), \" })()\") : r;\n  });\n}\n\nfunction parse(o) {\n  if (\"string\" == typeof o) return o;\n  var result = {};\n  return Object.entries(o).forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n\n    if (\"string\" == typeof value && value.startsWith(\"BIC_FN:::\")) try {\n      result[key] = eval(value.replace(/^BIC_FN:::/, \"\"));\n    } catch (e) {\n      throw e;\n    } else result[key] = parse(value);\n  }), result;\n}\n\nfunction generateLib() {\n  return createSourceObject(\"\\n    // reconstruct library\\n    function imageCompression (){return (\".concat(imageCompression, \").apply(null, arguments)}\\n\\n    imageCompression.getDataUrlFromFile = \").concat(imageCompression.getDataUrlFromFile, \"\\n    imageCompression.getFilefromDataUrl = \").concat(imageCompression.getFilefromDataUrl, \"\\n    imageCompression.loadImage = \").concat(imageCompression.loadImage, \"\\n    imageCompression.drawImageInCanvas = \").concat(imageCompression.drawImageInCanvas, \"\\n    imageCompression.drawFileInCanvas = \").concat(imageCompression.drawFileInCanvas, \"\\n    imageCompression.canvasToFile = \").concat(imageCompression.canvasToFile, \"\\n    imageCompression.getExifOrientation = \").concat(imageCompression.getExifOrientation, \"\\n    imageCompression.handleMaxWidthOrHeight = \").concat(imageCompression.handleMaxWidthOrHeight, \"\\n    imageCompression.followExifOrientation = \").concat(imageCompression.followExifOrientation, \"\\n    imageCompression.cleanupCanvasMemory = \").concat(imageCompression.cleanupCanvasMemory, \"\\n    imageCompression.isAutoOrientationInBrowser = \").concat(imageCompression.isAutoOrientationInBrowser, \"\\n    imageCompression.approximateBelowMaximumCanvasSizeOfBrowser = \").concat(imageCompression.approximateBelowMaximumCanvasSizeOfBrowser, \"\\n    imageCompression.getBrowserName = \").concat(imageCompression.getBrowserName, \"\\n\\n    // functions / objects\\n    getDataUrlFromFile = imageCompression.getDataUrlFromFile\\n    getFilefromDataUrl = imageCompression.getFilefromDataUrl\\n    loadImage = imageCompression.loadImage\\n    drawImageInCanvas = imageCompression.drawImageInCanvas\\n    drawFileInCanvas = imageCompression.drawFileInCanvas\\n    canvasToFile = imageCompression.canvasToFile\\n    getExifOrientation = imageCompression.getExifOrientation\\n    handleMaxWidthOrHeight = imageCompression.handleMaxWidthOrHeight\\n    followExifOrientation = imageCompression.followExifOrientation\\n    cleanupCanvasMemory = imageCompression.cleanupCanvasMemory\\n    isAutoOrientationInBrowser = imageCompression.isAutoOrientationInBrowser\\n    approximateBelowMaximumCanvasSizeOfBrowser = imageCompression.approximateBelowMaximumCanvasSizeOfBrowser\\n    getBrowserName = imageCompression.getBrowserName\\n    isIOS = \").concat(isIOS, \"\\n    \\n    getNewCanvasAndCtx = \").concat(getNewCanvasAndCtx, \"\\n    CustomFileReader = FileReader\\n    CustomFile = File\\n    MAX_CANVAS_SIZE = \").concat(JSON.stringify(MAX_CANVAS_SIZE), \"\\n    BROWSER_NAME = \").concat(JSON.stringify(BROWSER_NAME), \"\\n    function compress (){return (\").concat(compress, \").apply(null, arguments)}\\n\\n    // core-js\\n    function _slicedToArray(arr, n) { return arr }\\n    function _typeof(a) { return typeof a }\\n    function _objectSpread2(target) {\\n      for (var i = 1; i < arguments.length; i++) {\\n        var source = arguments[i] != null ? arguments[i] : {};\\n  \\n        Object.assign(target, source)\\n      }\\n  \\n      return target;\\n    }\\n\\n    // Libraries\\n    const parse = \").concat(parse, \"\\n    const UPNG = {}\\n    UPNG.toRGBA8 = \").concat(UPNG.toRGBA8, \"\\n    UPNG.toRGBA8.decodeImage = \").concat(UPNG.toRGBA8.decodeImage, \"\\n    UPNG.decode = \").concat(UPNG.decode, \"\\n    UPNG.decode._decompress = \").concat(UPNG.decode._decompress, \"\\n    UPNG.decode._inflate = \").concat(UPNG.decode._inflate, \"\\n    UPNG.decode._readInterlace = \").concat(UPNG.decode._readInterlace, \"\\n    UPNG.decode._getBPP = \").concat(UPNG.decode._getBPP, \" \\n    UPNG.decode._filterZero = \").concat(UPNG.decode._filterZero, \"\\n    UPNG.decode._paeth = \").concat(UPNG.decode._paeth, \"\\n    UPNG.decode._IHDR = \").concat(UPNG.decode._IHDR, \"\\n    UPNG._bin = parse(\").concat(stringify(UPNG._bin), \")\\n    UPNG._copyTile = \").concat(UPNG._copyTile, \"\\n    UPNG.encode = \").concat(UPNG.encode, \"\\n    UPNG.encodeLL = \").concat(UPNG.encodeLL, \" \\n    UPNG.encode._main = \").concat(UPNG.encode._main, \"\\n    UPNG.encode.compressPNG = \").concat(UPNG.encode.compressPNG, \" \\n    UPNG.encode.compress = \").concat(UPNG.encode.compress, \"\\n    UPNG.encode.framize = \").concat(UPNG.encode.framize, \" \\n    UPNG.encode._updateFrame = \").concat(UPNG.encode._updateFrame, \" \\n    UPNG.encode._prepareDiff = \").concat(UPNG.encode._prepareDiff, \" \\n    UPNG.encode._filterZero = \").concat(UPNG.encode._filterZero, \" \\n    UPNG.encode._filterLine = \").concat(UPNG.encode._filterLine, \"\\n    UPNG.encode.concatRGBA = \").concat(UPNG.encode.concatRGBA, \"\\n    UPNG.crc = parse(\").concat(stringify(UPNG.crc), \")\\n    UPNG.crc.table = ( function() {\\n    var tab = new Uint32Array(256);\\n    for (var n=0; n<256; n++) {\\n      var c = n;\\n      for (var k=0; k<8; k++) {\\n        if (c & 1)  c = 0xedb88320 ^ (c >>> 1);\\n        else        c = c >>> 1;\\n      }\\n      tab[n] = c;  }\\n    return tab;  })()\\n    UPNG.quantize = \").concat(UPNG.quantize, \" \\n    UPNG.quantize.getKDtree = \").concat(UPNG.quantize.getKDtree, \" \\n    UPNG.quantize.getNearest = \").concat(UPNG.quantize.getNearest, \" \\n    UPNG.quantize.planeDst = \").concat(UPNG.quantize.planeDst, \" \\n    UPNG.quantize.dist = \").concat(UPNG.quantize.dist, \"     \\n    UPNG.quantize.splitPixels = \").concat(UPNG.quantize.splitPixels, \" \\n    UPNG.quantize.vecDot = \").concat(UPNG.quantize.vecDot, \" \\n    UPNG.quantize.stats = \").concat(UPNG.quantize.stats, \" \\n    UPNG.quantize.estats = \").concat(UPNG.quantize.estats, \"\\n    UPNG.M4 = parse(\").concat(stringify(UPNG.M4), \")\\n    UPNG.encode.concatRGBA = \").concat(UPNG.encode.concatRGBA, '\\n    UPNG.inflateRaw=function(){\\n    var H={};H.H={};H.H.N=function(N,W){var R=Uint8Array,i=0,m=0,J=0,h=0,Q=0,X=0,u=0,w=0,d=0,v,C;\\n      if(N[0]==3&&N[1]==0)return W?W:new R(0);var V=H.H,n=V.b,A=V.e,l=V.R,M=V.n,I=V.A,e=V.Z,b=V.m,Z=W==null;\\n      if(Z)W=new R(N.length>>>2<<5);while(i==0){i=n(N,d,1);m=n(N,d+1,2);d+=3;if(m==0){if((d&7)!=0)d+=8-(d&7);\\n        var D=(d>>>3)+4,q=N[D-4]|N[D-3]<<8;if(Z)W=H.H.W(W,w+q);W.set(new R(N.buffer,N.byteOffset+D,q),w);d=D+q<<3;\\n        w+=q;continue}if(Z)W=H.H.W(W,w+(1<<17));if(m==1){v=b.J;C=b.h;X=(1<<9)-1;u=(1<<5)-1}if(m==2){J=A(N,d,5)+257;\\n        h=A(N,d+5,5)+1;Q=A(N,d+10,4)+4;d+=14;var E=d,j=1;for(var c=0;c<38;c+=2){b.Q[c]=0;b.Q[c+1]=0}for(var c=0;\\n                                                                                                        c<Q;c++){var K=A(N,d+c*3,3);b.Q[(b.X[c]<<1)+1]=K;if(K>j)j=K}d+=3*Q;M(b.Q,j);I(b.Q,j,b.u);v=b.w;C=b.d;\\n        d=l(b.u,(1<<j)-1,J+h,N,d,b.v);var r=V.V(b.v,0,J,b.C);X=(1<<r)-1;var S=V.V(b.v,J,h,b.D);u=(1<<S)-1;M(b.C,r);\\n        I(b.C,r,v);M(b.D,S);I(b.D,S,C)}while(!0){var T=v[e(N,d)&X];d+=T&15;var p=T>>>4;if(p>>>8==0){W[w++]=p}else if(p==256){break}else{var z=w+p-254;\\n        if(p>264){var _=b.q[p-257];z=w+(_>>>3)+A(N,d,_&7);d+=_&7}var $=C[e(N,d)&u];d+=$&15;var s=$>>>4,Y=b.c[s],a=(Y>>>4)+n(N,d,Y&15);\\n        d+=Y&15;while(w<z){W[w]=W[w++-a];W[w]=W[w++-a];W[w]=W[w++-a];W[w]=W[w++-a]}w=z}}}return W.length==w?W:W.slice(0,w)};\\n      H.H.W=function(N,W){var R=N.length;if(W<=R)return N;var V=new Uint8Array(R<<1);V.set(N,0);return V};\\n      H.H.R=function(N,W,R,V,n,A){var l=H.H.e,M=H.H.Z,I=0;while(I<R){var e=N[M(V,n)&W];n+=e&15;var b=e>>>4;\\n        if(b<=15){A[I]=b;I++}else{var Z=0,m=0;if(b==16){m=3+l(V,n,2);n+=2;Z=A[I-1]}else if(b==17){m=3+l(V,n,3);\\n          n+=3}else if(b==18){m=11+l(V,n,7);n+=7}var J=I+m;while(I<J){A[I]=Z;I++}}}return n};H.H.V=function(N,W,R,V){var n=0,A=0,l=V.length>>>1;\\n        while(A<R){var M=N[A+W];V[A<<1]=0;V[(A<<1)+1]=M;if(M>n)n=M;A++}while(A<l){V[A<<1]=0;V[(A<<1)+1]=0;A++}return n};\\n      H.H.n=function(N,W){var R=H.H.m,V=N.length,n,A,l,M,I,e=R.j;for(var M=0;M<=W;M++)e[M]=0;for(M=1;M<V;M+=2)e[N[M]]++;\\n        var b=R.K;n=0;e[0]=0;for(A=1;A<=W;A++){n=n+e[A-1]<<1;b[A]=n}for(l=0;l<V;l+=2){I=N[l+1];if(I!=0){N[l]=b[I];\\n          b[I]++}}};H.H.A=function(N,W,R){var V=N.length,n=H.H.m,A=n.r;for(var l=0;l<V;l+=2)if(N[l+1]!=0){var M=l>>1,I=N[l+1],e=M<<4|I,b=W-I,Z=N[l]<<b,m=Z+(1<<b);\\n        while(Z!=m){var J=A[Z]>>>15-W;R[J]=e;Z++}}};H.H.l=function(N,W){var R=H.H.m.r,V=15-W;for(var n=0;n<N.length;\\n                                                                                                 n+=2){var A=N[n]<<W-N[n+1];N[n]=R[A]>>>V}};H.H.M=function(N,W,R){R=R<<(W&7);var V=W>>>3;N[V]|=R;N[V+1]|=R>>>8};\\n      H.H.I=function(N,W,R){R=R<<(W&7);var V=W>>>3;N[V]|=R;N[V+1]|=R>>>8;N[V+2]|=R>>>16};H.H.e=function(N,W,R){return(N[W>>>3]|N[(W>>>3)+1]<<8)>>>(W&7)&(1<<R)-1};\\n      H.H.b=function(N,W,R){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16)>>>(W&7)&(1<<R)-1};H.H.Z=function(N,W){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16)>>>(W&7)};\\n      H.H.i=function(N,W){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16|N[(W>>>3)+3]<<24)>>>(W&7)};H.H.m=function(){var N=Uint16Array,W=Uint32Array;\\n        return{K:new N(16),j:new N(16),X:[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],S:[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],T:[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0],q:new N(32),p:[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,65535,65535],z:[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0],c:new W(32),J:new N(512),_:[],h:new N(32),$:[],w:new N(32768),C:[],v:[],d:new N(32768),D:[],u:new N(512),Q:[],r:new N(1<<15),s:new W(286),Y:new W(30),a:new W(19),t:new W(15e3),k:new N(1<<16),g:new N(1<<15)}}();\\n      (function(){var N=H.H.m,W=1<<15;for(var R=0;R<W;R++){var V=R;V=(V&2863311530)>>>1|(V&1431655765)<<1;\\n        V=(V&3435973836)>>>2|(V&858993459)<<2;V=(V&4042322160)>>>4|(V&252645135)<<4;V=(V&4278255360)>>>8|(V&16711935)<<8;\\n        N.r[R]=(V>>>16|V<<16)>>>17}function n(A,l,M){while(l--!=0)A.push(0,M)}for(var R=0;R<32;R++){N.q[R]=N.S[R]<<3|N.T[R];\\n        N.c[R]=N.p[R]<<4|N.z[R]}n(N._,144,8);n(N._,255-143,9);n(N._,279-255,7);n(N._,287-279,8);H.H.n(N._,9);\\n        H.H.A(N._,9,N.J);H.H.l(N._,9);n(N.$,32,5);H.H.n(N.$,5);H.H.A(N.$,5,N.h);H.H.l(N.$,5);n(N.Q,19,0);n(N.C,286,0);\\n        n(N.D,30,0);n(N.v,320,0)}());return H.H.N}()\\n    \\n    const UZIP = {}\\n    UZIP[\"parse\"] = ').concat(UZIP_1.parse, \"\\n    UZIP._readLocal = \").concat(UZIP_1._readLocal, \"\\n    UZIP.inflateRaw = \").concat(UZIP_1.inflateRaw, \"\\n    UZIP.inflate = \").concat(UZIP_1.inflate, \"\\n    UZIP.deflate = \").concat(UZIP_1.deflate, \"\\n    UZIP.deflateRaw = \").concat(UZIP_1.deflateRaw, \"\\n    UZIP.encode = \").concat(UZIP_1.encode, \"\\n    UZIP._noNeed = \").concat(UZIP_1._noNeed, \"\\n    UZIP._writeHeader = \").concat(UZIP_1._writeHeader, \"\\n    UZIP.crc = parse(\").concat(stringify(UZIP_1.crc), \")\\n    UZIP.crc.table = ( function() {\\n      var tab = new Uint32Array(256);\\n      for (var n=0; n<256; n++) {\\n        var c = n;\\n        for (var k=0; k<8; k++) {\\n          if (c & 1)  c = 0xedb88320 ^ (c >>> 1);\\n          else        c = c >>> 1;\\n        }\\n        tab[n] = c;  }\\n      return tab;  })()\\n    \\n    UZIP.adler = \").concat(UZIP_1.adler, \"\\n    UZIP.bin = parse(\").concat(stringify(UZIP_1.bin), \")\\n    UZIP.F = {}\\n    UZIP.F.deflateRaw = \").concat(UZIP_1.F.deflateRaw, \"\\n    UZIP.F._bestMatch = \").concat(UZIP_1.F._bestMatch, \"\\n    UZIP.F._howLong = \").concat(UZIP_1.F._howLong, \"\\n    UZIP.F._hash = \").concat(UZIP_1.F._hash, \"\\n    UZIP.saved = \").concat(UZIP_1.saved, \"\\n    UZIP.F._writeBlock = \").concat(UZIP_1.F._writeBlock, \"\\n    UZIP.F._copyExact = \").concat(UZIP_1.F._copyExact, \"\\n    UZIP.F.getTrees = \").concat(UZIP_1.F.getTrees, \"\\n    UZIP.F.getSecond = \").concat(UZIP_1.F.getSecond, \"\\n    UZIP.F.nonZero = \").concat(UZIP_1.F.nonZero, \"\\n    UZIP.F.contSize = \").concat(UZIP_1.F.contSize, \"\\n    UZIP.F._codeTiny = \").concat(UZIP_1.F._codeTiny, \" \\n    UZIP.F._lenCodes = \").concat(UZIP_1.F._lenCodes, \" \\n    UZIP.F._hufTree = \").concat(UZIP_1.F._hufTree, \" \\n    UZIP.F.setDepth = \").concat(UZIP_1.F.setDepth, \" \\n    UZIP.F.restrictDepth = \").concat(UZIP_1.F.restrictDepth, \"\\n    UZIP.F._goodIndex = \").concat(UZIP_1.F._goodIndex, \" \\n    UZIP.F._writeLit = \").concat(UZIP_1.F._writeLit, \" \\n    UZIP.F.inflate = \").concat(UZIP_1.F.inflate, \" \\n    UZIP.F._check = \").concat(UZIP_1.F._check, \" \\n    UZIP.F._decodeTiny = \").concat(UZIP_1.F._decodeTiny, \" \\n    UZIP.F._copyOut = \").concat(UZIP_1.F._copyOut, \" \\n    UZIP.F.makeCodes = \").concat(UZIP_1.F.makeCodes, \" \\n    UZIP.F.codes2map = \").concat(UZIP_1.F.codes2map, \" \\n    UZIP.F.revCodes = \").concat(UZIP_1.F.revCodes, \" \\n\\n    // used only in deflate\\n    UZIP.F._putsE = \").concat(UZIP_1.F._putsE, \"\\n    UZIP.F._putsF = \").concat(UZIP_1.F._putsF, \"\\n  \\n    UZIP.F._bitsE = \").concat(UZIP_1.F._bitsE, \"\\n    UZIP.F._bitsF = \").concat(UZIP_1.F._bitsF, \"\\n\\n    UZIP.F._get17 = \").concat(UZIP_1.F._get17, \"\\n    UZIP.F._get25 = \").concat(UZIP_1.F._get25, \"\\n    UZIP.F.U = function(){\\n      var u16=Uint16Array, u32=Uint32Array;\\n      return {\\n        next_code : new u16(16),\\n        bl_count  : new u16(16),\\n        ordr : [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ],\\n        of0  : [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],\\n        exb  : [0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0,  0,  0,  0],\\n        ldef : new u16(32),\\n        df0  : [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 65535, 65535],\\n        dxb  : [0,0,0,0,1,1,2, 2, 3, 3, 4, 4, 5, 5,  6,  6,  7,  7,  8,  8,   9,   9,  10,  10,  11,  11,  12,   12,   13,   13,     0,     0],\\n        ddef : new u32(32),\\n        flmap: new u16(  512),  fltree: [],\\n        fdmap: new u16(   32),  fdtree: [],\\n        lmap : new u16(32768),  ltree : [],  ttree:[],\\n        dmap : new u16(32768),  dtree : [],\\n        imap : new u16(  512),  itree : [],\\n        //rev9 : new u16(  512)\\n        rev15: new u16(1<<15),\\n        lhst : new u32(286), dhst : new u32( 30), ihst : new u32(19),\\n        lits : new u32(15000),\\n        strt : new u16(1<<16),\\n        prev : new u16(1<<15)\\n      };\\n    } ();\\n\\n    (function(){\\n      var U = UZIP.F.U;\\n      var len = 1<<15;\\n      for(var i=0; i<len; i++) {\\n        var x = i;\\n        x = (((x & 0xaaaaaaaa) >>> 1) | ((x & 0x55555555) << 1));\\n        x = (((x & 0xcccccccc) >>> 2) | ((x & 0x33333333) << 2));\\n        x = (((x & 0xf0f0f0f0) >>> 4) | ((x & 0x0f0f0f0f) << 4));\\n        x = (((x & 0xff00ff00) >>> 8) | ((x & 0x00ff00ff) << 8));\\n        U.rev15[i] = (((x >>> 16) | (x << 16)))>>>17;\\n      }\\n  \\n      function pushV(tgt, n, sv) {  while(n--!=0) tgt.push(0,sv);  }\\n  \\n      for(var i=0; i<32; i++) {  U.ldef[i]=(U.of0[i]<<3)|U.exb[i];  U.ddef[i]=(U.df0[i]<<4)|U.dxb[i];  }\\n  \\n      pushV(U.fltree, 144, 8);  pushV(U.fltree, 255-143, 9);  pushV(U.fltree, 279-255, 7);  pushV(U.fltree,287-279,8);\\n      /*\\n        var i = 0;\\n        for(; i<=143; i++) U.fltree.push(0,8);\\n        for(; i<=255; i++) U.fltree.push(0,9);\\n        for(; i<=279; i++) U.fltree.push(0,7);\\n        for(; i<=287; i++) U.fltree.push(0,8);\\n        */\\n      UZIP.F.makeCodes(U.fltree, 9);\\n      UZIP.F.codes2map(U.fltree, 9, U.flmap);\\n      UZIP.F.revCodes (U.fltree, 9)\\n  \\n      pushV(U.fdtree,32,5);\\n      //for(i=0;i<32; i++) U.fdtree.push(0,5);\\n      UZIP.F.makeCodes(U.fdtree, 5);\\n      UZIP.F.codes2map(U.fdtree, 5, U.fdmap);\\n      UZIP.F.revCodes (U.fdtree, 5)\\n  \\n      pushV(U.itree,19,0);  pushV(U.ltree,286,0);  pushV(U.dtree,30,0);  pushV(U.ttree,320,0);\\n      /*\\n        for(var i=0; i< 19; i++) U.itree.push(0,0);\\n        for(var i=0; i<286; i++) U.ltree.push(0,0);\\n        for(var i=0; i< 30; i++) U.dtree.push(0,0);\\n        for(var i=0; i<320; i++) U.ttree.push(0,0);\\n        */\\n    })()\\n    \"));\n}\n\nfunction generateWorkerScript() {\n  return createWorker(\"\\n    let scriptImported = false\\n    self.addEventListener('message', async (e) => {\\n      const { file, id, imageCompressionLibUrl, options } = e.data\\n      options.onProgress = (progress) => self.postMessage({ progress, id })\\n      try {\\n        if (!scriptImported) {\\n          // console.log('[worker] importScripts', imageCompressionLibUrl)\\n          self.importScripts(imageCompressionLibUrl)\\n          scriptImported = true\\n        }\\n        // console.log('[worker] self', self)\\n        const compressedFile = await imageCompression(file, options)\\n        self.postMessage({ file: compressedFile, id })\\n      } catch (e) {\\n        // console.error('[worker] error', e)\\n        self.postMessage({ error: e.message + '\\\\n' + e.stack, id })\\n      }\\n    })\\n  \");\n}\n\nfunction compressOnWebWorker(e, r) {\n  return new Promise(function (t, a) {\n    var i = cnt += 1;\n    imageCompressionLibUrl || (imageCompressionLibUrl = generateLib()), worker || (worker = generateWorkerScript()), worker.addEventListener(\"message\", function handler(e) {\n      if (e.data.id === i) {\n        if (r.signal && r.signal.aborted) return;\n        if (void 0 !== e.data.progress) return void r.onProgress(e.data.progress);\n        worker.removeEventListener(\"message\", handler), e.data.error && a(new Error(e.data.error)), t(e.data.file);\n      }\n    }), worker.addEventListener(\"error\", a), r.signal && r.signal.addEventListener(\"abort\", function () {\n      worker.terminate(), a(r.signal.reason);\n    }), worker.postMessage({\n      file: e,\n      id: i,\n      imageCompressionLibUrl: imageCompressionLibUrl,\n      options: _objectSpread2(_objectSpread2({}, r), {}, {\n        onProgress: void 0,\n        signal: void 0\n      })\n    });\n  });\n}\n\nfunction imageCompression(e, r) {\n  return new Promise(function (t, a) {\n    var i, s, c, f, l, u;\n    if (i = _objectSpread2({}, r), c = 0, f = i.onProgress, i.maxSizeMB = i.maxSizeMB || Number.POSITIVE_INFINITY, l = \"boolean\" != typeof i.useWebWorker || i.useWebWorker, delete i.useWebWorker, i.onProgress = function (e) {\n      c = e, \"function\" == typeof f && f(c);\n    }, !(e instanceof Blob || e instanceof CustomFile)) return a(new Error(\"The file given is not an instance of Blob or File\"));\n    if (!/^image/.test(e.type)) return a(new Error(\"The file given is not an image\"));\n    if (u = \"undefined\" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope, !l || \"function\" != typeof Worker || u) return compress(e, i).then(function (e) {\n      try {\n        return s = e, $If_3.call(this);\n      } catch (e) {\n        return a(e);\n      }\n    }.bind(this), a);\n\n    var d = function () {\n      try {\n        return $If_3.call(this);\n      } catch (e) {\n        return a(e);\n      }\n    }.bind(this),\n        h = function $Try_1_Catch(r) {\n      try {\n        return compress(e, i).then(function (e) {\n          try {\n            return s = e, d();\n          } catch (e) {\n            return a(e);\n          }\n        }, a);\n      } catch (e) {\n        return a(e);\n      }\n    };\n\n    try {\n      return compressOnWebWorker(e, i).then(function (e) {\n        try {\n          return s = e, d();\n        } catch (e) {\n          return h();\n        }\n      }, h);\n    } catch (e) {\n      h();\n    }\n\n    function $If_3() {\n      try {\n        s.name = e.name, s.lastModified = e.lastModified;\n      } catch (e) {}\n\n      return t(s);\n    }\n  });\n}\n\nimageCompression.getDataUrlFromFile = getDataUrlFromFile, imageCompression.getFilefromDataUrl = getFilefromDataUrl, imageCompression.loadImage = loadImage, imageCompression.drawImageInCanvas = drawImageInCanvas, imageCompression.drawFileInCanvas = drawFileInCanvas, imageCompression.canvasToFile = canvasToFile, imageCompression.getExifOrientation = getExifOrientation, imageCompression.handleMaxWidthOrHeight = handleMaxWidthOrHeight, imageCompression.followExifOrientation = followExifOrientation, imageCompression.cleanupCanvasMemory = cleanupCanvasMemory, imageCompression.isAutoOrientationInBrowser = isAutoOrientationInBrowser, imageCompression.approximateBelowMaximumCanvasSizeOfBrowser = approximateBelowMaximumCanvasSizeOfBrowser, imageCompression.getBrowserName = getBrowserName, imageCompression.version = \"2.0.0\";\nexport { imageCompression as default };","map":{"version":3,"mappings":"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","names":["u32","UZIP","e","eocd","data","t","rUi","i","a","u","onlyNames","out","rUs","r","d","nlen","buf","usize","length","adler","crc","Uint8Array","level","p","cpr","zpd","tot","o","A","_writeHeader","ioff","wUi","ext","fn","file","f","c","table","n","off","len","end","buff","writeUTF8","str","charCodeAt","code","s","_hash","_putsE","dlen","P","li","mch","lits","dst","dgi","lc","cvrd","m","g","U","ci","l","cl","j","F","pos","l0","BTYPE","o0","dtree","makeCodes","itree","si","C","x","_","p8","dset","b","tree","set","push","_hufTree","list","hl","hst","l2","maxl","MAXL","lit","bCost","dbt","arr","ch","ltree","noBuf","HLIT","HDIST","HCLEN","ML","MD","y","bitsE","ttree","mx1","dmap","ebs","h","_bitsE","_copyOut","bl_count","dt","next_code","ordr","of0","exb","ldef","df0","dxb","ddef","flmap","fltree","fdmap","fdtree","lmap","imap","rev15","lhst","dhst","ihst","strt","prev","sv","w","height","img","frames","fh","frm","dispose","bpp","bf32","buffer","ctype","depth","v","tRNS","ts","area","ti","ap","bf","cj","t0","I","qi","di","gr","R","tabs","al","tr","S","bin","UPNG","doff","num_frames","num_plays","del","offset","fd","readUint","type","text","keyw","readUTF8","pl","foff","bpl","interlace","CgBI","dd","_readInterlace","H","N","Z","W","D","X","M","Y","V","starting_row","row_increment","pass","cr","cc","row","starting_col","bpll","val","col","E","B","sh","_paeth","pa","pc","writeASCII","fb","ifa","tb","fr","fg","mode","fa","sb","ba","bufs","nimg","_main","wUs","wAs","dl","anim","leng","sRGB","pHYs","loop","cimg","imgd","nh","onlyBlend","inds","nbufs","cof","bln","K","ind","ilen","img32","Math","ceil","inj","gotAlpha","T","frms","nx","tlim","forbidPrev","it","pimg","Uint32Array","mix","evenCrd","sarea","miY","r0","miX","_updateFrame","rect","width","U8","pimg32","cx","miy","blend","rec","ftry","filter","opts","paeth","k","update","oimg","nimg32","KD","root","nd","abuf","err","i0","maxL","splitPixels","i1","node","left","planeDst","ln","rn","getNearest","q","d0","d1","d2","stats","m0","Rj","m1","iN","m3","Cov","M4","sml","noff","CHROME","FIREFOX","DESKTOP_SAFARI","IE","MOBILE_SAFARI","ETC","_BROWSER_NAME$CHROME$","MAX_CANVAS_SIZE","isBrowser","window","cordova","CustomFileReader","resolve","reader","result","readAsDataURL","Image","browserName","BROWSER_NAME","approximateBelowMaximumCanvasSizeOfBrowser","maximumCanvasSize","drawImageInCanvas","includes","navigator","isIOS","canvas","png","encode","name","$If_4","quality","fileLastModified","then","$await_11","testImageCanvas","$await_13","cachedResult","view","little","maxWidthOrHeight","getExifOrientation","maxSizeByte","cnt","worker","script","blobArgs","Worker","value","createSourceObject","parse","Number","imageCompression"],"sources":["/home/qhuy/Vscode/chat-app-react-nodejs/public/node_modules/browser-image-compression/node_modules/uzip/UZIP.js","/home/qhuy/Vscode/chat-app-react-nodejs/public/node_modules/browser-image-compression/lib/UPNG.js","/home/qhuy/Vscode/chat-app-react-nodejs/public/node_modules/browser-image-compression/lib/config/browser-name.js","/home/qhuy/Vscode/chat-app-react-nodejs/public/node_modules/browser-image-compression/lib/utils.js","/home/qhuy/Vscode/chat-app-react-nodejs/public/node_modules/browser-image-compression/lib/image-compression.js","/home/qhuy/Vscode/chat-app-react-nodejs/public/node_modules/browser-image-compression/lib/web-worker.js","/home/qhuy/Vscode/chat-app-react-nodejs/public/node_modules/browser-image-compression/lib/index.js"],"sourcesContent":["\r\n\r\nvar UZIP = {};\r\nif(typeof module == \"object\") module.exports = UZIP;\r\n\r\n\r\nUZIP[\"parse\"] = function(buf, onlyNames)\t// ArrayBuffer\r\n{\r\n\tvar rUs = UZIP.bin.readUshort, rUi = UZIP.bin.readUint, o = 0, out = {};\r\n\tvar data = new Uint8Array(buf);\r\n\tvar eocd = data.length-4;\r\n\t\r\n\twhile(rUi(data, eocd)!=0x06054b50) eocd--;\r\n\t\r\n\tvar o = eocd;\r\n\to+=4;\t// sign  = 0x06054b50\r\n\to+=4;  // disks = 0;\r\n\tvar cnu = rUs(data, o);  o+=2;\r\n\tvar cnt = rUs(data, o);  o+=2;\r\n\t\t\t\r\n\tvar csize = rUi(data, o);  o+=4;\r\n\tvar coffs = rUi(data, o);  o+=4;\r\n\t\r\n\to = coffs;\r\n\tfor(var i=0; i<cnu; i++)\r\n\t{\r\n\t\tvar sign = rUi(data, o);  o+=4;\r\n\t\to += 4;  // versions;\r\n\t\to += 4;  // flag + compr\r\n\t\to += 4;  // time\r\n\t\t\r\n\t\tvar crc32 = rUi(data, o);  o+=4;\r\n\t\tvar csize = rUi(data, o);  o+=4;\r\n\t\tvar usize = rUi(data, o);  o+=4;\r\n\t\t\r\n\t\tvar nl = rUs(data, o), el = rUs(data, o+2), cl = rUs(data, o+4);  o += 6;  // name, extra, comment\r\n\t\to += 8;  // disk, attribs\r\n\t\t\r\n\t\tvar roff = rUi(data, o);  o+=4;\r\n\t\to += nl + el + cl;\r\n\t\t\r\n\t\tUZIP._readLocal(data, roff, out, csize, usize, onlyNames);\r\n\t}\r\n\t//console.log(out);\r\n\treturn out;\r\n}\r\n\r\nUZIP._readLocal = function(data, o, out, csize, usize, onlyNames)\r\n{\r\n\tvar rUs = UZIP.bin.readUshort, rUi = UZIP.bin.readUint;\r\n\tvar sign  = rUi(data, o);  o+=4;\r\n\tvar ver   = rUs(data, o);  o+=2;\r\n\tvar gpflg = rUs(data, o);  o+=2;\r\n\t//if((gpflg&8)!=0) throw \"unknown sizes\";\r\n\tvar cmpr  = rUs(data, o);  o+=2;\r\n\t\r\n\tvar time  = rUi(data, o);  o+=4;\r\n\t\r\n\tvar crc32 = rUi(data, o);  o+=4;\r\n\t//var csize = rUi(data, o);  o+=4;\r\n\t//var usize = rUi(data, o);  o+=4;\r\n\to+=8;\r\n\t\t\r\n\tvar nlen  = rUs(data, o);  o+=2;\r\n\tvar elen  = rUs(data, o);  o+=2;\r\n\t\t\r\n\tvar name =  UZIP.bin.readUTF8(data, o, nlen);  o+=nlen;  //console.log(name);\r\n\to += elen;\r\n\t\t\t\r\n\t//console.log(sign.toString(16), ver, gpflg, cmpr, crc32.toString(16), \"csize, usize\", csize, usize, nlen, elen, name, o);\r\n\tif(onlyNames) {  out[name]={size:usize, csize:csize};  return;  }   \r\n\tvar file = new Uint8Array(data.buffer, o);\r\n\tif(false) {}\r\n\telse if(cmpr==0) out[name] = new Uint8Array(file.buffer.slice(o, o+csize));\r\n\telse if(cmpr==8) {\r\n\t\tvar buf = new Uint8Array(usize);  UZIP.inflateRaw(file, buf);\r\n\t\t/*var nbuf = pako[\"inflateRaw\"](file);\r\n\t\tif(usize>8514000) {\r\n\t\t\t//console.log(PUtils.readASCII(buf , 8514500, 500));\r\n\t\t\t//console.log(PUtils.readASCII(nbuf, 8514500, 500));\r\n\t\t}\r\n\t\tfor(var i=0; i<buf.length; i++) if(buf[i]!=nbuf[i]) {  console.log(buf.length, nbuf.length, usize, i);  throw \"e\";  }\r\n\t\t*/\r\n\t\tout[name] = buf;\r\n\t}\r\n\telse throw \"unknown compression method: \"+cmpr;\r\n}\r\n\r\nUZIP.inflateRaw = function(file, buf) {  return UZIP.F.inflate(file, buf);  }\r\nUZIP.inflate    = function(file, buf) { \r\n\tvar CMF = file[0], FLG = file[1];\r\n\tvar CM = (CMF&15), CINFO = (CMF>>>4);\r\n\t//console.log(CM, CINFO,CMF,FLG);\r\n\treturn UZIP.inflateRaw(new Uint8Array(file.buffer, file.byteOffset+2, file.length-6), buf);  \r\n}\r\nUZIP.deflate    = function(data, opts/*, buf, off*/) {\r\n\tif(opts==null) opts={level:6};\r\n\tvar off=0, buf=new Uint8Array(50+Math.floor(data.length*1.1));\r\n\tbuf[off]=120;  buf[off+1]=156;  off+=2;\r\n\toff = UZIP.F.deflateRaw(data, buf, off, opts.level);\r\n\tvar crc = UZIP.adler(data, 0, data.length);\r\n\tbuf[off+0]=((crc>>>24)&255); \r\n\tbuf[off+1]=((crc>>>16)&255); \r\n\tbuf[off+2]=((crc>>> 8)&255); \r\n\tbuf[off+3]=((crc>>> 0)&255); \t\r\n\treturn new Uint8Array(buf.buffer, 0, off+4);\r\n}\r\nUZIP.deflateRaw = function(data, opts) {\r\n\tif(opts==null) opts={level:6};\r\n\tvar buf=new Uint8Array(50+Math.floor(data.length*1.1));\r\n\tvar off = UZIP.F.deflateRaw(data, buf, off, opts.level);\r\n\treturn new Uint8Array(buf.buffer, 0, off);\r\n}\r\n\r\n\r\nUZIP.encode = function(obj, noCmpr) {\r\n\tif(noCmpr==null) noCmpr=false;\r\n\tvar tot = 0, wUi = UZIP.bin.writeUint, wUs = UZIP.bin.writeUshort;\r\n\tvar zpd = {};\r\n\tfor(var p in obj) {  var cpr = !UZIP._noNeed(p) && !noCmpr, buf = obj[p], crc = UZIP.crc.crc(buf,0,buf.length); \r\n\t\tzpd[p] = {  cpr:cpr, usize:buf.length, crc:crc, file: (cpr ? UZIP.deflateRaw(buf) : buf)  };  }\r\n\t\r\n\tfor(var p in zpd) tot += zpd[p].file.length + 30 + 46 + 2*UZIP.bin.sizeUTF8(p);\r\n\ttot +=  22;\r\n\t\r\n\tvar data = new Uint8Array(tot), o = 0;\r\n\tvar fof = []\r\n\t\r\n\tfor(var p in zpd) {\r\n\t\tvar file = zpd[p];  fof.push(o);\r\n\t\to = UZIP._writeHeader(data, o, p, file, 0);\r\n\t}\r\n\tvar i=0, ioff = o;\r\n\tfor(var p in zpd) {\r\n\t\tvar file = zpd[p];  fof.push(o);\r\n\t\to = UZIP._writeHeader(data, o, p, file, 1, fof[i++]);\t\t\r\n\t}\r\n\tvar csize = o-ioff;\r\n\t\r\n\twUi(data, o, 0x06054b50);  o+=4;\r\n\to += 4;  // disks\r\n\twUs(data, o, i);  o += 2;\r\n\twUs(data, o, i);  o += 2;\t// number of c d records\r\n\twUi(data, o, csize);  o += 4;\r\n\twUi(data, o, ioff );  o += 4;\r\n\to += 2;\r\n\treturn data.buffer;\r\n}\r\n// no need to compress .PNG, .ZIP, .JPEG ....\r\nUZIP._noNeed = function(fn) {  var ext = fn.split(\".\").pop().toLowerCase();  return \"png,jpg,jpeg,zip\".indexOf(ext)!=-1;  }\r\n\r\nUZIP._writeHeader = function(data, o, p, obj, t, roff)\r\n{\r\n\tvar wUi = UZIP.bin.writeUint, wUs = UZIP.bin.writeUshort;\r\n\tvar file = obj.file;\r\n\t\r\n\twUi(data, o, t==0 ? 0x04034b50 : 0x02014b50);  o+=4; // sign\r\n\tif(t==1) o+=2;  // ver made by\r\n\twUs(data, o, 20);  o+=2;\t// ver\r\n\twUs(data, o,  0);  o+=2;    // gflip\r\n\twUs(data, o,  obj.cpr?8:0);  o+=2;\t// cmpr\r\n\t\t\r\n\twUi(data, o,  0);  o+=4;\t// time\t\t\r\n\twUi(data, o, obj.crc);  o+=4;\t// crc32\r\n\twUi(data, o, file.length);  o+=4;\t// csize\r\n\twUi(data, o, obj.usize);  o+=4;\t// usize\r\n\t\t\r\n\twUs(data, o, UZIP.bin.sizeUTF8(p));  o+=2;\t// nlen\r\n\twUs(data, o, 0);  o+=2;\t// elen\r\n\t\r\n\tif(t==1) {\r\n\t\to += 2;  // comment length\r\n\t\to += 2;  // disk number\r\n\t\to += 6;  // attributes\r\n\t\twUi(data, o, roff);  o+=4;\t// usize\r\n\t}\r\n\tvar nlen = UZIP.bin.writeUTF8(data, o, p);  o+= nlen;\t\r\n\tif(t==0) {  data.set(file, o);  o += file.length;  }\r\n\treturn o;\r\n}\r\n\r\n\r\n\r\n\r\n\r\nUZIP.crc = {\r\n\ttable : ( function() {\r\n\t   var tab = new Uint32Array(256);\r\n\t   for (var n=0; n<256; n++) {\r\n\t\t\tvar c = n;\r\n\t\t\tfor (var k=0; k<8; k++) {\r\n\t\t\t\tif (c & 1)  c = 0xedb88320 ^ (c >>> 1);\r\n\t\t\t\telse        c = c >>> 1;\r\n\t\t\t}\r\n\t\t\ttab[n] = c;  }    \r\n\t\treturn tab;  })(),\r\n\tupdate : function(c, buf, off, len) {\r\n\t\tfor (var i=0; i<len; i++)  c = UZIP.crc.table[(c ^ buf[off+i]) & 0xff] ^ (c >>> 8);\r\n\t\treturn c;\r\n\t},\r\n\tcrc : function(b,o,l)  {  return UZIP.crc.update(0xffffffff,b,o,l) ^ 0xffffffff;  }\r\n}\r\nUZIP.adler = function(data,o,len) {\r\n\tvar a = 1, b = 0;\r\n\tvar off = o, end=o+len;\r\n\twhile(off<end) {\r\n\t\tvar eend = Math.min(off+5552, end);\r\n\t\twhile(off<eend) {\r\n\t\t\ta += data[off++];\r\n\t\t\tb += a;\r\n\t\t}\r\n\t\ta=a%65521;\r\n\t\tb=b%65521;\r\n\t}\r\n    return (b << 16) | a;\r\n}\r\n\r\nUZIP.bin = {\r\n\treadUshort : function(buff,p)  {  return (buff[p]) | (buff[p+1]<<8);  },\r\n\twriteUshort: function(buff,p,n){  buff[p] = (n)&255;  buff[p+1] = (n>>8)&255;  },\r\n\treadUint   : function(buff,p)  {  return (buff[p+3]*(256*256*256)) + ((buff[p+2]<<16) | (buff[p+1]<< 8) | buff[p]);  },\r\n\twriteUint  : function(buff,p,n){  buff[p]=n&255;  buff[p+1]=(n>>8)&255;  buff[p+2]=(n>>16)&255;  buff[p+3]=(n>>24)&255;  },\r\n\treadASCII  : function(buff,p,l){  var s = \"\";  for(var i=0; i<l; i++) s += String.fromCharCode(buff[p+i]);  return s;    },\r\n\twriteASCII : function(data,p,s){  for(var i=0; i<s.length; i++) data[p+i] = s.charCodeAt(i);  },\r\n\tpad : function(n) { return n.length < 2 ? \"0\" + n : n; },\r\n\treadUTF8 : function(buff, p, l) {\r\n\t\tvar s = \"\", ns;\r\n\t\tfor(var i=0; i<l; i++) s += \"%\" + UZIP.bin.pad(buff[p+i].toString(16));\r\n\t\ttry {  ns = decodeURIComponent(s); }\r\n\t\tcatch(e) {  return UZIP.bin.readASCII(buff, p, l);  }\r\n\t\treturn  ns;\r\n\t},\r\n\twriteUTF8 : function(buff, p, str) {\r\n\t\tvar strl = str.length, i=0;\r\n\t\tfor(var ci=0; ci<strl; ci++)\r\n\t\t{\r\n\t\t\tvar code = str.charCodeAt(ci);\r\n\t\t\tif     ((code&(0xffffffff-(1<< 7)+1))==0) {  buff[p+i] = (     code     );  i++;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<11)+1))==0) {  buff[p+i] = (192|(code>> 6));  buff[p+i+1] = (128|((code>> 0)&63));  i+=2;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<16)+1))==0) {  buff[p+i] = (224|(code>>12));  buff[p+i+1] = (128|((code>> 6)&63));  buff[p+i+2] = (128|((code>>0)&63));  i+=3;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<21)+1))==0) {  buff[p+i] = (240|(code>>18));  buff[p+i+1] = (128|((code>>12)&63));  buff[p+i+2] = (128|((code>>6)&63));  buff[p+i+3] = (128|((code>>0)&63)); i+=4;  }\r\n\t\t\telse throw \"e\";\r\n\t\t}\r\n\t\treturn i;\r\n\t},\r\n\tsizeUTF8 : function(str) {\r\n\t\tvar strl = str.length, i=0;\r\n\t\tfor(var ci=0; ci<strl; ci++)\r\n\t\t{\r\n\t\t\tvar code = str.charCodeAt(ci);\r\n\t\t\tif     ((code&(0xffffffff-(1<< 7)+1))==0) {  i++ ;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<11)+1))==0) {  i+=2;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<16)+1))==0) {  i+=3;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<21)+1))==0) {  i+=4;  }\r\n\t\t\telse throw \"e\";\r\n\t\t}\r\n\t\treturn i;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\nUZIP.F = {};\r\n\r\nUZIP.F.deflateRaw = function(data, out, opos, lvl) {\t\r\n\tvar opts = [\r\n\t/*\r\n\t\t ush good_length; /* reduce lazy search above this match length \r\n\t\t ush max_lazy;    /* do not perform lazy search above this match length \r\n         ush nice_length; /* quit search above this match length \r\n\t*/\r\n\t/*      good lazy nice chain */\r\n\t/* 0 */ [ 0,   0,   0,    0,0],  /* store only */\r\n\t/* 1 */ [ 4,   4,   8,    4,0], /* max speed, no lazy matches */\r\n\t/* 2 */ [ 4,   5,  16,    8,0],\r\n\t/* 3 */ [ 4,   6,  16,   16,0],\r\n\r\n\t/* 4 */ [ 4,  10,  16,   32,0],  /* lazy matches */\r\n\t/* 5 */ [ 8,  16,  32,   32,0],\r\n\t/* 6 */ [ 8,  16, 128,  128,0],\r\n\t/* 7 */ [ 8,  32, 128,  256,0],\r\n\t/* 8 */ [32, 128, 258, 1024,1],\r\n\t/* 9 */ [32, 258, 258, 4096,1]]; /* max compression */\r\n\t\r\n\tvar opt = opts[lvl];\r\n\t\r\n\t\r\n\tvar U = UZIP.F.U, goodIndex = UZIP.F._goodIndex, hash = UZIP.F._hash, putsE = UZIP.F._putsE;\r\n\tvar i = 0, pos = opos<<3, cvrd = 0, dlen = data.length;\r\n\t\r\n\tif(lvl==0) {\r\n\t\twhile(i<dlen) {   var len = Math.min(0xffff, dlen-i);\r\n\t\t\tputsE(out, pos, (i+len==dlen ? 1 : 0));  pos = UZIP.F._copyExact(data, i, len, out, pos+8);  i += len;  }\r\n\t\treturn pos>>>3;\r\n\t}\r\n\r\n\tvar lits = U.lits, strt=U.strt, prev=U.prev, li=0, lc=0, bs=0, ebits=0, c=0, nc=0;  // last_item, literal_count, block_start\r\n\tif(dlen>2) {  nc=UZIP.F._hash(data,0);  strt[nc]=0;  }\r\n\tvar nmch=0,nmci=0;\r\n\t\r\n\tfor(i=0; i<dlen; i++)  {\r\n\t\tc = nc;\r\n\t\t//*\r\n\t\tif(i+1<dlen-2) {\r\n\t\t\tnc = UZIP.F._hash(data, i+1);\r\n\t\t\tvar ii = ((i+1)&0x7fff);\r\n\t\t\tprev[ii]=strt[nc];\r\n\t\t\tstrt[nc]=ii;\r\n\t\t} //*/\r\n\t\tif(cvrd<=i) {\r\n\t\t\tif((li>14000 || lc>26697) && (dlen-i)>100) {\r\n\t\t\t\tif(cvrd<i) {  lits[li]=i-cvrd;  li+=2;  cvrd=i;  }\r\n\t\t\t\tpos = UZIP.F._writeBlock(((i==dlen-1) || (cvrd==dlen))?1:0, lits, li, ebits, data,bs,i-bs, out, pos);  li=lc=ebits=0;  bs=i;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar mch = 0;\r\n\t\t\t//if(nmci==i) mch= nmch;  else \r\n\t\t\tif(i<dlen-2) mch = UZIP.F._bestMatch(data, i, prev, c, Math.min(opt[2],dlen-i), opt[3]);\r\n\t\t\t/*\r\n\t\t\tif(mch!=0 && opt[4]==1 && (mch>>>16)<opt[1] && i+1<dlen-2) {\r\n\t\t\t\tnmch = UZIP.F._bestMatch(data, i+1, prev, nc, opt[2], opt[3]);  nmci=i+1;\r\n\t\t\t\t//var mch2 = UZIP.F._bestMatch(data, i+2, prev, nnc);  //nmci=i+1;\r\n\t\t\t\tif((nmch>>>16)>(mch>>>16)) mch=0;\r\n\t\t\t}//*/\r\n\t\t\tvar len = mch>>>16, dst = mch&0xffff;  //if(i-dst<0) throw \"e\";\r\n\t\t\tif(mch!=0) { \r\n\t\t\t\tvar len = mch>>>16, dst = mch&0xffff;  //if(i-dst<0) throw \"e\";\r\n\t\t\t\tvar lgi = goodIndex(len, U.of0);  U.lhst[257+lgi]++; \r\n\t\t\t\tvar dgi = goodIndex(dst, U.df0);  U.dhst[    dgi]++;  ebits += U.exb[lgi] + U.dxb[dgi]; \r\n\t\t\t\tlits[li] = (len<<23)|(i-cvrd);  lits[li+1] = (dst<<16)|(lgi<<8)|dgi;  li+=2;\r\n\t\t\t\tcvrd = i + len;  \r\n\t\t\t}\r\n\t\t\telse {\tU.lhst[data[i]]++;  }\r\n\t\t\tlc++;\r\n\t\t}\r\n\t}\r\n\tif(bs!=i || data.length==0) {\r\n\t\tif(cvrd<i) {  lits[li]=i-cvrd;  li+=2;  cvrd=i;  }\r\n\t\tpos = UZIP.F._writeBlock(1, lits, li, ebits, data,bs,i-bs, out, pos);  li=0;  lc=0;  li=lc=ebits=0;  bs=i;\r\n\t}\r\n\twhile((pos&7)!=0) pos++;\r\n\treturn pos>>>3;\r\n}\r\nUZIP.F._bestMatch = function(data, i, prev, c, nice, chain) {\r\n\tvar ci = (i&0x7fff), pi=prev[ci];  \r\n\t//console.log(\"----\", i);\r\n\tvar dif = ((ci-pi + (1<<15)) & 0x7fff);  if(pi==ci || c!=UZIP.F._hash(data,i-dif)) return 0;\r\n\tvar tl=0, td=0;  // top length, top distance\r\n\tvar dlim = Math.min(0x7fff, i);\r\n\twhile(dif<=dlim && --chain!=0 && pi!=ci /*&& c==UZIP.F._hash(data,i-dif)*/) {\r\n\t\tif(tl==0 || (data[i+tl]==data[i+tl-dif])) {\r\n\t\t\tvar cl = UZIP.F._howLong(data, i, dif);\r\n\t\t\tif(cl>tl) {  \r\n\t\t\t\ttl=cl;  td=dif;  if(tl>=nice) break;    //* \r\n\t\t\t\tif(dif+2<cl) cl = dif+2;\r\n\t\t\t\tvar maxd = 0; // pi does not point to the start of the word\r\n\t\t\t\tfor(var j=0; j<cl-2; j++) {\r\n\t\t\t\t\tvar ei =  (i-dif+j+ (1<<15)) & 0x7fff;\r\n\t\t\t\t\tvar li = prev[ei];\r\n\t\t\t\t\tvar curd = (ei-li + (1<<15)) & 0x7fff;\r\n\t\t\t\t\tif(curd>maxd) {  maxd=curd;  pi = ei; }\r\n\t\t\t\t}  //*/\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tci=pi;  pi = prev[ci];\r\n\t\tdif += ((ci-pi + (1<<15)) & 0x7fff);\r\n\t}\r\n\treturn (tl<<16)|td;\r\n}\r\nUZIP.F._howLong = function(data, i, dif) {\r\n\tif(data[i]!=data[i-dif] || data[i+1]!=data[i+1-dif] || data[i+2]!=data[i+2-dif]) return 0;\r\n\tvar oi=i, l = Math.min(data.length, i+258);  i+=3;\r\n\t//while(i+4<l && data[i]==data[i-dif] && data[i+1]==data[i+1-dif] && data[i+2]==data[i+2-dif] && data[i+3]==data[i+3-dif]) i+=4;\r\n\twhile(i<l && data[i]==data[i-dif]) i++;\r\n\treturn i-oi;\r\n}\r\nUZIP.F._hash = function(data, i) {\r\n\treturn (((data[i]<<8) | data[i+1])+(data[i+2]<<4))&0xffff;\r\n\t//var hash_shift = 0, hash_mask = 255;\r\n\t//var h = data[i+1] % 251;\r\n\t//h = (((h << 8) + data[i+2]) % 251);\r\n\t//h = (((h << 8) + data[i+2]) % 251);\r\n\t//h = ((h<<hash_shift) ^ (c) ) & hash_mask;\r\n\t//return h | (data[i]<<8);\r\n\t//return (data[i] | (data[i+1]<<8));\r\n}\r\n//UZIP.___toth = 0;\r\nUZIP.saved = 0;\r\nUZIP.F._writeBlock = function(BFINAL, lits, li, ebits, data,o0,l0, out, pos) {\r\n\tvar U = UZIP.F.U, putsF = UZIP.F._putsF, putsE = UZIP.F._putsE;\r\n\t\r\n\t//*\r\n\tvar T, ML, MD, MH, numl, numd, numh, lset, dset;  U.lhst[256]++;\r\n\tT = UZIP.F.getTrees(); ML=T[0]; MD=T[1]; MH=T[2]; numl=T[3]; numd=T[4]; numh=T[5]; lset=T[6]; dset=T[7];\r\n\t\r\n\tvar cstSize = (((pos+3)&7)==0 ? 0 : 8-((pos+3)&7)) + 32 + (l0<<3);\r\n\tvar fxdSize = ebits + UZIP.F.contSize(U.fltree, U.lhst) + UZIP.F.contSize(U.fdtree, U.dhst);\r\n\tvar dynSize = ebits + UZIP.F.contSize(U.ltree , U.lhst) + UZIP.F.contSize(U.dtree , U.dhst);\r\n\tdynSize    += 14 + 3*numh + UZIP.F.contSize(U.itree, U.ihst) + (U.ihst[16]*2 + U.ihst[17]*3 + U.ihst[18]*7);\r\n\t\r\n\tfor(var j=0; j<286; j++) U.lhst[j]=0;   for(var j=0; j<30; j++) U.dhst[j]=0;   for(var j=0; j<19; j++) U.ihst[j]=0;\r\n\t//*/\r\n\tvar BTYPE = (cstSize<fxdSize && cstSize<dynSize) ? 0 : ( fxdSize<dynSize ? 1 : 2 );\r\n\tputsF(out, pos, BFINAL);  putsF(out, pos+1, BTYPE);  pos+=3;\r\n\t\r\n\tvar opos = pos;\r\n\tif(BTYPE==0) {\r\n\t\twhile((pos&7)!=0) pos++;\r\n\t\tpos = UZIP.F._copyExact(data, o0, l0, out, pos);\r\n\t}\r\n\telse {\r\n\t\tvar ltree, dtree;\r\n\t\tif(BTYPE==1) {  ltree=U.fltree;  dtree=U.fdtree;  }\r\n\t\tif(BTYPE==2) {\t\r\n\t\t\tUZIP.F.makeCodes(U.ltree, ML);  UZIP.F.revCodes(U.ltree, ML);\r\n\t\t\tUZIP.F.makeCodes(U.dtree, MD);  UZIP.F.revCodes(U.dtree, MD);\r\n\t\t\tUZIP.F.makeCodes(U.itree, MH);  UZIP.F.revCodes(U.itree, MH);\r\n\t\t\t\r\n\t\t\tltree = U.ltree;  dtree = U.dtree;\r\n\t\t\t\r\n\t\t\tputsE(out, pos,numl-257);  pos+=5;  // 286\r\n\t\t\tputsE(out, pos,numd-  1);  pos+=5;  // 30\r\n\t\t\tputsE(out, pos,numh-  4);  pos+=4;  // 19\r\n\t\t\t\r\n\t\t\tfor(var i=0; i<numh; i++) putsE(out, pos+i*3, U.itree[(U.ordr[i]<<1)+1]);   pos+=3* numh;\r\n\t\t\tpos = UZIP.F._codeTiny(lset, U.itree, out, pos);\r\n\t\t\tpos = UZIP.F._codeTiny(dset, U.itree, out, pos);\r\n\t\t}\r\n\t\t\r\n\t\tvar off=o0;\r\n\t\tfor(var si=0; si<li; si+=2) {\r\n\t\t\tvar qb=lits[si], len=(qb>>>23), end = off+(qb&((1<<23)-1));\r\n\t\t\twhile(off<end) pos = UZIP.F._writeLit(data[off++], ltree, out, pos);\r\n\t\t\t\r\n\t\t\tif(len!=0) {\r\n\t\t\t\tvar qc = lits[si+1], dst=(qc>>16), lgi=(qc>>8)&255, dgi=(qc&255);\r\n\t\t\t\tpos = UZIP.F._writeLit(257+lgi, ltree, out, pos);\r\n\t\t\t\tputsE(out, pos, len-U.of0[lgi]);  pos+=U.exb[lgi];\r\n\t\t\t\t\r\n\t\t\t\tpos = UZIP.F._writeLit(dgi, dtree, out, pos);\r\n\t\t\t\tputsF(out, pos, dst-U.df0[dgi]);  pos+=U.dxb[dgi];  off+=len;\r\n\t\t\t}\r\n\t\t}\r\n\t\tpos = UZIP.F._writeLit(256, ltree, out, pos);\r\n\t}\r\n\t//console.log(pos-opos, fxdSize, dynSize, cstSize);\r\n\treturn pos;\r\n}\r\nUZIP.F._copyExact = function(data,off,len,out,pos) {\r\n\tvar p8 = (pos>>>3);\r\n\tout[p8]=(len);  out[p8+1]=(len>>>8);  out[p8+2]=255-out[p8];  out[p8+3]=255-out[p8+1];  p8+=4;\r\n\tout.set(new Uint8Array(data.buffer, off, len), p8);\r\n\t//for(var i=0; i<len; i++) out[p8+i]=data[off+i];\r\n\treturn pos + ((len+4)<<3);\r\n}\r\n/*\r\n\tInteresting facts:\r\n\t- decompressed block can have bytes, which do not occur in a Huffman tree (copied from the previous block by reference)\r\n*/\r\n\r\nUZIP.F.getTrees = function() {\r\n\tvar U = UZIP.F.U;\r\n\tvar ML = UZIP.F._hufTree(U.lhst, U.ltree, 15);\r\n\tvar MD = UZIP.F._hufTree(U.dhst, U.dtree, 15);\r\n\tvar lset = [], numl = UZIP.F._lenCodes(U.ltree, lset);\r\n\tvar dset = [], numd = UZIP.F._lenCodes(U.dtree, dset);\r\n\tfor(var i=0; i<lset.length; i+=2) U.ihst[lset[i]]++;\r\n\tfor(var i=0; i<dset.length; i+=2) U.ihst[dset[i]]++;\r\n\tvar MH = UZIP.F._hufTree(U.ihst, U.itree,  7);\r\n\tvar numh = 19;  while(numh>4 && U.itree[(U.ordr[numh-1]<<1)+1]==0) numh--;\r\n\treturn [ML, MD, MH, numl, numd, numh, lset, dset];\r\n}\r\nUZIP.F.getSecond= function(a) {  var b=[];  for(var i=0; i<a.length; i+=2) b.push  (a[i+1]);  return b;  }\r\nUZIP.F.nonZero  = function(a) {  var b= \"\";  for(var i=0; i<a.length; i+=2) if(a[i+1]!=0)b+=(i>>1)+\",\";  return b;  }\r\nUZIP.F.contSize = function(tree, hst) {  var s=0;  for(var i=0; i<hst.length; i++) s+= hst[i]*tree[(i<<1)+1];  return s;  }\r\nUZIP.F._codeTiny = function(set, tree, out, pos) {\r\n\tfor(var i=0; i<set.length; i+=2) {\r\n\t\tvar l = set[i], rst = set[i+1];  //console.log(l, pos, tree[(l<<1)+1]);\r\n\t\tpos = UZIP.F._writeLit(l, tree, out, pos);\r\n\t\tvar rsl = l==16 ? 2 : (l==17 ? 3 : 7);\r\n\t\tif(l>15) {  UZIP.F._putsE(out, pos, rst, rsl);  pos+=rsl;  }\r\n\t}\r\n\treturn pos;\r\n}\r\nUZIP.F._lenCodes = function(tree, set) {\r\n\tvar len=tree.length;  while(len!=2 && tree[len-1]==0) len-=2;  // when no distances, keep one code with length 0\r\n\tfor(var i=0; i<len; i+=2) {\r\n\t\tvar l = tree[i+1], nxt = (i+3<len ? tree[i+3]:-1),  nnxt = (i+5<len ? tree[i+5]:-1),  prv = (i==0 ? -1 : tree[i-1]);\r\n\t\tif(l==0 && nxt==l && nnxt==l) {\r\n\t\t\tvar lz = i+5;\r\n\t\t\twhile(lz+2<len && tree[lz+2]==l) lz+=2;\r\n\t\t\tvar zc = Math.min((lz+1-i)>>>1, 138);\r\n\t\t\tif(zc<11) set.push(17, zc-3);\r\n\t\t\telse set.push(18, zc-11);\r\n\t\t\ti += zc*2-2;\r\n\t\t}\r\n\t\telse if(l==prv && nxt==l && nnxt==l) {\r\n\t\t\tvar lz = i+5;\r\n\t\t\twhile(lz+2<len && tree[lz+2]==l) lz+=2;\r\n\t\t\tvar zc = Math.min((lz+1-i)>>>1, 6);\r\n\t\t\tset.push(16, zc-3);\r\n\t\t\ti += zc*2-2;\r\n\t\t}\r\n\t\telse set.push(l, 0);\r\n\t}\r\n\treturn len>>>1;\r\n}\r\nUZIP.F._hufTree   = function(hst, tree, MAXL) {\r\n\tvar list=[], hl = hst.length, tl=tree.length, i=0;\r\n\tfor(i=0; i<tl; i+=2) {  tree[i]=0;  tree[i+1]=0;  }\t\r\n\tfor(i=0; i<hl; i++) if(hst[i]!=0) list.push({lit:i, f:hst[i]});\r\n\tvar end = list.length, l2=list.slice(0);\r\n\tif(end==0) return 0;  // empty histogram (usually for dist)\r\n\tif(end==1) {  var lit=list[0].lit, l2=lit==0?1:0;  tree[(lit<<1)+1]=1;  tree[(l2<<1)+1]=1;  return 1;  }\r\n\tlist.sort(function(a,b){return a.f-b.f;});\r\n\tvar a=list[0], b=list[1], i0=0, i1=1, i2=2;  list[0]={lit:-1,f:a.f+b.f,l:a,r:b,d:0};\r\n\twhile(i1!=end-1) {\r\n\t\tif(i0!=i1 && (i2==end || list[i0].f<list[i2].f)) {  a=list[i0++];  }  else {  a=list[i2++];  }\r\n\t\tif(i0!=i1 && (i2==end || list[i0].f<list[i2].f)) {  b=list[i0++];  }  else {  b=list[i2++];  }\r\n\t\tlist[i1++]={lit:-1,f:a.f+b.f, l:a,r:b};\r\n\t}\r\n\tvar maxl = UZIP.F.setDepth(list[i1-1], 0);\r\n\tif(maxl>MAXL) {  UZIP.F.restrictDepth(l2, MAXL, maxl);  maxl = MAXL;  }\r\n\tfor(i=0; i<end; i++) tree[(l2[i].lit<<1)+1]=l2[i].d;\r\n\treturn maxl;\r\n}\r\n\r\nUZIP.F.setDepth  = function(t, d) {\r\n\tif(t.lit!=-1) {  t.d=d;  return d;  }\r\n\treturn Math.max( UZIP.F.setDepth(t.l, d+1),  UZIP.F.setDepth(t.r, d+1) );\r\n}\r\n\r\nUZIP.F.restrictDepth = function(dps, MD, maxl) {\r\n\tvar i=0, bCost=1<<(maxl-MD), dbt=0;\r\n\tdps.sort(function(a,b){return b.d==a.d ? a.f-b.f : b.d-a.d;});\r\n\t\r\n\tfor(i=0; i<dps.length; i++) if(dps[i].d>MD) {  var od=dps[i].d;  dps[i].d=MD;  dbt+=bCost-(1<<(maxl-od));  }  else break;\r\n\tdbt = dbt>>>(maxl-MD);\r\n\twhile(dbt>0) {  var od=dps[i].d;  if(od<MD) {  dps[i].d++;  dbt-=(1<<(MD-od-1));  }  else  i++;  }\r\n\tfor(; i>=0; i--) if(dps[i].d==MD && dbt<0) {  dps[i].d--;  dbt++;  }  if(dbt!=0) console.log(\"debt left\");\r\n}\r\n\r\nUZIP.F._goodIndex = function(v, arr) {\r\n\tvar i=0;  if(arr[i|16]<=v) i|=16;  if(arr[i|8]<=v) i|=8;  if(arr[i|4]<=v) i|=4;  if(arr[i|2]<=v) i|=2;  if(arr[i|1]<=v) i|=1;  return i;\r\n}\r\nUZIP.F._writeLit = function(ch, ltree, out, pos) {\r\n\tUZIP.F._putsF(out, pos, ltree[ch<<1]);\r\n\treturn pos+ltree[(ch<<1)+1];\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nUZIP.F.inflate = function(data, buf) {\r\n\tvar u8=Uint8Array;\r\n\tif(data[0]==3 && data[1]==0) return (buf ? buf : new u8(0));\r\n\tvar F=UZIP.F, bitsF = F._bitsF, bitsE = F._bitsE, decodeTiny = F._decodeTiny, makeCodes = F.makeCodes, codes2map=F.codes2map, get17 = F._get17;\r\n\tvar U = F.U;\r\n\t\r\n\tvar noBuf = (buf==null);\r\n\tif(noBuf) buf = new u8((data.length>>>2)<<3);\r\n\t\r\n\tvar BFINAL=0, BTYPE=0, HLIT=0, HDIST=0, HCLEN=0, ML=0, MD=0; \t\r\n\tvar off = 0, pos = 0;\r\n\tvar lmap, dmap;\r\n\t\r\n\twhile(BFINAL==0) {\t\t\r\n\t\tBFINAL = bitsF(data, pos  , 1);\r\n\t\tBTYPE  = bitsF(data, pos+1, 2);  pos+=3;\r\n\t\t//console.log(BFINAL, BTYPE);\r\n\t\t\r\n\t\tif(BTYPE==0) {\r\n\t\t\tif((pos&7)!=0) pos+=8-(pos&7);\r\n\t\t\tvar p8 = (pos>>>3)+4, len = data[p8-4]|(data[p8-3]<<8);  //console.log(len);//bitsF(data, pos, 16), \r\n\t\t\tif(noBuf) buf=UZIP.F._check(buf, off+len);\r\n\t\t\tbuf.set(new u8(data.buffer, data.byteOffset+p8, len), off);\r\n\t\t\t//for(var i=0; i<len; i++) buf[off+i] = data[p8+i];\r\n\t\t\t//for(var i=0; i<len; i++) if(buf[off+i] != data[p8+i]) throw \"e\";\r\n\t\t\tpos = ((p8+len)<<3);  off+=len;  continue;\r\n\t\t}\r\n\t\tif(noBuf) buf=UZIP.F._check(buf, off+(1<<17));  // really not enough in many cases (but PNG and ZIP provide buffer in advance)\r\n\t\tif(BTYPE==1) {  lmap = U.flmap;  dmap = U.fdmap;  ML = (1<<9)-1;  MD = (1<<5)-1;   }\r\n\t\tif(BTYPE==2) {\r\n\t\t\tHLIT  = bitsE(data, pos   , 5)+257;  \r\n\t\t\tHDIST = bitsE(data, pos+ 5, 5)+  1;  \r\n\t\t\tHCLEN = bitsE(data, pos+10, 4)+  4;  pos+=14;\r\n\t\t\t\r\n\t\t\tvar ppos = pos;\r\n\t\t\tfor(var i=0; i<38; i+=2) {  U.itree[i]=0;  U.itree[i+1]=0;  }\r\n\t\t\tvar tl = 1;\r\n\t\t\tfor(var i=0; i<HCLEN; i++) {  var l=bitsE(data, pos+i*3, 3);  U.itree[(U.ordr[i]<<1)+1] = l;  if(l>tl)tl=l;  }     pos+=3*HCLEN;  //console.log(itree);\r\n\t\t\tmakeCodes(U.itree, tl);\r\n\t\t\tcodes2map(U.itree, tl, U.imap);\r\n\t\t\t\r\n\t\t\tlmap = U.lmap;  dmap = U.dmap;\r\n\t\t\t\r\n\t\t\tpos = decodeTiny(U.imap, (1<<tl)-1, HLIT+HDIST, data, pos, U.ttree);\r\n\t\t\tvar mx0 = F._copyOut(U.ttree,    0, HLIT , U.ltree);  ML = (1<<mx0)-1;\r\n\t\t\tvar mx1 = F._copyOut(U.ttree, HLIT, HDIST, U.dtree);  MD = (1<<mx1)-1;\r\n\t\t\t\r\n\t\t\t//var ml = decodeTiny(U.imap, (1<<tl)-1, HLIT , data, pos, U.ltree); ML = (1<<(ml>>>24))-1;  pos+=(ml&0xffffff);\r\n\t\t\tmakeCodes(U.ltree, mx0);\r\n\t\t\tcodes2map(U.ltree, mx0, lmap);\r\n\t\t\t\r\n\t\t\t//var md = decodeTiny(U.imap, (1<<tl)-1, HDIST, data, pos, U.dtree); MD = (1<<(md>>>24))-1;  pos+=(md&0xffffff);\r\n\t\t\tmakeCodes(U.dtree, mx1);\r\n\t\t\tcodes2map(U.dtree, mx1, dmap);\r\n\t\t}\r\n\t\t//var ooff=off, opos=pos;\r\n\t\twhile(true) {\r\n\t\t\tvar code = lmap[get17(data, pos) & ML];  pos += code&15;\r\n\t\t\tvar lit = code>>>4;  //U.lhst[lit]++;  \r\n\t\t\tif((lit>>>8)==0) {  buf[off++] = lit;  }\r\n\t\t\telse if(lit==256) {  break;  }\r\n\t\t\telse {\r\n\t\t\t\tvar end = off+lit-254;\r\n\t\t\t\tif(lit>264) { var ebs = U.ldef[lit-257];  end = off + (ebs>>>3) + bitsE(data, pos, ebs&7);  pos += ebs&7;  }\r\n\t\t\t\t//UZIP.F.dst[end-off]++;\r\n\t\t\t\t\r\n\t\t\t\tvar dcode = dmap[get17(data, pos) & MD];  pos += dcode&15;\r\n\t\t\t\tvar dlit = dcode>>>4;\r\n\t\t\t\tvar dbs = U.ddef[dlit], dst = (dbs>>>4) + bitsF(data, pos, dbs&15);  pos += dbs&15;\r\n\t\t\t\t\r\n\t\t\t\t//var o0 = off-dst, stp = Math.min(end-off, dst);\r\n\t\t\t\t//if(stp>20) while(off<end) {  buf.copyWithin(off, o0, o0+stp);  off+=stp;  }  else\r\n\t\t\t\t//if(end-dst<=off) buf.copyWithin(off, off-dst, end-dst);  else\r\n\t\t\t\t//if(dst==1) buf.fill(buf[off-1], off, end);  else\r\n\t\t\t\tif(noBuf) buf=UZIP.F._check(buf, off+(1<<17));\r\n\t\t\t\twhile(off<end) {  buf[off]=buf[off++-dst];    buf[off]=buf[off++-dst];  buf[off]=buf[off++-dst];  buf[off]=buf[off++-dst];  }   \r\n\t\t\t\toff=end;\r\n\t\t\t\t//while(off!=end) {  buf[off]=buf[off++-dst];  }\r\n\t\t\t}\r\n\t\t}\r\n\t\t//console.log(off-ooff, (pos-opos)>>>3);\r\n\t}\r\n\t//console.log(UZIP.F.dst);\r\n\t//console.log(tlen, dlen, off-tlen+tcnt);\r\n\treturn buf.length==off ? buf : buf.slice(0,off);\r\n}\r\nUZIP.F._check=function(buf, len) {\r\n\tvar bl=buf.length;  if(len<=bl) return buf;\r\n\tvar nbuf = new Uint8Array(Math.max(bl<<1,len));  nbuf.set(buf,0);\r\n\t//for(var i=0; i<bl; i+=4) {  nbuf[i]=buf[i];  nbuf[i+1]=buf[i+1];  nbuf[i+2]=buf[i+2];  nbuf[i+3]=buf[i+3];  }\r\n\treturn nbuf;\r\n}\r\n\r\nUZIP.F._decodeTiny = function(lmap, LL, len, data, pos, tree) {\r\n\tvar bitsE = UZIP.F._bitsE, get17 = UZIP.F._get17;\r\n\tvar i = 0;\r\n\twhile(i<len) {\r\n\t\tvar code = lmap[get17(data, pos)&LL];  pos+=code&15;\r\n\t\tvar lit = code>>>4; \r\n\t\tif(lit<=15) {  tree[i]=lit;  i++;  }\r\n\t\telse {\r\n\t\t\tvar ll = 0, n = 0;\r\n\t\t\tif(lit==16) {\r\n\t\t\t\tn = (3  + bitsE(data, pos, 2));  pos += 2;  ll = tree[i-1];\r\n\t\t\t}\r\n\t\t\telse if(lit==17) {\r\n\t\t\t\tn = (3  + bitsE(data, pos, 3));  pos += 3;\r\n\t\t\t}\r\n\t\t\telse if(lit==18) {\r\n\t\t\t\tn = (11 + bitsE(data, pos, 7));  pos += 7;\r\n\t\t\t}\r\n\t\t\tvar ni = i+n;\r\n\t\t\twhile(i<ni) {  tree[i]=ll;  i++; }\r\n\t\t}\r\n\t}\r\n\treturn pos;\r\n}\r\nUZIP.F._copyOut = function(src, off, len, tree) {\r\n\tvar mx=0, i=0, tl=tree.length>>>1;\r\n\twhile(i<len) {  var v=src[i+off];  tree[(i<<1)]=0;  tree[(i<<1)+1]=v;  if(v>mx)mx=v;  i++;  }\r\n\twhile(i<tl ) {  tree[(i<<1)]=0;  tree[(i<<1)+1]=0;  i++;  }\r\n\treturn mx;\r\n}\r\n\r\nUZIP.F.makeCodes = function(tree, MAX_BITS) {  // code, length\r\n\tvar U = UZIP.F.U;\r\n\tvar max_code = tree.length;\r\n\tvar code, bits, n, i, len;\r\n\t\r\n\tvar bl_count = U.bl_count;  for(var i=0; i<=MAX_BITS; i++) bl_count[i]=0;\r\n\tfor(i=1; i<max_code; i+=2) bl_count[tree[i]]++;\r\n\t\r\n\tvar next_code = U.next_code;\t// smallest code for each length\r\n\t\r\n\tcode = 0;\r\n\tbl_count[0] = 0;\r\n\tfor (bits = 1; bits <= MAX_BITS; bits++) {\r\n\t\tcode = (code + bl_count[bits-1]) << 1;\r\n\t\tnext_code[bits] = code;\r\n\t}\r\n\t\r\n\tfor (n = 0; n < max_code; n+=2) {\r\n\t\tlen = tree[n+1];\r\n\t\tif (len != 0) {\r\n\t\t\ttree[n] = next_code[len];\r\n\t\t\tnext_code[len]++;\r\n\t\t}\r\n\t}\r\n}\r\nUZIP.F.codes2map = function(tree, MAX_BITS, map) {\r\n\tvar max_code = tree.length;\r\n\tvar U=UZIP.F.U, r15 = U.rev15;\r\n\tfor(var i=0; i<max_code; i+=2) if(tree[i+1]!=0)  {\r\n\t\tvar lit = i>>1;\r\n\t\tvar cl = tree[i+1], val = (lit<<4)|cl; // :  (0x8000 | (U.of0[lit-257]<<7) | (U.exb[lit-257]<<4) | cl);\r\n\t\tvar rest = (MAX_BITS-cl), i0 = tree[i]<<rest, i1 = i0 + (1<<rest);\r\n\t\t//tree[i]=r15[i0]>>>(15-MAX_BITS);\r\n\t\twhile(i0!=i1) {\r\n\t\t\tvar p0 = r15[i0]>>>(15-MAX_BITS);\r\n\t\t\tmap[p0]=val;  i0++;\r\n\t\t}\r\n\t}\r\n}\r\nUZIP.F.revCodes = function(tree, MAX_BITS) {\r\n\tvar r15 = UZIP.F.U.rev15, imb = 15-MAX_BITS;\r\n\tfor(var i=0; i<tree.length; i+=2) {  var i0 = (tree[i]<<(MAX_BITS-tree[i+1]));  tree[i] = r15[i0]>>>imb;  }\r\n}\r\n\r\n// used only in deflate\r\nUZIP.F._putsE= function(dt, pos, val   ) {  val = val<<(pos&7);  var o=(pos>>>3);  dt[o]|=val;  dt[o+1]|=(val>>>8);                        }\r\nUZIP.F._putsF= function(dt, pos, val   ) {  val = val<<(pos&7);  var o=(pos>>>3);  dt[o]|=val;  dt[o+1]|=(val>>>8);  dt[o+2]|=(val>>>16);  }\r\n\r\nUZIP.F._bitsE= function(dt, pos, length) {  return ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8)                        )>>>(pos&7))&((1<<length)-1);  }\r\nUZIP.F._bitsF= function(dt, pos, length) {  return ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16))>>>(pos&7))&((1<<length)-1);  }\r\n/*\r\nUZIP.F._get9 = function(dt, pos) {\r\n\treturn ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8))>>>(pos&7))&511;\r\n} */\r\nUZIP.F._get17= function(dt, pos) {\t// return at least 17 meaningful bytes\r\n\treturn (dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16) )>>>(pos&7);\r\n}\r\nUZIP.F._get25= function(dt, pos) {\t// return at least 17 meaningful bytes\r\n\treturn (dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16) | (dt[(pos>>>3)+3]<<24) )>>>(pos&7);\r\n}\r\nUZIP.F.U = function(){\r\n\tvar u16=Uint16Array, u32=Uint32Array;\r\n\treturn {\r\n\t\tnext_code : new u16(16),\r\n\t\tbl_count  : new u16(16),\r\n\t\tordr : [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ],\r\n\t\tof0  : [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],\r\n\t\texb  : [0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0,  0,  0,  0],\r\n\t\tldef : new u16(32),\r\n\t\tdf0  : [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 65535, 65535],\r\n\t\tdxb  : [0,0,0,0,1,1,2, 2, 3, 3, 4, 4, 5, 5,  6,  6,  7,  7,  8,  8,   9,   9,  10,  10,  11,  11,  12,   12,   13,   13,     0,     0],\r\n\t\tddef : new u32(32),\r\n\t\tflmap: new u16(  512),  fltree: [],\r\n\t\tfdmap: new u16(   32),  fdtree: [],\r\n\t\tlmap : new u16(32768),  ltree : [],  ttree:[],\r\n\t\tdmap : new u16(32768),  dtree : [],\r\n\t\timap : new u16(  512),  itree : [],\r\n\t\t//rev9 : new u16(  512)\r\n\t\trev15: new u16(1<<15),\r\n\t\tlhst : new u32(286), dhst : new u32( 30), ihst : new u32(19),\r\n\t\tlits : new u32(15000),\r\n\t\tstrt : new u16(1<<16),\r\n\t\tprev : new u16(1<<15)\r\n\t};  \r\n} ();\r\n\r\n(function(){\t\r\n\tvar U = UZIP.F.U;\r\n\tvar len = 1<<15;\r\n\tfor(var i=0; i<len; i++) {\r\n\t\tvar x = i;\r\n\t\tx = (((x & 0xaaaaaaaa) >>> 1) | ((x & 0x55555555) << 1));\r\n\t\tx = (((x & 0xcccccccc) >>> 2) | ((x & 0x33333333) << 2));\r\n\t\tx = (((x & 0xf0f0f0f0) >>> 4) | ((x & 0x0f0f0f0f) << 4));\r\n\t\tx = (((x & 0xff00ff00) >>> 8) | ((x & 0x00ff00ff) << 8));\r\n\t\tU.rev15[i] = (((x >>> 16) | (x << 16)))>>>17;\r\n\t}\r\n\t\r\n\tfunction pushV(tgt, n, sv) {  while(n--!=0) tgt.push(0,sv);  }\r\n\t\r\n\tfor(var i=0; i<32; i++) {  U.ldef[i]=(U.of0[i]<<3)|U.exb[i];  U.ddef[i]=(U.df0[i]<<4)|U.dxb[i];  }\r\n\t\r\n\tpushV(U.fltree, 144, 8);  pushV(U.fltree, 255-143, 9);  pushV(U.fltree, 279-255, 7);  pushV(U.fltree,287-279,8);\r\n\t/*\r\n\tvar i = 0;\r\n\tfor(; i<=143; i++) U.fltree.push(0,8);\r\n\tfor(; i<=255; i++) U.fltree.push(0,9);\r\n\tfor(; i<=279; i++) U.fltree.push(0,7);\r\n\tfor(; i<=287; i++) U.fltree.push(0,8);\r\n\t*/\r\n\tUZIP.F.makeCodes(U.fltree, 9);\r\n\tUZIP.F.codes2map(U.fltree, 9, U.flmap);\r\n\tUZIP.F.revCodes (U.fltree, 9)\r\n\t\r\n\tpushV(U.fdtree,32,5);\r\n\t//for(i=0;i<32; i++) U.fdtree.push(0,5);\r\n\tUZIP.F.makeCodes(U.fdtree, 5);\r\n\tUZIP.F.codes2map(U.fdtree, 5, U.fdmap);\r\n\tUZIP.F.revCodes (U.fdtree, 5)\r\n\t\r\n\tpushV(U.itree,19,0);  pushV(U.ltree,286,0);  pushV(U.dtree,30,0);  pushV(U.ttree,320,0);\r\n\t/*\r\n\tfor(var i=0; i< 19; i++) U.itree.push(0,0);\r\n\tfor(var i=0; i<286; i++) U.ltree.push(0,0);\r\n\tfor(var i=0; i< 30; i++) U.dtree.push(0,0);\r\n\tfor(var i=0; i<320; i++) U.ttree.push(0,0);\r\n\t*/\r\n})()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","// https://github.com/photopea/UPNG.js/blob/c976240e62b0497167f8aafabd7889625f8b2016/UPNG.js\n\n// import * as pako from 'pako'\nimport * as UZIP from 'uzip';\n\nconst UPNG = {};\n\nUPNG.toRGBA8 = function (out) {\n  const w = out.width; const\n    h = out.height;\n  if (out.tabs.acTL == null) return [UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer];\n\n  const frms = [];\n  if (out.frames[0].data == null) out.frames[0].data = out.data;\n\n  const len = w * h * 4; const img = new Uint8Array(len); const empty = new Uint8Array(len); const\n    prev = new Uint8Array(len);\n  for (let i = 0; i < out.frames.length; i++) {\n    const frm = out.frames[i];\n    const fx = frm.rect.x; const fy = frm.rect.y; const fw = frm.rect.width; const\n      fh = frm.rect.height;\n    const fdata = UPNG.toRGBA8.decodeImage(frm.data, fw, fh, out);\n\n    if (i != 0) for (var j = 0; j < len; j++) prev[j] = img[j];\n\n    if (frm.blend == 0) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);\n    else if (frm.blend == 1) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);\n\n    frms.push(img.buffer.slice(0));\n\n    if (frm.dispose == 0) {} else if (frm.dispose == 1) UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);\n    else if (frm.dispose == 2) for (var j = 0; j < len; j++) img[j] = prev[j];\n  }\n  return frms;\n};\nUPNG.toRGBA8.decodeImage = function (data, w, h, out) {\n  const area = w * h; const\n    bpp = UPNG.decode._getBPP(out);\n  const bpl = Math.ceil(w * bpp / 8);\t// bytes per line\n\n  const bf = new Uint8Array(area * 4); const\n    bf32 = new Uint32Array(bf.buffer);\n  const { ctype } = out;\n  const { depth } = out;\n  const rs = UPNG._bin.readUshort;\n\n  // console.log(ctype, depth);\n  const time = Date.now();\n\n  if (ctype == 6) { // RGB + alpha\n    const qarea = area << 2;\n    if (depth == 8) for (var i = 0; i < qarea; i += 4) { bf[i] = data[i]; bf[i + 1] = data[i + 1]; bf[i + 2] = data[i + 2]; bf[i + 3] = data[i + 3]; }\n    if (depth == 16) for (var i = 0; i < qarea; i++) { bf[i] = data[i << 1]; }\n  } else if (ctype == 2) {\t// RGB\n    const ts = out.tabs.tRNS;\n    if (ts == null) {\n      if (depth == 8) for (var i = 0; i < area; i++) { var ti = i * 3; bf32[i] = (255 << 24) | (data[ti + 2] << 16) | (data[ti + 1] << 8) | data[ti]; }\n      if (depth == 16) for (var i = 0; i < area; i++) { var ti = i * 6; bf32[i] = (255 << 24) | (data[ti + 4] << 16) | (data[ti + 2] << 8) | data[ti]; }\n    } else {\n      var tr = ts[0]; const tg = ts[1]; const\n        tb = ts[2];\n      if (depth == 8) {\n        for (var i = 0; i < area; i++) {\n          var qi = i << 2; var\n            ti = i * 3; bf32[i] = (255 << 24) | (data[ti + 2] << 16) | (data[ti + 1] << 8) | data[ti];\n          if (data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb) bf[qi + 3] = 0;\n        }\n      }\n      if (depth == 16) {\n        for (var i = 0; i < area; i++) {\n          var qi = i << 2; var\n            ti = i * 6; bf32[i] = (255 << 24) | (data[ti + 4] << 16) | (data[ti + 2] << 8) | data[ti];\n          if (rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb) bf[qi + 3] = 0;\n        }\n      }\n    }\n  } else if (ctype == 3) {\t// palette\n    const p = out.tabs.PLTE;\n    const ap = out.tabs.tRNS;\n    const tl = ap ? ap.length : 0;\n    // console.log(p, ap);\n    if (depth == 1) {\n      for (var y = 0; y < h; y++) {\n        var s0 = y * bpl; var\n          t0 = y * w;\n        for (var i = 0; i < w; i++) {\n          var qi = (t0 + i) << 2; var j = ((data[s0 + (i >> 3)] >> (7 - ((i & 7) << 0))) & 1); var\n            cj = 3 * j; bf[qi] = p[cj]; bf[qi + 1] = p[cj + 1]; bf[qi + 2] = p[cj + 2]; bf[qi + 3] = (j < tl) ? ap[j] : 255;\n        }\n      }\n    }\n    if (depth == 2) {\n      for (var y = 0; y < h; y++) {\n        var s0 = y * bpl; var\n          t0 = y * w;\n        for (var i = 0; i < w; i++) {\n          var qi = (t0 + i) << 2; var j = ((data[s0 + (i >> 2)] >> (6 - ((i & 3) << 1))) & 3); var\n            cj = 3 * j; bf[qi] = p[cj]; bf[qi + 1] = p[cj + 1]; bf[qi + 2] = p[cj + 2]; bf[qi + 3] = (j < tl) ? ap[j] : 255;\n        }\n      }\n    }\n    if (depth == 4) {\n      for (var y = 0; y < h; y++) {\n        var s0 = y * bpl; var\n          t0 = y * w;\n        for (var i = 0; i < w; i++) {\n          var qi = (t0 + i) << 2; var j = ((data[s0 + (i >> 1)] >> (4 - ((i & 1) << 2))) & 15); var\n            cj = 3 * j; bf[qi] = p[cj]; bf[qi + 1] = p[cj + 1]; bf[qi + 2] = p[cj + 2]; bf[qi + 3] = (j < tl) ? ap[j] : 255;\n        }\n      }\n    }\n    if (depth == 8) {\n      for (var i = 0; i < area; i++) {\n        var qi = i << 2; var j = data[i]; var\n          cj = 3 * j; bf[qi] = p[cj]; bf[qi + 1] = p[cj + 1]; bf[qi + 2] = p[cj + 2]; bf[qi + 3] = (j < tl) ? ap[j] : 255;\n      }\n    }\n  } else if (ctype == 4) {\t// gray + alpha\n    if (depth == 8) {\n      for (var i = 0; i < area; i++) {\n        var qi = i << 2; var di = i << 1; var\n          gr = data[di]; bf[qi] = gr; bf[qi + 1] = gr; bf[qi + 2] = gr; bf[qi + 3] = data[di + 1];\n      }\n    }\n    if (depth == 16) {\n      for (var i = 0; i < area; i++) {\n        var qi = i << 2; var di = i << 2; var\n          gr = data[di]; bf[qi] = gr; bf[qi + 1] = gr; bf[qi + 2] = gr; bf[qi + 3] = data[di + 2];\n      }\n    }\n  } else if (ctype == 0) {\t// gray\n    var tr = out.tabs.tRNS ? out.tabs.tRNS : -1;\n    for (var y = 0; y < h; y++) {\n      const off = y * bpl; const\n        to = y * w;\n      if (depth == 1) {\n        for (var x = 0; x < w; x++) {\n          var gr = 255 * ((data[off + (x >>> 3)] >>> (7 - ((x & 7)))) & 1); var\n            al = (gr == tr * 255) ? 0 : 255; bf32[to + x] = (al << 24) | (gr << 16) | (gr << 8) | gr;\n        }\n      } else if (depth == 2) {\n        for (var x = 0; x < w; x++) {\n          var gr = 85 * ((data[off + (x >>> 2)] >>> (6 - ((x & 3) << 1))) & 3); var\n            al = (gr == tr * 85) ? 0 : 255; bf32[to + x] = (al << 24) | (gr << 16) | (gr << 8) | gr;\n        }\n      } else if (depth == 4) {\n        for (var x = 0; x < w; x++) {\n          var gr = 17 * ((data[off + (x >>> 1)] >>> (4 - ((x & 1) << 2))) & 15); var\n            al = (gr == tr * 17) ? 0 : 255; bf32[to + x] = (al << 24) | (gr << 16) | (gr << 8) | gr;\n        }\n      } else if (depth == 8) {\n        for (var x = 0; x < w; x++) {\n          var gr = data[off + x]; var\n            al = (gr == tr) ? 0 : 255; bf32[to + x] = (al << 24) | (gr << 16) | (gr << 8) | gr;\n        }\n      } else if (depth == 16) {\n        for (var x = 0; x < w; x++) {\n          var gr = data[off + (x << 1)]; var\n            al = (rs(data, off + (x << i)) == tr) ? 0 : 255; bf32[to + x] = (al << 24) | (gr << 16) | (gr << 8) | gr;\n        }\n      }\n    }\n  }\n  // console.log(Date.now()-time);\n  return bf;\n};\n\nUPNG.decode = function (buff) {\n  const data = new Uint8Array(buff); let offset = 8; const bin = UPNG._bin; const rUs = bin.readUshort; const\n    rUi = bin.readUint;\n  const out = { tabs: {}, frames: [] };\n  const dd = new Uint8Array(data.length); let\n    doff = 0;\t // put all IDAT data into it\n  let fd; let\n    foff = 0;\t// frames\n\n  const mgck = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\n  for (var i = 0; i < 8; i++) if (data[i] != mgck[i]) throw 'The input is not a PNG file!';\n\n  while (offset < data.length) {\n    const len = bin.readUint(data, offset); offset += 4;\n    const type = bin.readASCII(data, offset, 4); offset += 4;\n    // console.log(type,len);\n\n    if (type == 'IHDR') { UPNG.decode._IHDR(data, offset, out); } else if (type == 'CgBI') { out.tabs[type] = data.slice(offset, offset + 4); } else if (type == 'IDAT') {\n      for (var i = 0; i < len; i++) dd[doff + i] = data[offset + i];\n      doff += len;\n    } else if (type == 'acTL') {\n      out.tabs[type] = { num_frames: rUi(data, offset), num_plays: rUi(data, offset + 4) };\n      fd = new Uint8Array(data.length);\n    } else if (type == 'fcTL') {\n      if (foff != 0) {\n        var fr = out.frames[out.frames.length - 1];\n        fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height); foff = 0;\n      }\n      const rct = {\n        x: rUi(data, offset + 12), y: rUi(data, offset + 16), width: rUi(data, offset + 4), height: rUi(data, offset + 8),\n      };\n      let del = rUs(data, offset + 22); del = rUs(data, offset + 20) / (del == 0 ? 100 : del);\n      const frm = {\n        rect: rct, delay: Math.round(del * 1000), dispose: data[offset + 24], blend: data[offset + 25],\n      };\n      // console.log(frm);\n      out.frames.push(frm);\n    } else if (type == 'fdAT') {\n      for (var i = 0; i < len - 4; i++) fd[foff + i] = data[offset + i + 4];\n      foff += len - 4;\n    } else if (type == 'pHYs') {\n      out.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset + 4), data[offset + 8]];\n    } else if (type == 'cHRM') {\n      out.tabs[type] = [];\n      for (var i = 0; i < 8; i++) out.tabs[type].push(bin.readUint(data, offset + i * 4));\n    } else if (type == 'tEXt' || type == 'zTXt') {\n      if (out.tabs[type] == null) out.tabs[type] = {};\n      var nz = bin.nextZero(data, offset);\n      var keyw = bin.readASCII(data, offset, nz - offset);\n      var text; var\n        tl = offset + len - nz - 1;\n      if (type == 'tEXt') text = bin.readASCII(data, nz + 1, tl);\n      else {\n        var bfr = UPNG.decode._inflate(data.slice(nz + 2, nz + 2 + tl));\n        text = bin.readUTF8(bfr, 0, bfr.length);\n      }\n      out.tabs[type][keyw] = text;\n    } else if (type == 'iTXt') {\n      if (out.tabs[type] == null) out.tabs[type] = {};\n      var nz = 0; let\n        off = offset;\n      nz = bin.nextZero(data, off);\n      var keyw = bin.readASCII(data, off, nz - off); off = nz + 1;\n      const cflag = data[off]; const\n        cmeth = data[off + 1]; off += 2;\n      nz = bin.nextZero(data, off);\n      const ltag = bin.readASCII(data, off, nz - off); off = nz + 1;\n      nz = bin.nextZero(data, off);\n      const tkeyw = bin.readUTF8(data, off, nz - off); off = nz + 1;\n      var text; var\n        tl = len - (off - offset);\n      if (cflag == 0) text = bin.readUTF8(data, off, tl);\n      else {\n        var bfr = UPNG.decode._inflate(data.slice(off, off + tl));\n        text = bin.readUTF8(bfr, 0, bfr.length);\n      }\n      out.tabs[type][keyw] = text;\n    } else if (type == 'PLTE') {\n      out.tabs[type] = bin.readBytes(data, offset, len);\n    } else if (type == 'hIST') {\n      const pl = out.tabs.PLTE.length / 3;\n      out.tabs[type] = []; for (var i = 0; i < pl; i++) out.tabs[type].push(rUs(data, offset + i * 2));\n    } else if (type == 'tRNS') {\n      if (out.ctype == 3) out.tabs[type] = bin.readBytes(data, offset, len);\n      else if (out.ctype == 0) out.tabs[type] = rUs(data, offset);\n      else if (out.ctype == 2) out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];\n      // else console.log(\"tRNS for unsupported color type\",out.ctype, len);\n    } else if (type == 'gAMA') out.tabs[type] = bin.readUint(data, offset) / 100000;\n    else if (type == 'sRGB') out.tabs[type] = data[offset];\n    else if (type == 'bKGD') {\n      if (out.ctype == 0 || out.ctype == 4) out.tabs[type] = [rUs(data, offset)];\n      else if (out.ctype == 2 || out.ctype == 6) out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];\n      else if (out.ctype == 3) out.tabs[type] = data[offset];\n    } else if (type == 'IEND') {\n      break;\n    }\n    // else {  log(\"unknown chunk type\", type, len);  }\n    offset += len;\n    const crc = bin.readUint(data, offset); offset += 4;\n  }\n  if (foff != 0) {\n    var fr = out.frames[out.frames.length - 1];\n    fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height); foff = 0;\n  }\n  out.data = UPNG.decode._decompress(out, dd, out.width, out.height);\n\n  delete out.compress; delete out.interlace; delete out.filter;\n  return out;\n};\n\nUPNG.decode._decompress = function (out, dd, w, h) {\n  var time = Date.now();\n  const bpp = UPNG.decode._getBPP(out); const bpl = Math.ceil(w * bpp / 8); const\n    buff = new Uint8Array((bpl + 1 + out.interlace) * h);\n  if (out.tabs.CgBI) dd = UPNG.inflateRaw(dd, buff);\n  else dd = UPNG.decode._inflate(dd, buff);\n  // console.log(dd.length, buff.length);\n  // console.log(Date.now()-time);\n\n  var time = Date.now();\n  if (out.interlace == 0) dd = UPNG.decode._filterZero(dd, out, 0, w, h);\n  else if (out.interlace == 1) dd = UPNG.decode._readInterlace(dd, out);\n  // console.log(Date.now()-time);\n  return dd;\n};\n\nUPNG.decode._inflate = function (data, buff) { const out = UPNG.inflateRaw(new Uint8Array(data.buffer, 2, data.length - 6), buff); return out; };\nUPNG.inflateRaw = (function () {\n  const H = {}; H.H = {}; H.H.N = function (N, W) {\n    const R = Uint8Array; let i = 0; let m = 0; let J = 0; let h = 0; let Q = 0; let X = 0; let u = 0; let w = 0; let d = 0; let v; let C;\n    if (N[0] == 3 && N[1] == 0) return W || new R(0); const V = H.H; const n = V.b; const A = V.e; const l = V.R; const M = V.n; const I = V.A; const e = V.Z; const b = V.m; const Z = W == null;\n    if (Z)W = new R(N.length >>> 2 << 5); while (i == 0) {\n      i = n(N, d, 1); m = n(N, d + 1, 2); d += 3; if (m == 0) {\n        if ((d & 7) != 0)d += 8 - (d & 7);\n        const D = (d >>> 3) + 4; const q = N[D - 4] | N[D - 3] << 8; if (Z)W = H.H.W(W, w + q); W.set(new R(N.buffer, N.byteOffset + D, q), w); d = D + q << 3;\n        w += q; continue;\n      } if (Z)W = H.H.W(W, w + (1 << 17)); if (m == 1) { v = b.J; C = b.h; X = (1 << 9) - 1; u = (1 << 5) - 1; } if (m == 2) {\n        J = A(N, d, 5) + 257;\n        h = A(N, d + 5, 5) + 1; Q = A(N, d + 10, 4) + 4; d += 14; const E = d; let j = 1; for (var c = 0; c < 38; c += 2) { b.Q[c] = 0; b.Q[c + 1] = 0; } for (var c = 0;\n          c < Q; c++) { const K = A(N, d + c * 3, 3); b.Q[(b.X[c] << 1) + 1] = K; if (K > j)j = K; }d += 3 * Q; M(b.Q, j); I(b.Q, j, b.u); v = b.w; C = b.d;\n        d = l(b.u, (1 << j) - 1, J + h, N, d, b.v); const r = V.V(b.v, 0, J, b.C); X = (1 << r) - 1; const S = V.V(b.v, J, h, b.D); u = (1 << S) - 1; M(b.C, r);\n        I(b.C, r, v); M(b.D, S); I(b.D, S, C);\n      } while (!0) {\n        const T = v[e(N, d) & X]; d += T & 15; const p = T >>> 4; if (p >>> 8 == 0) { W[w++] = p; } else if (p == 256) { break; } else {\n          let z = w + p - 254;\n          if (p > 264) { const _ = b.q[p - 257]; z = w + (_ >>> 3) + A(N, d, _ & 7); d += _ & 7; } const $ = C[e(N, d) & u]; d += $ & 15; const s = $ >>> 4; const Y = b.c[s]; const a = (Y >>> 4) + n(N, d, Y & 15);\n          d += Y & 15; while (w < z) { W[w] = W[w++ - a]; W[w] = W[w++ - a]; W[w] = W[w++ - a]; W[w] = W[w++ - a]; }w = z;\n        }\n      }\n    } return W.length == w ? W : W.slice(0, w);\n  };\n  H.H.W = function (N, W) { const R = N.length; if (W <= R) return N; const V = new Uint8Array(R << 1); V.set(N, 0); return V; };\n  H.H.R = function (N, W, R, V, n, A) {\n    const l = H.H.e; const M = H.H.Z; let I = 0; while (I < R) {\n      const e = N[M(V, n) & W]; n += e & 15; const b = e >>> 4;\n      if (b <= 15) { A[I] = b; I++; } else {\n        let Z = 0; let m = 0; if (b == 16) { m = 3 + l(V, n, 2); n += 2; Z = A[I - 1]; } else if (b == 17) {\n          m = 3 + l(V, n, 3);\n          n += 3;\n        } else if (b == 18) { m = 11 + l(V, n, 7); n += 7; } const J = I + m; while (I < J) { A[I] = Z; I++; }\n      }\n    } return n;\n  }; H.H.V = function (N, W, R, V) {\n    let n = 0; let A = 0; const l = V.length >>> 1;\n    while (A < R) { const M = N[A + W]; V[A << 1] = 0; V[(A << 1) + 1] = M; if (M > n)n = M; A++; } while (A < l) { V[A << 1] = 0; V[(A << 1) + 1] = 0; A++; } return n;\n  };\n  H.H.n = function (N, W) {\n    const R = H.H.m; const V = N.length; let n; let A; let l; var M; let I; const e = R.j; for (var M = 0; M <= W; M++)e[M] = 0; for (M = 1; M < V; M += 2)e[N[M]]++;\n    const b = R.K; n = 0; e[0] = 0; for (A = 1; A <= W; A++) { n = n + e[A - 1] << 1; b[A] = n; } for (l = 0; l < V; l += 2) {\n      I = N[l + 1]; if (I != 0) {\n        N[l] = b[I];\n        b[I]++;\n      }\n    }\n  }; H.H.A = function (N, W, R) {\n    const V = N.length; const n = H.H.m; const A = n.r; for (let l = 0; l < V; l += 2) {\n      if (N[l + 1] != 0) {\n        const M = l >> 1; const I = N[l + 1]; const e = M << 4 | I; const b = W - I; let Z = N[l] << b; const m = Z + (1 << b);\n        while (Z != m) { const J = A[Z] >>> 15 - W; R[J] = e; Z++; }\n      }\n    }\n  }; H.H.l = function (N, W) {\n    const R = H.H.m.r; const V = 15 - W; for (let n = 0; n < N.length;\n      n += 2) { const A = N[n] << W - N[n + 1]; N[n] = R[A] >>> V; }\n  }; H.H.M = function (N, W, R) { R <<= (W & 7); const V = W >>> 3; N[V] |= R; N[V + 1] |= R >>> 8; };\n  H.H.I = function (N, W, R) { R <<= (W & 7); const V = W >>> 3; N[V] |= R; N[V + 1] |= R >>> 8; N[V + 2] |= R >>> 16; }; H.H.e = function (N, W, R) { return (N[W >>> 3] | N[(W >>> 3) + 1] << 8) >>> (W & 7) & (1 << R) - 1; };\n  H.H.b = function (N, W, R) { return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7) & (1 << R) - 1; }; H.H.Z = function (N, W) { return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7); };\n  H.H.i = function (N, W) { return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16 | N[(W >>> 3) + 3] << 24) >>> (W & 7); }; H.H.m = (function () {\n    const N = Uint16Array; const W = Uint32Array;\n    return {\n      K: new N(16), j: new N(16), X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], q: new N(32), p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], c: new W(32), J: new N(512), _: [], h: new N(32), $: [], w: new N(32768), C: [], v: [], d: new N(32768), D: [], u: new N(512), Q: [], r: new N(1 << 15), s: new W(286), Y: new W(30), a: new W(19), t: new W(15e3), k: new N(1 << 16), g: new N(1 << 15),\n    };\n  }());\n  (function () {\n    const N = H.H.m; const W = 1 << 15; for (var R = 0; R < W; R++) {\n      let V = R; V = (V & 2863311530) >>> 1 | (V & 1431655765) << 1;\n      V = (V & 3435973836) >>> 2 | (V & 858993459) << 2; V = (V & 4042322160) >>> 4 | (V & 252645135) << 4; V = (V & 4278255360) >>> 8 | (V & 16711935) << 8;\n      N.r[R] = (V >>> 16 | V << 16) >>> 17;\n    } function n(A, l, M) { while (l-- != 0)A.push(0, M); } for (var R = 0; R < 32; R++) {\n      N.q[R] = N.S[R] << 3 | N.T[R];\n      N.c[R] = N.p[R] << 4 | N.z[R];\n    }n(N._, 144, 8); n(N._, 255 - 143, 9); n(N._, 279 - 255, 7); n(N._, 287 - 279, 8); H.H.n(N._, 9);\n    H.H.A(N._, 9, N.J); H.H.l(N._, 9); n(N.$, 32, 5); H.H.n(N.$, 5); H.H.A(N.$, 5, N.h); H.H.l(N.$, 5); n(N.Q, 19, 0); n(N.C, 286, 0);\n    n(N.D, 30, 0); n(N.v, 320, 0);\n  }()); return H.H.N;\n}());\n\nUPNG.decode._readInterlace = function (data, out) {\n  const w = out.width; const\n    h = out.height;\n  const bpp = UPNG.decode._getBPP(out); const cbpp = bpp >> 3; const\n    bpl = Math.ceil(w * bpp / 8);\n  const img = new Uint8Array(h * bpl);\n  let di = 0;\n\n  const starting_row = [0, 0, 4, 0, 2, 0, 1];\n  const starting_col = [0, 4, 0, 2, 0, 1, 0];\n  const row_increment = [8, 8, 8, 4, 4, 2, 2];\n  const col_increment = [8, 8, 4, 4, 2, 2, 1];\n\n  let pass = 0;\n  while (pass < 7) {\n    const ri = row_increment[pass]; const\n      ci = col_increment[pass];\n    let sw = 0; let\n      sh = 0;\n    let cr = starting_row[pass]; while (cr < h) { cr += ri; sh++; }\n    let cc = starting_col[pass]; while (cc < w) { cc += ci; sw++; }\n    const bpll = Math.ceil(sw * bpp / 8);\n    UPNG.decode._filterZero(data, out, di, sw, sh);\n\n    let y = 0; let\n      row = starting_row[pass];\n    while (row < h) {\n      let col = starting_col[pass];\n      let cdi = (di + y * bpll) << 3;\n\n      while (col < w) {\n        if (bpp == 1) {\n          var val = data[cdi >> 3]; val = (val >> (7 - (cdi & 7))) & 1;\n          img[row * bpl + (col >> 3)] |= (val << (7 - ((col & 7) << 0)));\n        }\n        if (bpp == 2) {\n          var val = data[cdi >> 3]; val = (val >> (6 - (cdi & 7))) & 3;\n          img[row * bpl + (col >> 2)] |= (val << (6 - ((col & 3) << 1)));\n        }\n        if (bpp == 4) {\n          var val = data[cdi >> 3]; val = (val >> (4 - (cdi & 7))) & 15;\n          img[row * bpl + (col >> 1)] |= (val << (4 - ((col & 1) << 2)));\n        }\n        if (bpp >= 8) {\n          const ii = row * bpl + col * cbpp;\n          for (let j = 0; j < cbpp; j++) img[ii + j] = data[(cdi >> 3) + j];\n        }\n        cdi += bpp; col += ci;\n      }\n      y++; row += ri;\n    }\n    if (sw * sh != 0) di += sh * (1 + bpll);\n    pass += 1;\n  }\n  return img;\n};\n\nUPNG.decode._getBPP = function (out) {\n  const noc = [1, null, 3, 1, 2, null, 4][out.ctype];\n  return noc * out.depth;\n};\n\nUPNG.decode._filterZero = function (data, out, off, w, h) {\n  let bpp = UPNG.decode._getBPP(out); const bpl = Math.ceil(w * bpp / 8); const\n    paeth = UPNG.decode._paeth;\n  bpp = Math.ceil(bpp / 8);\n\n  let i = 0; let di = 1; let type = data[off]; let\n    x = 0;\n\n  if (type > 1) data[off] = [0, 0, 1][type - 2];\n  if (type == 3) for (x = bpp; x < bpl; x++) data[x + 1] = (data[x + 1] + (data[x + 1 - bpp] >>> 1)) & 255;\n\n  for (let y = 0; y < h; y++) {\n    i = off + y * bpl; di = i + y + 1;\n    type = data[di - 1]; x = 0;\n\n    if (type == 0) for (; x < bpl; x++) data[i + x] = data[di + x];\n    else if (type == 1) {\n      for (; x < bpp; x++) data[i + x] = data[di + x];\n      for (; x < bpl; x++) data[i + x] = (data[di + x] + data[i + x - bpp]);\n    } else if (type == 2) { for (; x < bpl; x++) data[i + x] = (data[di + x] + data[i + x - bpl]); } else if (type == 3) {\n      for (; x < bpp; x++) data[i + x] = (data[di + x] + (data[i + x - bpl] >>> 1));\n      for (; x < bpl; x++) data[i + x] = (data[di + x] + ((data[i + x - bpl] + data[i + x - bpp]) >>> 1));\n    } else {\n      for (; x < bpp; x++) data[i + x] = (data[di + x] + paeth(0, data[i + x - bpl], 0));\n      for (; x < bpl; x++) data[i + x] = (data[di + x] + paeth(data[i + x - bpp], data[i + x - bpl], data[i + x - bpp - bpl]));\n    }\n  }\n  return data;\n};\n\nUPNG.decode._paeth = function (a, b, c) {\n  const p = a + b - c; const pa = (p - a); const pb = (p - b); const\n    pc = (p - c);\n  if (pa * pa <= pb * pb && pa * pa <= pc * pc) return a;\n  if (pb * pb <= pc * pc) return b;\n  return c;\n};\n\nUPNG.decode._IHDR = function (data, offset, out) {\n  const bin = UPNG._bin;\n  out.width = bin.readUint(data, offset); offset += 4;\n  out.height = bin.readUint(data, offset); offset += 4;\n  out.depth = data[offset]; offset++;\n  out.ctype = data[offset]; offset++;\n  out.compress = data[offset]; offset++;\n  out.filter = data[offset]; offset++;\n  out.interlace = data[offset]; offset++;\n};\n\nUPNG._bin = {\n  nextZero(data, p) { while (data[p] != 0) p++; return p; },\n  readUshort(buff, p) { return (buff[p] << 8) | buff[p + 1]; },\n  writeUshort(buff, p, n) { buff[p] = (n >> 8) & 255; buff[p + 1] = n & 255; },\n  readUint(buff, p) { return (buff[p] * (256 * 256 * 256)) + ((buff[p + 1] << 16) | (buff[p + 2] << 8) | buff[p + 3]); },\n  writeUint(buff, p, n) { buff[p] = (n >> 24) & 255; buff[p + 1] = (n >> 16) & 255; buff[p + 2] = (n >> 8) & 255; buff[p + 3] = n & 255; },\n  readASCII(buff, p, l) { let s = ''; for (let i = 0; i < l; i++) s += String.fromCharCode(buff[p + i]); return s; },\n  writeASCII(data, p, s) { for (let i = 0; i < s.length; i++) data[p + i] = s.charCodeAt(i); },\n  readBytes(buff, p, l) { const arr = []; for (let i = 0; i < l; i++) arr.push(buff[p + i]); return arr; },\n  pad(n) { return n.length < 2 ? `0${n}` : n; },\n  readUTF8(buff, p, l) {\n    let s = '';\n    let ns;\n    for (let i = 0; i < l; i++) s += `%${UPNG._bin.pad(buff[p + i].toString(16))}`;\n    try { ns = decodeURIComponent(s); } catch (e) { return UPNG._bin.readASCII(buff, p, l); }\n    return ns;\n  },\n};\nUPNG._copyTile = function (sb, sw, sh, tb, tw, th, xoff, yoff, mode) {\n  const w = Math.min(sw, tw); const\n    h = Math.min(sh, th);\n  let si = 0; let\n    ti = 0;\n  for (let y = 0; y < h; y++) {\n    for (let x = 0; x < w; x++) {\n      if (xoff >= 0 && yoff >= 0) { si = (y * sw + x) << 2; ti = ((yoff + y) * tw + xoff + x) << 2; } else { si = ((-yoff + y) * sw - xoff + x) << 2; ti = (y * tw + x) << 2; }\n\n      if (mode == 0) { tb[ti] = sb[si]; tb[ti + 1] = sb[si + 1]; tb[ti + 2] = sb[si + 2]; tb[ti + 3] = sb[si + 3]; } else if (mode == 1) {\n        var fa = sb[si + 3] * (1 / 255); var fr = sb[si] * fa; var fg = sb[si + 1] * fa; var\n          fb = sb[si + 2] * fa;\n        var ba = tb[ti + 3] * (1 / 255); var br = tb[ti] * ba; var bg = tb[ti + 1] * ba; var\n          bb = tb[ti + 2] * ba;\n\n        const ifa = 1 - fa; const oa = fa + ba * ifa; const\n          ioa = (oa == 0 ? 0 : 1 / oa);\n        tb[ti + 3] = 255 * oa;\n        tb[ti + 0] = (fr + br * ifa) * ioa;\n        tb[ti + 1] = (fg + bg * ifa) * ioa;\n        tb[ti + 2] = (fb + bb * ifa) * ioa;\n      } else if (mode == 2) {\t// copy only differences, otherwise zero\n        var fa = sb[si + 3]; var fr = sb[si]; var fg = sb[si + 1]; var\n          fb = sb[si + 2];\n        var ba = tb[ti + 3]; var br = tb[ti]; var bg = tb[ti + 1]; var\n          bb = tb[ti + 2];\n        if (fa == ba && fr == br && fg == bg && fb == bb) { tb[ti] = 0; tb[ti + 1] = 0; tb[ti + 2] = 0; tb[ti + 3] = 0; } else { tb[ti] = fr; tb[ti + 1] = fg; tb[ti + 2] = fb; tb[ti + 3] = fa; }\n      } else if (mode == 3) {\t// check if can be blended\n        var fa = sb[si + 3]; var fr = sb[si]; var fg = sb[si + 1]; var\n          fb = sb[si + 2];\n        var ba = tb[ti + 3]; var br = tb[ti]; var bg = tb[ti + 1]; var\n          bb = tb[ti + 2];\n        if (fa == ba && fr == br && fg == bg && fb == bb) continue;\n        // if(fa!=255 && ba!=0) return false;\n        if (fa < 220 && ba > 20) return false;\n      }\n    }\n  }\n  return true;\n};\n\nUPNG.encode = function (bufs, w, h, ps, dels, tabs, forbidPlte) {\n  if (ps == null) ps = 0;\n  if (forbidPlte == null) forbidPlte = false;\n\n  const nimg = UPNG.encode.compress(bufs, w, h, ps, [false, false, false, 0, forbidPlte]);\n  UPNG.encode.compressPNG(nimg, -1);\n\n  return UPNG.encode._main(nimg, w, h, dels, tabs);\n};\n\nUPNG.encodeLL = function (bufs, w, h, cc, ac, depth, dels, tabs) {\n  const nimg = { ctype: 0 + (cc == 1 ? 0 : 2) + (ac == 0 ? 0 : 4), depth, frames: [] };\n\n  const time = Date.now();\n  const bipp = (cc + ac) * depth; const\n    bipl = bipp * w;\n  for (let i = 0; i < bufs.length; i++) {\n    nimg.frames.push({\n      rect: {\n        x: 0, y: 0, width: w, height: h,\n      },\n      img: new Uint8Array(bufs[i]),\n      blend: 0,\n      dispose: 1,\n      bpp: Math.ceil(bipp / 8),\n      bpl: Math.ceil(bipl / 8),\n    });\n  }\n\n  UPNG.encode.compressPNG(nimg, 0, true);\n\n  const out = UPNG.encode._main(nimg, w, h, dels, tabs);\n  return out;\n};\n\nUPNG.encode._main = function (nimg, w, h, dels, tabs) {\n  if (tabs == null) tabs = {};\n  const { crc } = UPNG.crc;\n  const wUi = UPNG._bin.writeUint;\n  const wUs = UPNG._bin.writeUshort;\n  const wAs = UPNG._bin.writeASCII;\n  let offset = 8; const anim = nimg.frames.length > 1; let\n    pltAlpha = false;\n\n  let leng = 8 + (16 + 5 + 4) /* + (9+4) */ + (anim ? 20 : 0);\n  if (tabs.sRGB != null) leng += 8 + 1 + 4;\n  if (tabs.pHYs != null) leng += 8 + 9 + 4;\n  if (nimg.ctype == 3) {\n    var dl = nimg.plte.length;\n    for (var i = 0; i < dl; i++) if ((nimg.plte[i] >>> 24) != 255) pltAlpha = true;\n    leng += (8 + dl * 3 + 4) + (pltAlpha ? (8 + dl * 1 + 4) : 0);\n  }\n  for (var j = 0; j < nimg.frames.length; j++) {\n    var fr = nimg.frames[j];\n    if (anim) leng += 38;\n    leng += fr.cimg.length + 12;\n    if (j != 0) leng += 4;\n  }\n  leng += 12;\n\n  const data = new Uint8Array(leng);\n  const wr = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\n  for (var i = 0; i < 8; i++) data[i] = wr[i];\n\n  wUi(data, offset, 13); offset += 4;\n  wAs(data, offset, 'IHDR'); offset += 4;\n  wUi(data, offset, w); offset += 4;\n  wUi(data, offset, h); offset += 4;\n  data[offset] = nimg.depth; offset++; // depth\n  data[offset] = nimg.ctype; offset++; // ctype\n  data[offset] = 0; offset++; // compress\n  data[offset] = 0; offset++; // filter\n  data[offset] = 0; offset++; // interlace\n  wUi(data, offset, crc(data, offset - 17, 17)); offset += 4; // crc\n\n  // 13 bytes to say, that it is sRGB\n  if (tabs.sRGB != null) {\n    wUi(data, offset, 1); offset += 4;\n    wAs(data, offset, 'sRGB'); offset += 4;\n    data[offset] = tabs.sRGB; offset++;\n    wUi(data, offset, crc(data, offset - 5, 5)); offset += 4; // crc\n  }\n  if (tabs.pHYs != null) {\n    wUi(data, offset, 9); offset += 4;\n    wAs(data, offset, 'pHYs'); offset += 4;\n    wUi(data, offset, tabs.pHYs[0]); offset += 4;\n    wUi(data, offset, tabs.pHYs[1]); offset += 4;\n    data[offset] = tabs.pHYs[2];\t\t\toffset++;\n    wUi(data, offset, crc(data, offset - 13, 13)); offset += 4; // crc\n  }\n\n  if (anim) {\n    wUi(data, offset, 8); offset += 4;\n    wAs(data, offset, 'acTL'); offset += 4;\n    wUi(data, offset, nimg.frames.length); offset += 4;\n    wUi(data, offset, tabs.loop != null ? tabs.loop : 0); offset += 4;\n    wUi(data, offset, crc(data, offset - 12, 12)); offset += 4; // crc\n  }\n\n  if (nimg.ctype == 3) {\n    var dl = nimg.plte.length;\n    wUi(data, offset, dl * 3); offset += 4;\n    wAs(data, offset, 'PLTE'); offset += 4;\n    for (var i = 0; i < dl; i++) {\n      const ti = i * 3; const c = nimg.plte[i]; const r = (c) & 255; const g = (c >>> 8) & 255; const\n        b = (c >>> 16) & 255;\n      data[offset + ti + 0] = r; data[offset + ti + 1] = g; data[offset + ti + 2] = b;\n    }\n    offset += dl * 3;\n    wUi(data, offset, crc(data, offset - dl * 3 - 4, dl * 3 + 4)); offset += 4; // crc\n\n    if (pltAlpha) {\n      wUi(data, offset, dl); offset += 4;\n      wAs(data, offset, 'tRNS'); offset += 4;\n      for (var i = 0; i < dl; i++) data[offset + i] = (nimg.plte[i] >>> 24) & 255;\n      offset += dl;\n      wUi(data, offset, crc(data, offset - dl - 4, dl + 4)); offset += 4; // crc\n    }\n  }\n\n  let fi = 0;\n  for (var j = 0; j < nimg.frames.length; j++) {\n    var fr = nimg.frames[j];\n    if (anim) {\n      wUi(data, offset, 26); offset += 4;\n      wAs(data, offset, 'fcTL'); offset += 4;\n      wUi(data, offset, fi++); offset += 4;\n      wUi(data, offset, fr.rect.width); offset += 4;\n      wUi(data, offset, fr.rect.height); offset += 4;\n      wUi(data, offset, fr.rect.x); offset += 4;\n      wUi(data, offset, fr.rect.y); offset += 4;\n      wUs(data, offset, dels[j]); offset += 2;\n      wUs(data, offset, 1000); offset += 2;\n      data[offset] = fr.dispose; offset++;\t// dispose\n      data[offset] = fr.blend; offset++;\t// blend\n      wUi(data, offset, crc(data, offset - 30, 30)); offset += 4; // crc\n    }\n\n    const imgd = fr.cimg; var\n      dl = imgd.length;\n    wUi(data, offset, dl + (j == 0 ? 0 : 4)); offset += 4;\n    const ioff = offset;\n    wAs(data, offset, (j == 0) ? 'IDAT' : 'fdAT'); offset += 4;\n    if (j != 0) { wUi(data, offset, fi++); offset += 4; }\n    data.set(imgd, offset);\n    offset += dl;\n    wUi(data, offset, crc(data, ioff, offset - ioff)); offset += 4; // crc\n  }\n\n  wUi(data, offset, 0); offset += 4;\n  wAs(data, offset, 'IEND'); offset += 4;\n  wUi(data, offset, crc(data, offset - 4, 4)); offset += 4; // crc\n\n  return data.buffer;\n};\n\nUPNG.encode.compressPNG = function (out, filter, levelZero) {\n  for (let i = 0; i < out.frames.length; i++) {\n    const frm = out.frames[i]; const nw = frm.rect.width; const\n      nh = frm.rect.height;\n    const fdata = new Uint8Array(nh * frm.bpl + nh);\n    frm.cimg = UPNG.encode._filterZero(frm.img, nh, frm.bpp, frm.bpl, fdata, filter, levelZero);\n  }\n};\n\nUPNG.encode.compress = function (bufs, w, h, ps, prms) // prms:  onlyBlend, minBits, forbidPlte\n{\n  // var time = Date.now();\n  const onlyBlend = prms[0]; const evenCrd = prms[1]; const forbidPrev = prms[2]; const minBits = prms[3]; const\n    forbidPlte = prms[4];\n\n  let ctype = 6; let depth = 8; let\n    alphaAnd = 255;\n\n  for (var j = 0; j < bufs.length; j++) { // when not quantized, other frames can contain colors, that are not in an initial frame\n    const img = new Uint8Array(bufs[j]); var\n      ilen = img.length;\n    for (var i = 0; i < ilen; i += 4) alphaAnd &= img[i + 3];\n  }\n  const gotAlpha = (alphaAnd != 255);\n\n  // console.log(\"alpha check\", Date.now()-time);  time = Date.now();\n\n  // var brute = gotAlpha && forGIF;\t\t// brute : frames can only be copied, not \"blended\"\n  const frms = UPNG.encode.framize(bufs, w, h, onlyBlend, evenCrd, forbidPrev);\n  // console.log(\"framize\", Date.now()-time);  time = Date.now();\n\n  const cmap = {}; const plte = []; const\n    inds = [];\n\n  if (ps != 0) {\n    const nbufs = []; for (var i = 0; i < frms.length; i++) nbufs.push(frms[i].img.buffer);\n\n    const abuf = UPNG.encode.concatRGBA(nbufs); const\n      qres = UPNG.quantize(abuf, ps); // console.log(qres);\n    let cof = 0; const\n      bb = new Uint8Array(qres.abuf);\n    for (var i = 0; i < frms.length; i++) {\n      var ti = frms[i].img; const\n        bln = ti.length; inds.push(new Uint8Array(qres.inds.buffer, cof >> 2, bln >> 2));\n      for (var j = 0; j < bln; j += 4) { ti[j] = bb[cof + j]; ti[j + 1] = bb[cof + j + 1]; ti[j + 2] = bb[cof + j + 2]; ti[j + 3] = bb[cof + j + 3]; } cof += bln;\n    }\n\n    for (var i = 0; i < qres.plte.length; i++) plte.push(qres.plte[i].est.rgba);\n    // console.log(\"quantize\", Date.now()-time);  time = Date.now();\n  } else {\n    // what if ps==0, but there are <=256 colors?  we still need to detect, if the palette could be used\n    for (var j = 0; j < frms.length; j++) { // when not quantized, other frames can contain colors, that are not in an initial frame\n      var frm = frms[j]; const img32 = new Uint32Array(frm.img.buffer); var nw = frm.rect.width; var\n        ilen = img32.length;\n      const ind = new Uint8Array(ilen); inds.push(ind);\n      for (var i = 0; i < ilen; i++) {\n        const c = img32[i];\n        if (i != 0 && c == img32[i - 1]) ind[i] = ind[i - 1];\n        else if (i > nw && c == img32[i - nw]) ind[i] = ind[i - nw];\n        else {\n          let cmc = cmap[c];\n          if (cmc == null) { cmap[c] = cmc = plte.length; plte.push(c); if (plte.length >= 300) break; }\n          ind[i] = cmc;\n        }\n      }\n    }\n    // console.log(\"make palette\", Date.now()-time);  time = Date.now();\n  }\n\n  const cc = plte.length; // console.log(\"colors:\",cc);\n  if (cc <= 256 && forbidPlte == false) {\n    if (cc <= 2) depth = 1; else if (cc <= 4) depth = 2; else if (cc <= 16) depth = 4; else depth = 8;\n    depth = Math.max(depth, minBits);\n  }\n\n  for (var j = 0; j < frms.length; j++) {\n    var frm = frms[j]; const nx = frm.rect.x; const ny = frm.rect.y; var nw = frm.rect.width; const\n      nh = frm.rect.height;\n    let cimg = frm.img; const\n      cimg32 = new Uint32Array(cimg.buffer);\n    let bpl = 4 * nw; let\n      bpp = 4;\n    if (cc <= 256 && forbidPlte == false) {\n      bpl = Math.ceil(depth * nw / 8);\n      var nimg = new Uint8Array(bpl * nh);\n      const inj = inds[j];\n      for (let y = 0; y < nh; y++) {\n        var i = y * bpl; const\n          ii = y * nw;\n        if (depth == 8) for (var x = 0; x < nw; x++) nimg[i + (x)] = (inj[ii + x]);\n        else if (depth == 4) for (var x = 0; x < nw; x++) nimg[i + (x >> 1)] |= (inj[ii + x] << (4 - (x & 1) * 4));\n        else if (depth == 2) for (var x = 0; x < nw; x++) nimg[i + (x >> 2)] |= (inj[ii + x] << (6 - (x & 3) * 2));\n        else if (depth == 1) for (var x = 0; x < nw; x++) nimg[i + (x >> 3)] |= (inj[ii + x] << (7 - (x & 7) * 1));\n      }\n      cimg = nimg; ctype = 3; bpp = 1;\n    } else if (gotAlpha == false && frms.length == 1) {\t// some next \"reduced\" frames may contain alpha for blending\n      var nimg = new Uint8Array(nw * nh * 3); const\n        area = nw * nh;\n      for (var i = 0; i < area; i++) {\n        var ti = i * 3; const\n          qi = i * 4; nimg[ti] = cimg[qi]; nimg[ti + 1] = cimg[qi + 1]; nimg[ti + 2] = cimg[qi + 2];\n      }\n      cimg = nimg; ctype = 2; bpp = 3; bpl = 3 * nw;\n    }\n    frm.img = cimg; frm.bpl = bpl; frm.bpp = bpp;\n  }\n  // console.log(\"colors => palette indices\", Date.now()-time);  time = Date.now();\n\n  return {\n    ctype, depth, plte, frames: frms,\n  };\n};\nUPNG.encode.framize = function (bufs, w, h, alwaysBlend, evenCrd, forbidPrev) {\n  /*  DISPOSE\n      - 0 : no change\n    - 1 : clear to transparent\n    - 2 : retstore to content before rendering (previous frame disposed)\n    BLEND\n    - 0 : replace\n    - 1 : blend\n  */\n  const frms = [];\n  for (var j = 0; j < bufs.length; j++) {\n    const cimg = new Uint8Array(bufs[j]); const\n      cimg32 = new Uint32Array(cimg.buffer);\n    var nimg;\n\n    let nx = 0; let ny = 0; let nw = w; let nh = h; let\n      blend = alwaysBlend ? 1 : 0;\n    if (j != 0) {\n      const tlim = (forbidPrev || alwaysBlend || j == 1 || frms[j - 2].dispose != 0) ? 1 : 2; let tstp = 0; let\n        tarea = 1e9;\n      for (let it = 0; it < tlim; it++) {\n        var pimg = new Uint8Array(bufs[j - 1 - it]); const\n          p32 = new Uint32Array(bufs[j - 1 - it]);\n        let mix = w; let miy = h; let max = -1; let may = -1;\n        for (let y = 0; y < h; y++) {\n          for (let x = 0; x < w; x++) {\n            var i = y * w + x;\n            if (cimg32[i] != p32[i]) {\n              if (x < mix) mix = x; if (x > max) max = x;\n              if (y < miy) miy = y; if (y > may) may = y;\n            }\n          }\n        }\n        if (max == -1) mix = miy = max = may = 0;\n        if (evenCrd) { if ((mix & 1) == 1)mix--; if ((miy & 1) == 1)miy--; }\n        const sarea = (max - mix + 1) * (may - miy + 1);\n        if (sarea < tarea) {\n          tarea = sarea; tstp = it;\n          nx = mix; ny = miy; nw = max - mix + 1; nh = may - miy + 1;\n        }\n      }\n\n      // alwaysBlend: pokud zjistím, že blendit nelze, nastavím předchozímu snímku dispose=1. Zajistím, aby obsahoval můj obdélník.\n      var pimg = new Uint8Array(bufs[j - 1 - tstp]);\n      if (tstp == 1) frms[j - 1].dispose = 2;\n\n      nimg = new Uint8Array(nw * nh * 4);\n      UPNG._copyTile(pimg, w, h, nimg, nw, nh, -nx, -ny, 0);\n\n      blend = UPNG._copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 3) ? 1 : 0;\n      if (blend == 1) {\n        UPNG.encode._prepareDiff(cimg, w, h, nimg, {\n          x: nx, y: ny, width: nw, height: nh,\n        });\n      } else UPNG._copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 0);\n      // UPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, blend==1?2:0);\n    } else nimg = cimg.slice(0);\t// img may be rewritten further ... don't rewrite input\n\n    frms.push({\n      rect: {\n        x: nx, y: ny, width: nw, height: nh,\n      },\n      img: nimg,\n      blend,\n      dispose: 0,\n    });\n  }\n\n  if (alwaysBlend) {\n    for (var j = 0; j < frms.length; j++) {\n      var frm = frms[j]; if (frm.blend == 1) continue;\n      const r0 = frm.rect; const\n        r1 = frms[j - 1].rect;\n      const miX = Math.min(r0.x, r1.x); const\n        miY = Math.min(r0.y, r1.y);\n      const maX = Math.max(r0.x + r0.width, r1.x + r1.width); const\n        maY = Math.max(r0.y + r0.height, r1.y + r1.height);\n      const r = {\n        x: miX, y: miY, width: maX - miX, height: maY - miY,\n      };\n\n      frms[j - 1].dispose = 1;\n      if (j - 1 != 0) { UPNG.encode._updateFrame(bufs, w, h, frms, j - 1, r, evenCrd); }\n      UPNG.encode._updateFrame(bufs, w, h, frms, j, r, evenCrd);\n    }\n  }\n  let area = 0;\n  if (bufs.length != 1) {\n    for (var i = 0; i < frms.length; i++) {\n      var frm = frms[i];\n      area += frm.rect.width * frm.rect.height;\n    // if(i==0 || frm.blend!=1) continue;\n    // var ob = new Uint8Array(\n    // console.log(frm.blend, frm.dispose, frm.rect);\n    }\n  }\n  // if(area!=0) console.log(area);\n  return frms;\n};\nUPNG.encode._updateFrame = function (bufs, w, h, frms, i, r, evenCrd) {\n  const U8 = Uint8Array; const\n    U32 = Uint32Array;\n  const pimg = new U8(bufs[i - 1]); const pimg32 = new U32(bufs[i - 1]); const\n    nimg = i + 1 < bufs.length ? new U8(bufs[i + 1]) : null;\n  const cimg = new U8(bufs[i]); const\n    cimg32 = new U32(cimg.buffer);\n\n  let mix = w; let miy = h; let max = -1; let may = -1;\n  for (let y = 0; y < r.height; y++) {\n    for (let x = 0; x < r.width; x++) {\n      const cx = r.x + x; const\n        cy = r.y + y;\n      const j = cy * w + cx; const\n        cc = cimg32[j];\n      // no need to draw transparency, or to dispose it. Or, if writing the same color and the next one does not need transparency.\n      if (cc == 0 || (frms[i - 1].dispose == 0 && pimg32[j] == cc && (nimg == null || nimg[j * 4 + 3] != 0))/**/) {} else {\n        if (cx < mix) mix = cx; if (cx > max) max = cx;\n        if (cy < miy) miy = cy; if (cy > may) may = cy;\n      }\n    }\n  }\n  if (max == -1) mix = miy = max = may = 0;\n  if (evenCrd) { if ((mix & 1) == 1)mix--; if ((miy & 1) == 1)miy--; }\n  r = {\n    x: mix, y: miy, width: max - mix + 1, height: may - miy + 1,\n  };\n\n  const fr = frms[i]; fr.rect = r; fr.blend = 1; fr.img = new Uint8Array(r.width * r.height * 4);\n  if (frms[i - 1].dispose == 0) {\n    UPNG._copyTile(pimg, w, h, fr.img, r.width, r.height, -r.x, -r.y, 0);\n    UPNG.encode._prepareDiff(cimg, w, h, fr.img, r);\n    // UPNG._copyTile(cimg,w,h, fr.img,r.width,r.height, -r.x,-r.y, 2);\n  } else { UPNG._copyTile(cimg, w, h, fr.img, r.width, r.height, -r.x, -r.y, 0); }\n};\nUPNG.encode._prepareDiff = function (cimg, w, h, nimg, rec) {\n  UPNG._copyTile(cimg, w, h, nimg, rec.width, rec.height, -rec.x, -rec.y, 2);\n  /*\n  var n32 = new Uint32Array(nimg.buffer);\n  var og = new Uint8Array(rec.width*rec.height*4), o32 = new Uint32Array(og.buffer);\n  UPNG._copyTile(cimg,w,h, og,rec.width,rec.height, -rec.x,-rec.y, 0);\n  for(var i=4; i<nimg.length; i+=4) {\n    if(nimg[i-1]!=0 && nimg[i+3]==0 && o32[i>>>2]==o32[(i>>>2)-1]) {\n      n32[i>>>2]=o32[i>>>2];\n      //var j = i, c=p32[(i>>>2)-1];\n      //while(p32[j>>>2]==c) {  n32[j>>>2]=c;  j+=4;  }\n    }\n  }\n  for(var i=nimg.length-8; i>0; i-=4) {\n    if(nimg[i+7]!=0 && nimg[i+3]==0 && o32[i>>>2]==o32[(i>>>2)+1]) {\n      n32[i>>>2]=o32[i>>>2];\n      //var j = i, c=p32[(i>>>2)-1];\n      //while(p32[j>>>2]==c) {  n32[j>>>2]=c;  j+=4;  }\n    }\n  } */\n};\n\nUPNG.encode._filterZero = function (img, h, bpp, bpl, data, filter, levelZero) {\n  const fls = []; let\n    ftry = [0, 1, 2, 3, 4];\n  if (filter != -1) ftry = [filter];\n  else if (h * bpl > 500000 || bpp == 1) ftry = [0];\n  let opts; if (levelZero) opts = { level: 0 };\n\n  // var CMPR = (data.length>10e6 && typeof UZIP !== 'undefined') ? UZIP : pako;\n  const CMPR = UZIP;\n\n  const time = Date.now();\n  for (var i = 0; i < ftry.length; i++) {\n    for (let y = 0; y < h; y++) UPNG.encode._filterLine(data, img, y, bpl, bpp, ftry[i]);\n    // var nimg = new Uint8Array(data.length);\n    // var sz = UZIP.F.deflate(data, nimg);  fls.push(nimg.slice(0,sz));\n    // var dfl = pako[\"deflate\"](data), dl=dfl.length-4;\n    // var crc = (dfl[dl+3]<<24)|(dfl[dl+2]<<16)|(dfl[dl+1]<<8)|(dfl[dl+0]<<0);\n    // console.log(crc, UZIP.adler(data,2,data.length-6));\n    fls.push(CMPR.deflate(data, opts));\n  }\n\n  let ti; let\n    tsize = 1e9;\n  for (var i = 0; i < fls.length; i++) if (fls[i].length < tsize) { ti = i; tsize = fls[i].length; }\n  return fls[ti];\n};\nUPNG.encode._filterLine = function (data, img, y, bpl, bpp, type) {\n  const i = y * bpl; let di = i + y; const\n    paeth = UPNG.decode._paeth;\n  data[di] = type; di++;\n\n  if (type == 0) {\n    if (bpl < 500) for (var x = 0; x < bpl; x++) data[di + x] = img[i + x];\n    else data.set(new Uint8Array(img.buffer, i, bpl), di);\n  } else if (type == 1) {\n    for (var x = 0; x < bpp; x++) data[di + x] = img[i + x];\n    for (var x = bpp; x < bpl; x++) data[di + x] = (img[i + x] - img[i + x - bpp] + 256) & 255;\n  } else if (y == 0) {\n    for (var x = 0; x < bpp; x++) data[di + x] = img[i + x];\n\n    if (type == 2) for (var x = bpp; x < bpl; x++) data[di + x] = img[i + x];\n    if (type == 3) for (var x = bpp; x < bpl; x++) data[di + x] = (img[i + x] - (img[i + x - bpp] >> 1) + 256) & 255;\n    if (type == 4) for (var x = bpp; x < bpl; x++) data[di + x] = (img[i + x] - paeth(img[i + x - bpp], 0, 0) + 256) & 255;\n  } else {\n    if (type == 2) { for (var x = 0; x < bpl; x++) data[di + x] = (img[i + x] + 256 - img[i + x - bpl]) & 255; }\n    if (type == 3) {\n      for (var x = 0; x < bpp; x++) data[di + x] = (img[i + x] + 256 - (img[i + x - bpl] >> 1)) & 255;\n      for (var x = bpp; x < bpl; x++) data[di + x] = (img[i + x] + 256 - ((img[i + x - bpl] + img[i + x - bpp]) >> 1)) & 255;\n    }\n    if (type == 4) {\n      for (var x = 0; x < bpp; x++) data[di + x] = (img[i + x] + 256 - paeth(0, img[i + x - bpl], 0)) & 255;\n      for (var x = bpp; x < bpl; x++) data[di + x] = (img[i + x] + 256 - paeth(img[i + x - bpp], img[i + x - bpl], img[i + x - bpp - bpl])) & 255;\n    }\n  }\n};\n\nUPNG.crc = {\n  table: (function () {\n    const tab = new Uint32Array(256);\n    for (let n = 0; n < 256; n++) {\n      let c = n;\n      for (let k = 0; k < 8; k++) {\n        if (c & 1) c = 0xedb88320 ^ (c >>> 1);\n        else c >>>= 1;\n      }\n      tab[n] = c;\n    }\n    return tab;\n  }()),\n  update(c, buf, off, len) {\n    for (let i = 0; i < len; i++) c = UPNG.crc.table[(c ^ buf[off + i]) & 0xff] ^ (c >>> 8);\n    return c;\n  },\n  crc(b, o, l) { return UPNG.crc.update(0xffffffff, b, o, l) ^ 0xffffffff; },\n};\n\nUPNG.quantize = function (abuf, ps) {\n  const oimg = new Uint8Array(abuf); const nimg = oimg.slice(0); const\n    nimg32 = new Uint32Array(nimg.buffer);\n\n  const KD = UPNG.quantize.getKDtree(nimg, ps);\n  const root = KD[0]; const\n    leafs = KD[1];\n\n  const { planeDst } = UPNG.quantize;\n  const sb = oimg; const tb = nimg32; const\n    len = sb.length;\n\n  const inds = new Uint8Array(oimg.length >> 2); let\n    nd;\n  if (oimg.length < 20e6) // precise, but slow :(\n  {\n    for (var i = 0; i < len; i += 4) {\n      var r = sb[i] * (1 / 255); var g = sb[i + 1] * (1 / 255); var b = sb[i + 2] * (1 / 255); var\n        a = sb[i + 3] * (1 / 255);\n\n      nd = UPNG.quantize.getNearest(root, r, g, b, a);\n      inds[i >> 2] = nd.ind; tb[i >> 2] = nd.est.rgba;\n    }\n  } else {\n    for (var i = 0; i < len; i += 4) {\n      var r = sb[i] * (1 / 255); var g = sb[i + 1] * (1 / 255); var b = sb[i + 2] * (1 / 255); var\n        a = sb[i + 3] * (1 / 255);\n\n      nd = root; while (nd.left) nd = (planeDst(nd.est, r, g, b, a) <= 0) ? nd.left : nd.right;\n      inds[i >> 2] = nd.ind; tb[i >> 2] = nd.est.rgba;\n    }\n  }\n  return { abuf: nimg.buffer, inds, plte: leafs };\n};\n\nUPNG.quantize.getKDtree = function (nimg, ps, err) {\n  if (err == null) err = 0.0001;\n  const nimg32 = new Uint32Array(nimg.buffer);\n\n  const root = {\n    i0: 0, i1: nimg.length, bst: null, est: null, tdst: 0, left: null, right: null,\n  }; // basic statistic, extra statistic\n  root.bst = UPNG.quantize.stats(nimg, root.i0, root.i1); root.est = UPNG.quantize.estats(root.bst);\n  const leafs = [root];\n\n  while (leafs.length < ps) {\n    let maxL = 0; let\n      mi = 0;\n    for (var i = 0; i < leafs.length; i++) if (leafs[i].est.L > maxL) { maxL = leafs[i].est.L; mi = i; }\n    if (maxL < err) break;\n    const node = leafs[mi];\n\n    const s0 = UPNG.quantize.splitPixels(nimg, nimg32, node.i0, node.i1, node.est.e, node.est.eMq255);\n    const s0wrong = (node.i0 >= s0 || node.i1 <= s0);\n    // console.log(maxL, leafs.length, mi);\n    if (s0wrong) { node.est.L = 0; continue; }\n\n    const ln = {\n      i0: node.i0, i1: s0, bst: null, est: null, tdst: 0, left: null, right: null,\n    }; ln.bst = UPNG.quantize.stats(nimg, ln.i0, ln.i1);\n    ln.est = UPNG.quantize.estats(ln.bst);\n    const rn = {\n      i0: s0, i1: node.i1, bst: null, est: null, tdst: 0, left: null, right: null,\n    }; rn.bst = { R: [], m: [], N: node.bst.N - ln.bst.N };\n    for (var i = 0; i < 16; i++) rn.bst.R[i] = node.bst.R[i] - ln.bst.R[i];\n    for (var i = 0; i < 4; i++) rn.bst.m[i] = node.bst.m[i] - ln.bst.m[i];\n    rn.est = UPNG.quantize.estats(rn.bst);\n\n    node.left = ln; node.right = rn;\n    leafs[mi] = ln; leafs.push(rn);\n  }\n  leafs.sort((a, b) => b.bst.N - a.bst.N);\n  for (var i = 0; i < leafs.length; i++) leafs[i].ind = i;\n  return [root, leafs];\n};\n\nUPNG.quantize.getNearest = function (nd, r, g, b, a) {\n  if (nd.left == null) { nd.tdst = UPNG.quantize.dist(nd.est.q, r, g, b, a); return nd; }\n  const planeDst = UPNG.quantize.planeDst(nd.est, r, g, b, a);\n\n  let node0 = nd.left; let\n    node1 = nd.right;\n  if (planeDst > 0) { node0 = nd.right; node1 = nd.left; }\n\n  const ln = UPNG.quantize.getNearest(node0, r, g, b, a);\n  if (ln.tdst <= planeDst * planeDst) return ln;\n  const rn = UPNG.quantize.getNearest(node1, r, g, b, a);\n  return rn.tdst < ln.tdst ? rn : ln;\n};\nUPNG.quantize.planeDst = function (est, r, g, b, a) { const { e } = est; return e[0] * r + e[1] * g + e[2] * b + e[3] * a - est.eMq; };\nUPNG.quantize.dist = function (q, r, g, b, a) {\n  const d0 = r - q[0]; const d1 = g - q[1]; const d2 = b - q[2]; const\n    d3 = a - q[3]; return d0 * d0 + d1 * d1 + d2 * d2 + d3 * d3;\n};\n\nUPNG.quantize.splitPixels = function (nimg, nimg32, i0, i1, e, eMq) {\n  const { vecDot } = UPNG.quantize;\n  i1 -= 4;\n  const shfs = 0;\n  while (i0 < i1) {\n    while (vecDot(nimg, i0, e) <= eMq) i0 += 4;\n    while (vecDot(nimg, i1, e) > eMq) i1 -= 4;\n    if (i0 >= i1) break;\n\n    const t = nimg32[i0 >> 2]; nimg32[i0 >> 2] = nimg32[i1 >> 2]; nimg32[i1 >> 2] = t;\n\n    i0 += 4; i1 -= 4;\n  }\n  while (vecDot(nimg, i0, e) > eMq) i0 -= 4;\n  return i0 + 4;\n};\nUPNG.quantize.vecDot = function (nimg, i, e) {\n  return nimg[i] * e[0] + nimg[i + 1] * e[1] + nimg[i + 2] * e[2] + nimg[i + 3] * e[3];\n};\nUPNG.quantize.stats = function (nimg, i0, i1) {\n  const R = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n  const m = [0, 0, 0, 0];\n  const N = (i1 - i0) >> 2;\n  for (let i = i0; i < i1; i += 4) {\n    const r = nimg[i] * (1 / 255); const g = nimg[i + 1] * (1 / 255); const b = nimg[i + 2] * (1 / 255); const\n      a = nimg[i + 3] * (1 / 255);\n    // var r = nimg[i], g = nimg[i+1], b = nimg[i+2], a = nimg[i+3];\n    m[0] += r; m[1] += g; m[2] += b; m[3] += a;\n\n    R[0] += r * r; R[1] += r * g; R[2] += r * b; R[3] += r * a;\n    R[5] += g * g; R[6] += g * b; R[7] += g * a;\n    R[10] += b * b; R[11] += b * a;\n    R[15] += a * a;\n  }\n  R[4] = R[1]; R[8] = R[2]; R[9] = R[6]; R[12] = R[3]; R[13] = R[7]; R[14] = R[11];\n\n  return { R, m, N };\n};\nUPNG.quantize.estats = function (stats) {\n  const { R } = stats;\n  const { m } = stats;\n  const { N } = stats;\n\n  // when all samples are equal, but N is large (millions), the Rj can be non-zero ( 0.0003.... - precission error)\n  const m0 = m[0]; const m1 = m[1]; const m2 = m[2]; const m3 = m[3]; const\n    iN = (N == 0 ? 0 : 1 / N);\n  const Rj = [\n    R[0] - m0 * m0 * iN, R[1] - m0 * m1 * iN, R[2] - m0 * m2 * iN, R[3] - m0 * m3 * iN,\n    R[4] - m1 * m0 * iN, R[5] - m1 * m1 * iN, R[6] - m1 * m2 * iN, R[7] - m1 * m3 * iN,\n    R[8] - m2 * m0 * iN, R[9] - m2 * m1 * iN, R[10] - m2 * m2 * iN, R[11] - m2 * m3 * iN,\n    R[12] - m3 * m0 * iN, R[13] - m3 * m1 * iN, R[14] - m3 * m2 * iN, R[15] - m3 * m3 * iN,\n  ];\n\n  const A = Rj; const\n    M = UPNG.M4;\n  let b = [Math.random(), Math.random(), Math.random(), Math.random()]; let mi = 0; let\n    tmi = 0;\n\n  if (N != 0) {\n    for (let i = 0; i < 16; i++) {\n      b = M.multVec(A, b); tmi = Math.sqrt(M.dot(b, b)); b = M.sml(1 / tmi, b);\n      if (i != 0 && Math.abs(tmi - mi) < 1e-9) break; mi = tmi;\n    }\n  }\n  // b = [0,0,1,0];  mi=N;\n  const q = [m0 * iN, m1 * iN, m2 * iN, m3 * iN];\n  const eMq255 = M.dot(M.sml(255, q), b);\n\n  return {\n    Cov: Rj,\n    q,\n    e: b,\n    L: mi,\n    eMq255,\n    eMq: M.dot(b, q),\n    rgba: (((Math.round(255 * q[3]) << 24) | (Math.round(255 * q[2]) << 16) | (Math.round(255 * q[1]) << 8) | (Math.round(255 * q[0]) << 0)) >>> 0),\n  };\n};\nUPNG.M4 = {\n  multVec(m, v) {\n    return [\n      m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3] * v[3],\n      m[4] * v[0] + m[5] * v[1] + m[6] * v[2] + m[7] * v[3],\n      m[8] * v[0] + m[9] * v[1] + m[10] * v[2] + m[11] * v[3],\n      m[12] * v[0] + m[13] * v[1] + m[14] * v[2] + m[15] * v[3],\n    ];\n  },\n  dot(x, y) { return x[0] * y[0] + x[1] * y[1] + x[2] * y[2] + x[3] * y[3]; },\n  sml(a, y) { return [a * y[0], a * y[1], a * y[2], a * y[3]]; },\n};\n\nUPNG.encode.concatRGBA = function (bufs) {\n  let tlen = 0;\n  for (var i = 0; i < bufs.length; i++) tlen += bufs[i].byteLength;\n  const nimg = new Uint8Array(tlen); let\n    noff = 0;\n  for (var i = 0; i < bufs.length; i++) {\n    const img = new Uint8Array(bufs[i]); const\n      il = img.length;\n    for (let j = 0; j < il; j += 4) {\n      let r = img[j]; let g = img[j + 1]; let b = img[j + 2]; const\n        a = img[j + 3];\n      if (a == 0) r = g = b = 0;\n      nimg[noff + j] = r; nimg[noff + j + 1] = g; nimg[noff + j + 2] = b; nimg[noff + j + 3] = a;\n    }\n    noff += il;\n  }\n  return nimg.buffer;\n};\n\nexport default UPNG;\n","export default {\n  CHROME: 'CHROME',\n  FIREFOX: 'FIREFOX',\n  DESKTOP_SAFARI: 'DESKTOP_SAFARI',\n  IE: 'IE',\n  MOBILE_SAFARI: 'MOBILE_SAFARI',\n  ETC: 'ETC',\n};\n","import UPNG from './UPNG';\nimport MAX_CANVAS_SIZE from './config/max-canvas-size';\nimport BROWSER_NAME from './config/browser-name';\n\nconst isBrowser = typeof window !== 'undefined'; // change browser environment to support SSR\n\n// add support for cordova-plugin-file\nconst moduleMapper = isBrowser && window.cordova && window.cordova.require && window.cordova.require('cordova/modulemapper');\nexport const CustomFile = isBrowser && ((moduleMapper && moduleMapper.getOriginalSymbol(window, 'File')) || (typeof window.File !== 'undefined' && File));\nexport const CustomFileReader = isBrowser && ((moduleMapper && moduleMapper.getOriginalSymbol(window, 'FileReader')) || (typeof window.FileReader !== 'undefined' && FileReader));\n\n/**\n * getFilefromDataUrl\n *\n * @param {string} dataUrl\n * @param {string} filename\n * @param {number} [lastModified=Date.now()]\n * @returns {Promise<File | Blob>}\n */\nexport function getFilefromDataUrl(dataUrl, filename, lastModified = Date.now()) {\n  return new Promise((resolve) => {\n    const arr = dataUrl.split(',');\n    const mime = arr[0].match(/:(.*?);/)[1];\n    const bstr = globalThis.atob(arr[1]);\n    let n = bstr.length;\n    const u8arr = new Uint8Array(n);\n    while (n--) {\n      u8arr[n] = bstr.charCodeAt(n);\n    }\n    const file = new Blob([u8arr], { type: mime });\n    file.name = filename;\n    file.lastModified = lastModified;\n    resolve(file);\n\n    // Safari has issue with File constructor not being able to POST in FormData\n    // https://github.com/Donaldcwl/browser-image-compression/issues/8\n    // https://bugs.webkit.org/show_bug.cgi?id=165081\n    // let file\n    // try {\n    //   file = new File([u8arr], filename, { type: mime }) // Edge do not support File constructor\n    // } catch (e) {\n    //   file = new Blob([u8arr], { type: mime })\n    //   file.name = filename\n    //   file.lastModified = lastModified\n    // }\n    // resolve(file)\n  });\n}\n\n/**\n * getDataUrlFromFile\n *\n * @param {File | Blob} file\n * @returns {Promise<string>}\n */\nexport function getDataUrlFromFile(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new CustomFileReader();\n    reader.onload = () => resolve(reader.result);\n    reader.onerror = (e) => reject(e);\n    reader.readAsDataURL(file);\n  });\n}\n\n/**\n * loadImage\n *\n * @param {string} src\n * @returns {Promise<HTMLImageElement>}\n */\nexport function loadImage(src) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = (e) => reject(e);\n    img.src = src;\n  });\n}\n\n/**\n * getBrowserName\n *\n * Extracts the browser name from the useragent.\n *\n * ref: https://stackoverflow.com/a/26358856\n *\n * @returns {string}\n */\nexport function getBrowserName() {\n  if (getBrowserName.cachedResult !== undefined) {\n    return getBrowserName.cachedResult;\n  }\n  let browserName = BROWSER_NAME.ETC;\n  const { userAgent } = navigator;\n  if (/Chrom(e|ium)/i.test(userAgent)) {\n    browserName = BROWSER_NAME.CHROME;\n  } else if (/iP(ad|od|hone)/i.test(userAgent) && /WebKit/i.test(userAgent) && !(/(CriOS|FxiOS|OPiOS|mercury)/i.test(userAgent))) {\n    // see: https://stackoverflow.com/a/35813965\n    browserName = BROWSER_NAME.MOBILE_SAFARI;\n  } else if (/Safari/i.test(userAgent)) {\n    browserName = BROWSER_NAME.DESKTOP_SAFARI;\n  } else if (/Firefox/i.test(userAgent)) {\n    browserName = BROWSER_NAME.FIREFOX;\n  } else if (/MSIE/i.test(userAgent) || (!!document.documentMode) === true) { // IF IE > 10\n    browserName = BROWSER_NAME.IE;\n  }\n  getBrowserName.cachedResult = browserName;\n  return getBrowserName.cachedResult;\n}\n\n/**\n * approximateBelowCanvasMaximumSizeOfBrowser\n *\n * it uses binary search to converge below the browser's maximum Canvas size.\n *\n * @param {number} initWidth\n * @param {number} initHeight\n * @returns {object}\n */\nexport function approximateBelowMaximumCanvasSizeOfBrowser(initWidth, initHeight) {\n  const browserName = getBrowserName();\n  const maximumCanvasSize = MAX_CANVAS_SIZE[browserName];\n\n  let width = initWidth;\n  let height = initHeight;\n  let size = width * height;\n  const ratio = width > height ? height / width : width / height;\n\n  while (size > maximumCanvasSize * maximumCanvasSize) {\n    const halfSizeWidth = (maximumCanvasSize + width) / 2;\n    const halfSizeHeight = (maximumCanvasSize + height) / 2;\n    if (halfSizeWidth < halfSizeHeight) {\n      height = halfSizeHeight;\n      width = halfSizeHeight * ratio;\n    } else {\n      height = halfSizeWidth * ratio;\n      width = halfSizeWidth;\n    }\n\n    size = width * height;\n  }\n\n  return {\n    width, height,\n  };\n}\n\n/**\n * get new Canvas and it's context\n * @param width\n * @param height\n * @returns {[HTMLCanvasElement | OffscreenCanvas, CanvasRenderingContext2D]}\n */\nexport function getNewCanvasAndCtx(width, height) {\n  let canvas;\n  let ctx;\n  try {\n    canvas = new OffscreenCanvas(width, height);\n    ctx = canvas.getContext('2d');\n    if (ctx === null) {\n      throw new Error('getContext of OffscreenCanvas returns null');\n    }\n  } catch (e) {\n    canvas = document.createElement('canvas');\n    ctx = canvas.getContext('2d');\n  }\n  canvas.width = width;\n  canvas.height = height;\n  // ctx.fillStyle = '#fff'\n  // ctx.fillRect(0, 0, width, height)\n  return [canvas, ctx];\n}\n\n/**\n * drawImageInCanvas\n *\n * @param {HTMLImageElement} img\n * @param {string} [fileType=undefined]\n * @returns {HTMLCanvasElement | OffscreenCanvas}\n */\nexport function drawImageInCanvas(img, fileType = undefined) {\n  const { width, height } = approximateBelowMaximumCanvasSizeOfBrowser(img.width, img.height);\n  const [canvas, ctx] = getNewCanvasAndCtx(width, height);\n  if (fileType && /jpe?g/.test(fileType)) {\n    ctx.fillStyle = 'white'; // to fill the transparent background with white color for png file in jpeg extension\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n  }\n  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n  return canvas;\n}\n\n/**\n * Detect IOS device\n * see: https://stackoverflow.com/a/9039885\n * @returns {boolean} isIOS device\n */\nexport function isIOS() {\n  if (isIOS.cachedResult !== undefined) {\n    return isIOS.cachedResult;\n  }\n  isIOS.cachedResult = [\n    'iPad Simulator',\n    'iPhone Simulator',\n    'iPod Simulator',\n    'iPad',\n    'iPhone',\n    'iPod',\n  ].includes(navigator.platform)\n  // iPad on iOS 13 detection\n  || (navigator.userAgent.includes('Mac') && typeof document !== 'undefined' && 'ontouchend' in document);\n  return isIOS.cachedResult;\n}\n\n/**\n * drawFileInCanvas\n *\n * @param {File | Blob} file\n * @returns {Promise<[ImageBitmap | HTMLImageElement, HTMLCanvasElement | OffscreenCanvas]>}\n */\nexport async function drawFileInCanvas(file, options = {}) {\n  let img;\n  try {\n    if (isIOS() || [BROWSER_NAME.DESKTOP_SAFARI, BROWSER_NAME.MOBILE_SAFARI].includes(getBrowserName())) {\n      throw new Error('Skip createImageBitmap on IOS and Safari'); // see https://github.com/Donaldcwl/browser-image-compression/issues/118\n    }\n    img = await createImageBitmap(file);\n  } catch (e) {\n    if (process.env.BUILD === 'development') {\n      console.error(e);\n    }\n    try {\n      const dataUrl = await getDataUrlFromFile(file);\n      img = await loadImage(dataUrl);\n    } catch (e2) {\n      if (process.env.BUILD === 'development') {\n        console.error(e2);\n      }\n      throw e2;\n    }\n  }\n  const canvas = drawImageInCanvas(img, options.fileType || file.type);\n  return [img, canvas];\n}\n\n/**\n * canvasToFile\n *\n * @param {HTMLCanvasElement | OffscreenCanvas} canvas\n * @param {string} fileType\n * @param {string} fileName\n * @param {number} fileLastModified\n * @param {number} [quality]\n * @returns {Promise<File | Blob>}\n */\nexport async function canvasToFile(canvas, fileType, fileName, fileLastModified, quality = 1) {\n  let file;\n  if (fileType === 'image/png') {\n    const ctx = canvas.getContext('2d');\n    const { data } = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const png = UPNG.encode([data], canvas.width, canvas.height, 256 * quality);\n    file = new Blob([png], { type: fileType });\n    file.name = fileName;\n    file.lastModified = fileLastModified;\n  } else if (typeof OffscreenCanvas === 'function' && canvas instanceof OffscreenCanvas) { // checked on Win Chrome 83, MacOS Chrome 83\n    file = await canvas.convertToBlob({ type: fileType, quality });\n    file.name = fileName;\n    file.lastModified = fileLastModified;\n  // some browser do not support quality parameter, see: https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob\n  // } else if (typeof canvas.toBlob === 'function') {\n  //   file = await new Promise(resolve => canvas.toBlob(resolve, fileType, quality))\n  } else { // checked on Win Edge 44, Win IE 11, Win Firefox 76, MacOS Firefox 77, MacOS Safari 13.1\n    const dataUrl = canvas.toDataURL(fileType, quality);\n    file = await getFilefromDataUrl(dataUrl, fileName, fileLastModified);\n  }\n  return file;\n}\n\n/**\n * clear Canvas memory\n * @param canvas\n * @returns null\n */\nexport function cleanupCanvasMemory(canvas) {\n  // garbage clean canvas for safari\n  // ref: https://bugs.webkit.org/show_bug.cgi?id=195325\n  // eslint-disable-next-line no-param-reassign\n  canvas.width = 0;\n  // eslint-disable-next-line no-param-reassign\n  canvas.height = 0;\n}\n\n// Check if browser supports automatic image orientation\n// see https://github.com/blueimp/JavaScript-Load-Image/blob/1e4df707821a0afcc11ea0720ee403b8759f3881/js/load-image-orientation.js#L37-L53\nexport async function isAutoOrientationInBrowser() {\n  if (isAutoOrientationInBrowser.cachedResult !== undefined) return isAutoOrientationInBrowser.cachedResult;\n\n  // black 2x1 JPEG, with the following meta information set:\n  // EXIF Orientation: 6 (Rotated 90° CCW)\n  const testImageURL = 'data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAA'\n    + 'AAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBA'\n    + 'QEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE'\n    + 'BAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/x'\n    + 'ABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAA'\n    + 'AAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q==';\n  const testImageFile = await getFilefromDataUrl(testImageURL, 'test.jpg', Date.now());\n\n  const testImageCanvas = (await drawFileInCanvas(testImageFile))[1];\n  const testImageFile2 = await canvasToFile(testImageCanvas, testImageFile.type, testImageFile.name, testImageFile.lastModified);\n  cleanupCanvasMemory(testImageCanvas);\n  const img = (await drawFileInCanvas(testImageFile2))[0];\n  // console.log('img', img.width, img.height)\n\n  isAutoOrientationInBrowser.cachedResult = img.width === 1 && img.height === 2;\n  return isAutoOrientationInBrowser.cachedResult;\n}\n\n/**\n * getExifOrientation\n * get image exif orientation info\n * source: https://stackoverflow.com/a/32490603/10395024\n *\n * @param {File | Blob} file\n * @returns {Promise<number>} - orientation id, see https://i.stack.imgur.com/VGsAj.gif\n */\nexport function getExifOrientation(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new CustomFileReader();\n    reader.onload = (e) => {\n      const view = new DataView(e.target.result);\n      if (view.getUint16(0, false) != 0xFFD8) {\n        return resolve(-2);\n      }\n      const length = view.byteLength;\n      let offset = 2;\n      while (offset < length) {\n        if (view.getUint16(offset + 2, false) <= 8) return resolve(-1);\n        const marker = view.getUint16(offset, false);\n        offset += 2;\n        if (marker == 0xFFE1) {\n          if (view.getUint32(offset += 2, false) != 0x45786966) {\n            return resolve(-1);\n          }\n\n          const little = view.getUint16(offset += 6, false) == 0x4949;\n          offset += view.getUint32(offset + 4, little);\n          const tags = view.getUint16(offset, little);\n          offset += 2;\n          for (let i = 0; i < tags; i++) {\n            if (view.getUint16(offset + (i * 12), little) == 0x0112) {\n              return resolve(view.getUint16(offset + (i * 12) + 8, little));\n            }\n          }\n        } else if ((marker & 0xFF00) != 0xFF00) {\n          break;\n        } else {\n          offset += view.getUint16(offset, false);\n        }\n      }\n      return resolve(-1);\n    };\n    reader.onerror = (e) => reject(e);\n    reader.readAsArrayBuffer(file);\n  });\n}\n\n/**\n *\n * @param {HTMLCanvasElement | OffscreenCanvas} canvas\n * @param options\n * @returns {HTMLCanvasElement | OffscreenCanvas}\n */\nexport function handleMaxWidthOrHeight(canvas, options) {\n  const { width } = canvas;\n  const { height } = canvas;\n  const { maxWidthOrHeight } = options;\n\n  const needToHandle = isFinite(maxWidthOrHeight) && (width > maxWidthOrHeight || height > maxWidthOrHeight);\n\n  let newCanvas = canvas;\n  let ctx;\n\n  if (needToHandle) {\n    [newCanvas, ctx] = getNewCanvasAndCtx(width, height);\n    if (width > height) {\n      newCanvas.width = maxWidthOrHeight;\n      newCanvas.height = (height / width) * maxWidthOrHeight;\n    } else {\n      newCanvas.width = (width / height) * maxWidthOrHeight;\n      newCanvas.height = maxWidthOrHeight;\n    }\n    ctx.drawImage(canvas, 0, 0, newCanvas.width, newCanvas.height);\n\n    cleanupCanvasMemory(canvas);\n  }\n\n  return newCanvas;\n}\n\n/**\n * followExifOrientation\n * source: https://stackoverflow.com/a/40867559/10395024\n *\n * @param {HTMLCanvasElement | OffscreenCanvas} canvas\n * @param {number} exifOrientation\n * @returns {HTMLCanvasElement | OffscreenCanvas} canvas\n */\nexport function followExifOrientation(canvas, exifOrientation) {\n  const { width } = canvas;\n  const { height } = canvas;\n\n  const [newCanvas, ctx] = getNewCanvasAndCtx(width, height);\n\n  // set proper canvas dimensions before transform & export\n  if (exifOrientation > 4 && exifOrientation < 9) {\n    newCanvas.width = height;\n    newCanvas.height = width;\n  } else {\n    newCanvas.width = width;\n    newCanvas.height = height;\n  }\n\n  // transform context before drawing image\n  switch (exifOrientation) {\n    case 2:\n      ctx.transform(-1, 0, 0, 1, width, 0);\n      break;\n    case 3:\n      ctx.transform(-1, 0, 0, -1, width, height);\n      break;\n    case 4:\n      ctx.transform(1, 0, 0, -1, 0, height);\n      break;\n    case 5:\n      ctx.transform(0, 1, 1, 0, 0, 0);\n      break;\n    case 6:\n      ctx.transform(0, 1, -1, 0, height, 0);\n      break;\n    case 7:\n      ctx.transform(0, -1, -1, 0, height, width);\n      break;\n    case 8:\n      ctx.transform(0, -1, 1, 0, 0, width);\n      break;\n    default:\n      break;\n  }\n\n  ctx.drawImage(canvas, 0, 0, width, height);\n\n  cleanupCanvasMemory(canvas);\n\n  return newCanvas;\n}\n","import {\n  canvasToFile,\n  cleanupCanvasMemory,\n  drawFileInCanvas,\n  followExifOrientation,\n  getExifOrientation,\n  getNewCanvasAndCtx,\n  handleMaxWidthOrHeight,\n  isAutoOrientationInBrowser,\n} from './utils';\n\n/**\n * Compress an image file.\n *\n * @param {File} file\n * @param {Object} options\n * @param {number} [options.maxSizeMB=Number.POSITIVE_INFINITY]\n * @param {number} [options.maxWidthOrHeight=undefined]\n * @param {boolean} [options.useWebWorker=true]\n * @param {number} [options.maxIteration=10]\n * @param {number} [options.exifOrientation] - default to be the exif orientation from the image file\n * @param {Function} [options.onProgress] - a function takes one progress argument (progress from 0 to 100)\n * @param {string} [options.fileType] - default to be the original mime type from the image file\n * @param {number} [options.initialQuality=1.0]\n * @param {boolean} [options.alwaysKeepResolution=false]\n * @param {AbortSignal} [options.signal]\n * @param {number} previousProgress - for internal try catch rerunning start from previous progress\n * @returns {Promise<File | Blob>}\n */\nexport default async function compress(file, options, previousProgress = 0) {\n  let progress = previousProgress;\n\n  function incProgress(inc = 5) {\n    if (options.signal && options.signal.aborted) {\n      throw options.signal.reason;\n    }\n    progress += inc;\n    options.onProgress(Math.min(progress, 100));\n  }\n\n  function setProgress(p) {\n    if (options.signal && options.signal.aborted) {\n      throw options.signal.reason;\n    }\n    progress = Math.min(Math.max(p, progress), 100);\n    options.onProgress(progress);\n  }\n\n  let remainingTrials = options.maxIteration || 10;\n\n  const maxSizeByte = options.maxSizeMB * 1024 * 1024;\n\n  incProgress();\n\n  // drawFileInCanvas\n  const [, origCanvas] = await drawFileInCanvas(file, options);\n\n  incProgress();\n\n  // handleMaxWidthOrHeight\n  const maxWidthOrHeightFixedCanvas = handleMaxWidthOrHeight(origCanvas, options);\n\n  incProgress();\n\n  // exifOrientation\n  const exifOrientation = options.exifOrientation || await getExifOrientation(file);\n  incProgress();\n  const orientationFixedCanvas = (await isAutoOrientationInBrowser()) ? maxWidthOrHeightFixedCanvas : followExifOrientation(maxWidthOrHeightFixedCanvas, exifOrientation);\n  incProgress();\n\n  let quality = options.initialQuality || 1.0;\n\n  const outputFileType = options.fileType || file.type;\n\n  const tempFile = await canvasToFile(orientationFixedCanvas, outputFileType, file.name, file.lastModified, quality);\n  incProgress();\n\n  const origExceedMaxSize = tempFile.size > maxSizeByte;\n  const sizeBecomeLarger = tempFile.size > file.size;\n  if (process.env.BUILD === 'development') {\n    console.log('original file size', file.size);\n    console.log('current file size', tempFile.size);\n  }\n\n  // check if we need to compress or resize\n  if (!origExceedMaxSize && !sizeBecomeLarger) {\n    // no need to compress\n    if (process.env.BUILD === 'development') {\n      console.log('no need to compress');\n    }\n    setProgress(100);\n    return tempFile;\n  }\n\n  const sourceSize = file.size;\n  const renderedSize = tempFile.size;\n  let currentSize = renderedSize;\n  let compressedFile;\n  let newCanvas;\n  let ctx;\n  let canvas = orientationFixedCanvas;\n  const shouldReduceResolution = !options.alwaysKeepResolution && origExceedMaxSize;\n  while (remainingTrials-- && (currentSize > maxSizeByte || currentSize > sourceSize)) {\n    const newWidth = shouldReduceResolution ? canvas.width * 0.95 : canvas.width;\n    const newHeight = shouldReduceResolution ? canvas.height * 0.95 : canvas.height;\n    if (process.env.BUILD === 'development') {\n      console.log('current width', newWidth);\n      console.log('current height', newHeight);\n      console.log('current quality', quality);\n    }\n    [newCanvas, ctx] = getNewCanvasAndCtx(newWidth, newHeight);\n\n    ctx.drawImage(canvas, 0, 0, newWidth, newHeight);\n\n    quality *= 0.95;\n    // eslint-disable-next-line no-await-in-loop\n    compressedFile = await canvasToFile(newCanvas, outputFileType, file.name, file.lastModified, quality);\n\n    cleanupCanvasMemory(canvas);\n\n    canvas = newCanvas;\n\n    currentSize = compressedFile.size;\n    // console.log('currentSize', currentSize)\n    setProgress(Math.min(99, Math.floor(((renderedSize - currentSize) / (renderedSize - maxSizeByte)) * 100)));\n  }\n\n  cleanupCanvasMemory(canvas);\n  cleanupCanvasMemory(newCanvas);\n  cleanupCanvasMemory(maxWidthOrHeightFixedCanvas);\n  cleanupCanvasMemory(orientationFixedCanvas);\n  cleanupCanvasMemory(origCanvas);\n\n  setProgress(100);\n  return compressedFile;\n}\n","import * as UZIP from 'uzip';\n// eslint-disable-next-line import/no-cycle\nimport lib from './index';\nimport compress from './image-compression';\nimport { getNewCanvasAndCtx, isIOS } from './utils';\nimport UPNG from './UPNG';\nimport MAX_CANVAS_SIZE from './config/max-canvas-size';\nimport BROWSER_NAME from './config/browser-name';\n\nlet cnt = 0;\nlet imageCompressionLibUrl;\nlet worker;\n\nfunction createWorker(script) {\n  const blobArgs = [];\n  if (typeof script === 'function') {\n    blobArgs.push(`(${script})()`);\n  } else {\n    blobArgs.push(script);\n  }\n  return new Worker(URL.createObjectURL(new Blob(blobArgs)));\n}\n\nfunction createSourceObject(str) {\n  // console.log('createSourceObject', str)\n  return URL.createObjectURL(new Blob([str], { type: 'application/javascript' }));\n}\n\nfunction stringify(o) {\n  return JSON.stringify(o, (key, value) => ((typeof value === 'function') ? `BIC_FN:::(function () { return ${value.toString()} })()` : value));\n}\n\nfunction parse(o) {\n  if (typeof o === 'string') return o;\n  const result = {};\n  Object.entries(o).forEach(([key, value]) => {\n    if (typeof value === 'string' && value.startsWith('BIC_FN:::')) {\n      try {\n        // eslint-disable-next-line no-eval\n        result[key] = eval(value.replace(/^BIC_FN:::/, ''));\n      } catch (e) {\n        if (process.env.BUILD === 'development') {\n          console.error(key, e);\n        }\n        throw e;\n      }\n    } else {\n      result[key] = parse(value);\n    }\n  });\n  return result;\n}\n\nfunction generateLib() {\n  // prepare the lib to be used inside WebWorker\n  return createSourceObject(`\n    // reconstruct library\n    function imageCompression (){return (${lib}).apply(null, arguments)}\n\n    imageCompression.getDataUrlFromFile = ${lib.getDataUrlFromFile}\n    imageCompression.getFilefromDataUrl = ${lib.getFilefromDataUrl}\n    imageCompression.loadImage = ${lib.loadImage}\n    imageCompression.drawImageInCanvas = ${lib.drawImageInCanvas}\n    imageCompression.drawFileInCanvas = ${lib.drawFileInCanvas}\n    imageCompression.canvasToFile = ${lib.canvasToFile}\n    imageCompression.getExifOrientation = ${lib.getExifOrientation}\n    imageCompression.handleMaxWidthOrHeight = ${lib.handleMaxWidthOrHeight}\n    imageCompression.followExifOrientation = ${lib.followExifOrientation}\n    imageCompression.cleanupCanvasMemory = ${lib.cleanupCanvasMemory}\n    imageCompression.isAutoOrientationInBrowser = ${lib.isAutoOrientationInBrowser}\n    imageCompression.approximateBelowMaximumCanvasSizeOfBrowser = ${lib.approximateBelowMaximumCanvasSizeOfBrowser}\n    imageCompression.getBrowserName = ${lib.getBrowserName}\n\n    // functions / objects\n    getDataUrlFromFile = imageCompression.getDataUrlFromFile\n    getFilefromDataUrl = imageCompression.getFilefromDataUrl\n    loadImage = imageCompression.loadImage\n    drawImageInCanvas = imageCompression.drawImageInCanvas\n    drawFileInCanvas = imageCompression.drawFileInCanvas\n    canvasToFile = imageCompression.canvasToFile\n    getExifOrientation = imageCompression.getExifOrientation\n    handleMaxWidthOrHeight = imageCompression.handleMaxWidthOrHeight\n    followExifOrientation = imageCompression.followExifOrientation\n    cleanupCanvasMemory = imageCompression.cleanupCanvasMemory\n    isAutoOrientationInBrowser = imageCompression.isAutoOrientationInBrowser\n    approximateBelowMaximumCanvasSizeOfBrowser = imageCompression.approximateBelowMaximumCanvasSizeOfBrowser\n    getBrowserName = imageCompression.getBrowserName\n    isIOS = ${isIOS}\n    \n    getNewCanvasAndCtx = ${getNewCanvasAndCtx}\n    CustomFileReader = FileReader\n    CustomFile = File\n    MAX_CANVAS_SIZE = ${JSON.stringify(MAX_CANVAS_SIZE)}\n    BROWSER_NAME = ${JSON.stringify(BROWSER_NAME)}\n    function compress (){return (${compress}).apply(null, arguments)}\n\n    // core-js\n    function _slicedToArray(arr, n) { return arr }\n    function _typeof(a) { return typeof a }\n    function _objectSpread2(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i] != null ? arguments[i] : {};\n  \n        Object.assign(target, source)\n      }\n  \n      return target;\n    }\n\n    // Libraries\n    const parse = ${parse}\n    const UPNG = {}\n    UPNG.toRGBA8 = ${UPNG.toRGBA8}\n    UPNG.toRGBA8.decodeImage = ${UPNG.toRGBA8.decodeImage}\n    UPNG.decode = ${UPNG.decode}\n    UPNG.decode._decompress = ${UPNG.decode._decompress}\n    UPNG.decode._inflate = ${UPNG.decode._inflate}\n    UPNG.decode._readInterlace = ${UPNG.decode._readInterlace}\n    UPNG.decode._getBPP = ${UPNG.decode._getBPP} \n    UPNG.decode._filterZero = ${UPNG.decode._filterZero}\n    UPNG.decode._paeth = ${UPNG.decode._paeth}\n    UPNG.decode._IHDR = ${UPNG.decode._IHDR}\n    UPNG._bin = parse(${stringify(UPNG._bin)})\n    UPNG._copyTile = ${UPNG._copyTile}\n    UPNG.encode = ${UPNG.encode}\n    UPNG.encodeLL = ${UPNG.encodeLL} \n    UPNG.encode._main = ${UPNG.encode._main}\n    UPNG.encode.compressPNG = ${UPNG.encode.compressPNG} \n    UPNG.encode.compress = ${UPNG.encode.compress}\n    UPNG.encode.framize = ${UPNG.encode.framize} \n    UPNG.encode._updateFrame = ${UPNG.encode._updateFrame} \n    UPNG.encode._prepareDiff = ${UPNG.encode._prepareDiff} \n    UPNG.encode._filterZero = ${UPNG.encode._filterZero} \n    UPNG.encode._filterLine = ${UPNG.encode._filterLine}\n    UPNG.encode.concatRGBA = ${UPNG.encode.concatRGBA}\n    UPNG.crc = parse(${stringify(UPNG.crc)})\n    UPNG.crc.table = ( function() {\n    var tab = new Uint32Array(256);\n    for (var n=0; n<256; n++) {\n      var c = n;\n      for (var k=0; k<8; k++) {\n        if (c & 1)  c = 0xedb88320 ^ (c >>> 1);\n        else        c = c >>> 1;\n      }\n      tab[n] = c;  }\n    return tab;  })()\n    UPNG.quantize = ${UPNG.quantize} \n    UPNG.quantize.getKDtree = ${UPNG.quantize.getKDtree} \n    UPNG.quantize.getNearest = ${UPNG.quantize.getNearest} \n    UPNG.quantize.planeDst = ${UPNG.quantize.planeDst} \n    UPNG.quantize.dist = ${UPNG.quantize.dist}     \n    UPNG.quantize.splitPixels = ${UPNG.quantize.splitPixels} \n    UPNG.quantize.vecDot = ${UPNG.quantize.vecDot} \n    UPNG.quantize.stats = ${UPNG.quantize.stats} \n    UPNG.quantize.estats = ${UPNG.quantize.estats}\n    UPNG.M4 = parse(${stringify(UPNG.M4)})\n    UPNG.encode.concatRGBA = ${UPNG.encode.concatRGBA}\n    UPNG.inflateRaw=function(){\n    var H={};H.H={};H.H.N=function(N,W){var R=Uint8Array,i=0,m=0,J=0,h=0,Q=0,X=0,u=0,w=0,d=0,v,C;\n      if(N[0]==3&&N[1]==0)return W?W:new R(0);var V=H.H,n=V.b,A=V.e,l=V.R,M=V.n,I=V.A,e=V.Z,b=V.m,Z=W==null;\n      if(Z)W=new R(N.length>>>2<<5);while(i==0){i=n(N,d,1);m=n(N,d+1,2);d+=3;if(m==0){if((d&7)!=0)d+=8-(d&7);\n        var D=(d>>>3)+4,q=N[D-4]|N[D-3]<<8;if(Z)W=H.H.W(W,w+q);W.set(new R(N.buffer,N.byteOffset+D,q),w);d=D+q<<3;\n        w+=q;continue}if(Z)W=H.H.W(W,w+(1<<17));if(m==1){v=b.J;C=b.h;X=(1<<9)-1;u=(1<<5)-1}if(m==2){J=A(N,d,5)+257;\n        h=A(N,d+5,5)+1;Q=A(N,d+10,4)+4;d+=14;var E=d,j=1;for(var c=0;c<38;c+=2){b.Q[c]=0;b.Q[c+1]=0}for(var c=0;\n                                                                                                        c<Q;c++){var K=A(N,d+c*3,3);b.Q[(b.X[c]<<1)+1]=K;if(K>j)j=K}d+=3*Q;M(b.Q,j);I(b.Q,j,b.u);v=b.w;C=b.d;\n        d=l(b.u,(1<<j)-1,J+h,N,d,b.v);var r=V.V(b.v,0,J,b.C);X=(1<<r)-1;var S=V.V(b.v,J,h,b.D);u=(1<<S)-1;M(b.C,r);\n        I(b.C,r,v);M(b.D,S);I(b.D,S,C)}while(!0){var T=v[e(N,d)&X];d+=T&15;var p=T>>>4;if(p>>>8==0){W[w++]=p}else if(p==256){break}else{var z=w+p-254;\n        if(p>264){var _=b.q[p-257];z=w+(_>>>3)+A(N,d,_&7);d+=_&7}var $=C[e(N,d)&u];d+=$&15;var s=$>>>4,Y=b.c[s],a=(Y>>>4)+n(N,d,Y&15);\n        d+=Y&15;while(w<z){W[w]=W[w++-a];W[w]=W[w++-a];W[w]=W[w++-a];W[w]=W[w++-a]}w=z}}}return W.length==w?W:W.slice(0,w)};\n      H.H.W=function(N,W){var R=N.length;if(W<=R)return N;var V=new Uint8Array(R<<1);V.set(N,0);return V};\n      H.H.R=function(N,W,R,V,n,A){var l=H.H.e,M=H.H.Z,I=0;while(I<R){var e=N[M(V,n)&W];n+=e&15;var b=e>>>4;\n        if(b<=15){A[I]=b;I++}else{var Z=0,m=0;if(b==16){m=3+l(V,n,2);n+=2;Z=A[I-1]}else if(b==17){m=3+l(V,n,3);\n          n+=3}else if(b==18){m=11+l(V,n,7);n+=7}var J=I+m;while(I<J){A[I]=Z;I++}}}return n};H.H.V=function(N,W,R,V){var n=0,A=0,l=V.length>>>1;\n        while(A<R){var M=N[A+W];V[A<<1]=0;V[(A<<1)+1]=M;if(M>n)n=M;A++}while(A<l){V[A<<1]=0;V[(A<<1)+1]=0;A++}return n};\n      H.H.n=function(N,W){var R=H.H.m,V=N.length,n,A,l,M,I,e=R.j;for(var M=0;M<=W;M++)e[M]=0;for(M=1;M<V;M+=2)e[N[M]]++;\n        var b=R.K;n=0;e[0]=0;for(A=1;A<=W;A++){n=n+e[A-1]<<1;b[A]=n}for(l=0;l<V;l+=2){I=N[l+1];if(I!=0){N[l]=b[I];\n          b[I]++}}};H.H.A=function(N,W,R){var V=N.length,n=H.H.m,A=n.r;for(var l=0;l<V;l+=2)if(N[l+1]!=0){var M=l>>1,I=N[l+1],e=M<<4|I,b=W-I,Z=N[l]<<b,m=Z+(1<<b);\n        while(Z!=m){var J=A[Z]>>>15-W;R[J]=e;Z++}}};H.H.l=function(N,W){var R=H.H.m.r,V=15-W;for(var n=0;n<N.length;\n                                                                                                 n+=2){var A=N[n]<<W-N[n+1];N[n]=R[A]>>>V}};H.H.M=function(N,W,R){R=R<<(W&7);var V=W>>>3;N[V]|=R;N[V+1]|=R>>>8};\n      H.H.I=function(N,W,R){R=R<<(W&7);var V=W>>>3;N[V]|=R;N[V+1]|=R>>>8;N[V+2]|=R>>>16};H.H.e=function(N,W,R){return(N[W>>>3]|N[(W>>>3)+1]<<8)>>>(W&7)&(1<<R)-1};\n      H.H.b=function(N,W,R){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16)>>>(W&7)&(1<<R)-1};H.H.Z=function(N,W){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16)>>>(W&7)};\n      H.H.i=function(N,W){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16|N[(W>>>3)+3]<<24)>>>(W&7)};H.H.m=function(){var N=Uint16Array,W=Uint32Array;\n        return{K:new N(16),j:new N(16),X:[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],S:[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],T:[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0],q:new N(32),p:[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,65535,65535],z:[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0],c:new W(32),J:new N(512),_:[],h:new N(32),$:[],w:new N(32768),C:[],v:[],d:new N(32768),D:[],u:new N(512),Q:[],r:new N(1<<15),s:new W(286),Y:new W(30),a:new W(19),t:new W(15e3),k:new N(1<<16),g:new N(1<<15)}}();\n      (function(){var N=H.H.m,W=1<<15;for(var R=0;R<W;R++){var V=R;V=(V&2863311530)>>>1|(V&1431655765)<<1;\n        V=(V&3435973836)>>>2|(V&858993459)<<2;V=(V&4042322160)>>>4|(V&252645135)<<4;V=(V&4278255360)>>>8|(V&16711935)<<8;\n        N.r[R]=(V>>>16|V<<16)>>>17}function n(A,l,M){while(l--!=0)A.push(0,M)}for(var R=0;R<32;R++){N.q[R]=N.S[R]<<3|N.T[R];\n        N.c[R]=N.p[R]<<4|N.z[R]}n(N._,144,8);n(N._,255-143,9);n(N._,279-255,7);n(N._,287-279,8);H.H.n(N._,9);\n        H.H.A(N._,9,N.J);H.H.l(N._,9);n(N.$,32,5);H.H.n(N.$,5);H.H.A(N.$,5,N.h);H.H.l(N.$,5);n(N.Q,19,0);n(N.C,286,0);\n        n(N.D,30,0);n(N.v,320,0)}());return H.H.N}()\n    \n    const UZIP = {}\n    UZIP[\"parse\"] = ${UZIP.parse}\n    UZIP._readLocal = ${UZIP._readLocal}\n    UZIP.inflateRaw = ${UZIP.inflateRaw}\n    UZIP.inflate = ${UZIP.inflate}\n    UZIP.deflate = ${UZIP.deflate}\n    UZIP.deflateRaw = ${UZIP.deflateRaw}\n    UZIP.encode = ${UZIP.encode}\n    UZIP._noNeed = ${UZIP._noNeed}\n    UZIP._writeHeader = ${UZIP._writeHeader}\n    UZIP.crc = parse(${stringify(UZIP.crc)})\n    UZIP.crc.table = ( function() {\n      var tab = new Uint32Array(256);\n      for (var n=0; n<256; n++) {\n        var c = n;\n        for (var k=0; k<8; k++) {\n          if (c & 1)  c = 0xedb88320 ^ (c >>> 1);\n          else        c = c >>> 1;\n        }\n        tab[n] = c;  }\n      return tab;  })()\n    \n    UZIP.adler = ${UZIP.adler}\n    UZIP.bin = parse(${stringify(UZIP.bin)})\n    UZIP.F = {}\n    UZIP.F.deflateRaw = ${UZIP.F.deflateRaw}\n    UZIP.F._bestMatch = ${UZIP.F._bestMatch}\n    UZIP.F._howLong = ${UZIP.F._howLong}\n    UZIP.F._hash = ${UZIP.F._hash}\n    UZIP.saved = ${UZIP.saved}\n    UZIP.F._writeBlock = ${UZIP.F._writeBlock}\n    UZIP.F._copyExact = ${UZIP.F._copyExact}\n    UZIP.F.getTrees = ${UZIP.F.getTrees}\n    UZIP.F.getSecond = ${UZIP.F.getSecond}\n    UZIP.F.nonZero = ${UZIP.F.nonZero}\n    UZIP.F.contSize = ${UZIP.F.contSize}\n    UZIP.F._codeTiny = ${UZIP.F._codeTiny} \n    UZIP.F._lenCodes = ${UZIP.F._lenCodes} \n    UZIP.F._hufTree = ${UZIP.F._hufTree} \n    UZIP.F.setDepth = ${UZIP.F.setDepth} \n    UZIP.F.restrictDepth = ${UZIP.F.restrictDepth}\n    UZIP.F._goodIndex = ${UZIP.F._goodIndex} \n    UZIP.F._writeLit = ${UZIP.F._writeLit} \n    UZIP.F.inflate = ${UZIP.F.inflate} \n    UZIP.F._check = ${UZIP.F._check} \n    UZIP.F._decodeTiny = ${UZIP.F._decodeTiny} \n    UZIP.F._copyOut = ${UZIP.F._copyOut} \n    UZIP.F.makeCodes = ${UZIP.F.makeCodes} \n    UZIP.F.codes2map = ${UZIP.F.codes2map} \n    UZIP.F.revCodes = ${UZIP.F.revCodes} \n\n    // used only in deflate\n    UZIP.F._putsE = ${UZIP.F._putsE}\n    UZIP.F._putsF = ${UZIP.F._putsF}\n  \n    UZIP.F._bitsE = ${UZIP.F._bitsE}\n    UZIP.F._bitsF = ${UZIP.F._bitsF}\n\n    UZIP.F._get17 = ${UZIP.F._get17}\n    UZIP.F._get25 = ${UZIP.F._get25}\n    UZIP.F.U = function(){\n      var u16=Uint16Array, u32=Uint32Array;\n      return {\n        next_code : new u16(16),\n        bl_count  : new u16(16),\n        ordr : [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ],\n        of0  : [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],\n        exb  : [0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0,  0,  0,  0],\n        ldef : new u16(32),\n        df0  : [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 65535, 65535],\n        dxb  : [0,0,0,0,1,1,2, 2, 3, 3, 4, 4, 5, 5,  6,  6,  7,  7,  8,  8,   9,   9,  10,  10,  11,  11,  12,   12,   13,   13,     0,     0],\n        ddef : new u32(32),\n        flmap: new u16(  512),  fltree: [],\n        fdmap: new u16(   32),  fdtree: [],\n        lmap : new u16(32768),  ltree : [],  ttree:[],\n        dmap : new u16(32768),  dtree : [],\n        imap : new u16(  512),  itree : [],\n        //rev9 : new u16(  512)\n        rev15: new u16(1<<15),\n        lhst : new u32(286), dhst : new u32( 30), ihst : new u32(19),\n        lits : new u32(15000),\n        strt : new u16(1<<16),\n        prev : new u16(1<<15)\n      };\n    } ();\n\n    (function(){\n      var U = UZIP.F.U;\n      var len = 1<<15;\n      for(var i=0; i<len; i++) {\n        var x = i;\n        x = (((x & 0xaaaaaaaa) >>> 1) | ((x & 0x55555555) << 1));\n        x = (((x & 0xcccccccc) >>> 2) | ((x & 0x33333333) << 2));\n        x = (((x & 0xf0f0f0f0) >>> 4) | ((x & 0x0f0f0f0f) << 4));\n        x = (((x & 0xff00ff00) >>> 8) | ((x & 0x00ff00ff) << 8));\n        U.rev15[i] = (((x >>> 16) | (x << 16)))>>>17;\n      }\n  \n      function pushV(tgt, n, sv) {  while(n--!=0) tgt.push(0,sv);  }\n  \n      for(var i=0; i<32; i++) {  U.ldef[i]=(U.of0[i]<<3)|U.exb[i];  U.ddef[i]=(U.df0[i]<<4)|U.dxb[i];  }\n  \n      pushV(U.fltree, 144, 8);  pushV(U.fltree, 255-143, 9);  pushV(U.fltree, 279-255, 7);  pushV(U.fltree,287-279,8);\n      /*\n        var i = 0;\n        for(; i<=143; i++) U.fltree.push(0,8);\n        for(; i<=255; i++) U.fltree.push(0,9);\n        for(; i<=279; i++) U.fltree.push(0,7);\n        for(; i<=287; i++) U.fltree.push(0,8);\n        */\n      UZIP.F.makeCodes(U.fltree, 9);\n      UZIP.F.codes2map(U.fltree, 9, U.flmap);\n      UZIP.F.revCodes (U.fltree, 9)\n  \n      pushV(U.fdtree,32,5);\n      //for(i=0;i<32; i++) U.fdtree.push(0,5);\n      UZIP.F.makeCodes(U.fdtree, 5);\n      UZIP.F.codes2map(U.fdtree, 5, U.fdmap);\n      UZIP.F.revCodes (U.fdtree, 5)\n  \n      pushV(U.itree,19,0);  pushV(U.ltree,286,0);  pushV(U.dtree,30,0);  pushV(U.ttree,320,0);\n      /*\n        for(var i=0; i< 19; i++) U.itree.push(0,0);\n        for(var i=0; i<286; i++) U.ltree.push(0,0);\n        for(var i=0; i< 30; i++) U.dtree.push(0,0);\n        for(var i=0; i<320; i++) U.ttree.push(0,0);\n        */\n    })()\n    `);\n}\n\nfunction generateWorkerScript() {\n  // code to be run in the WebWorker\n  return createWorker(`\n    let scriptImported = false\n    self.addEventListener('message', async (e) => {\n      const { file, id, imageCompressionLibUrl, options } = e.data\n      options.onProgress = (progress) => self.postMessage({ progress, id })\n      try {\n        if (!scriptImported) {\n          // console.log('[worker] importScripts', imageCompressionLibUrl)\n          self.importScripts(imageCompressionLibUrl)\n          scriptImported = true\n        }\n        // console.log('[worker] self', self)\n        const compressedFile = await imageCompression(file, options)\n        self.postMessage({ file: compressedFile, id })\n      } catch (e) {\n        // console.error('[worker] error', e)\n        self.postMessage({ error: e.message + '\\\\n' + e.stack, id })\n      }\n    })\n  `);\n}\n\nexport default function compressOnWebWorker(file, options) {\n  return new Promise((resolve, reject) => {\n    cnt += 1;\n    const id = cnt;\n\n    if (!imageCompressionLibUrl) {\n      imageCompressionLibUrl = generateLib();\n    }\n\n    if (!worker) {\n      worker = generateWorkerScript();\n    }\n\n    function handler(e) {\n      if (e.data.id === id) {\n        if (options.signal && options.signal.aborted) {\n          return;\n        }\n        if (e.data.progress !== undefined) {\n          options.onProgress(e.data.progress);\n          return;\n        }\n        worker.removeEventListener('message', handler);\n        if (e.data.error) {\n          reject(new Error(e.data.error));\n        }\n        resolve(e.data.file);\n      }\n    }\n\n    worker.addEventListener('message', handler);\n    worker.addEventListener('error', reject);\n    if (options.signal) {\n      options.signal.addEventListener('abort', () => {\n        worker.terminate();\n        reject(options.signal.reason);\n      });\n    }\n\n    worker.postMessage({\n      file,\n      id,\n      imageCompressionLibUrl,\n      options: { ...options, onProgress: undefined, signal: undefined },\n    });\n  });\n}\n","import compress from './image-compression';\nimport {\n  canvasToFile,\n  drawFileInCanvas,\n  drawImageInCanvas,\n  getDataUrlFromFile,\n  getFilefromDataUrl,\n  loadImage,\n  getExifOrientation,\n  handleMaxWidthOrHeight,\n  followExifOrientation,\n  CustomFile,\n  cleanupCanvasMemory,\n  isAutoOrientationInBrowser,\n  approximateBelowMaximumCanvasSizeOfBrowser,\n  getBrowserName,\n} from './utils';\n// eslint-disable-next-line import/no-cycle\nimport compressOnWebWorker from './web-worker';\n\n/**\n * Compress an image file.\n *\n * @param {File} file\n * @param {Object} options - { maxSizeMB=Number.POSITIVE_INFINITY, maxWidthOrHeight, useWebWorker=false, maxIteration = 10, exifOrientation, fileType }\n * @param {number} [options.maxSizeMB=Number.POSITIVE_INFINITY]\n * @param {number} [options.maxWidthOrHeight=undefined]\n * @param {boolean} [options.useWebWorker=true]\n * @param {number} [options.maxIteration=10]\n * @param {number} [options.exifOrientation] - default to be the exif orientation from the image file\n * @param {Function} [options.onProgress] - a function takes one progress argument (progress from 0 to 100)\n * @param {string} [options.fileType] - default to be the original mime type from the image file\n * @param {number} [options.initialQuality=1.0]\n * @param {boolean} [options.alwaysKeepResolution=false]\n * @param {AbortSignal} [options.signal]\n * @returns {Promise<File | Blob>}\n */\nasync function imageCompression(file, options) {\n  const opts = { ...options };\n\n  let compressedFile;\n  let progress = 0;\n  const { onProgress } = opts;\n\n  opts.maxSizeMB = opts.maxSizeMB || Number.POSITIVE_INFINITY;\n  const useWebWorker = typeof opts.useWebWorker === 'boolean' ? opts.useWebWorker : true;\n  delete opts.useWebWorker;\n  opts.onProgress = (aProgress) => {\n    progress = aProgress;\n    if (typeof onProgress === 'function') {\n      onProgress(progress);\n    }\n  };\n\n  if (!(file instanceof Blob || file instanceof CustomFile)) {\n    throw new Error('The file given is not an instance of Blob or File');\n  } else if (!/^image/.test(file.type)) {\n    throw new Error('The file given is not an image');\n  }\n\n  // try run in web worker, fall back to run in main thread\n  // eslint-disable-next-line no-undef, no-restricted-globals\n  const inWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n\n  if (process.env.BUILD === 'development') {\n    if ((useWebWorker && typeof Worker === 'function') || inWebWorker) {\n      console.log('run compression in web worker');\n    } else {\n      console.log('run compression in main thread');\n    }\n  }\n\n  if (useWebWorker && typeof Worker === 'function' && !inWebWorker) {\n    try {\n      // \"compressOnWebWorker\" is kind of like a recursion to call \"imageCompression\" again inside web worker\n      compressedFile = await compressOnWebWorker(file, opts);\n    } catch (e) {\n      if (process.env.BUILD === 'development') {\n        console.warn('Run compression in web worker failed:', e, ', fall back to main thread');\n      }\n      compressedFile = await compress(file, opts);\n    }\n  } else {\n    compressedFile = await compress(file, opts);\n  }\n\n  try {\n    compressedFile.name = file.name;\n    compressedFile.lastModified = file.lastModified;\n  } catch (e) {\n    if (process.env.BUILD === 'development') {\n      console.error(e);\n    }\n  }\n\n  return compressedFile;\n}\n\nimageCompression.getDataUrlFromFile = getDataUrlFromFile;\nimageCompression.getFilefromDataUrl = getFilefromDataUrl;\nimageCompression.loadImage = loadImage;\nimageCompression.drawImageInCanvas = drawImageInCanvas;\nimageCompression.drawFileInCanvas = drawFileInCanvas;\nimageCompression.canvasToFile = canvasToFile;\nimageCompression.getExifOrientation = getExifOrientation;\n\nimageCompression.handleMaxWidthOrHeight = handleMaxWidthOrHeight;\nimageCompression.followExifOrientation = followExifOrientation;\nimageCompression.cleanupCanvasMemory = cleanupCanvasMemory;\nimageCompression.isAutoOrientationInBrowser = isAutoOrientationInBrowser;\nimageCompression.approximateBelowMaximumCanvasSizeOfBrowser = approximateBelowMaximumCanvasSizeOfBrowser;\nimageCompression.getBrowserName = getBrowserName;\nimageCompression.version = __buildVersion__;\n\nexport default imageCompression;\n"]},"metadata":{},"sourceType":"module"}